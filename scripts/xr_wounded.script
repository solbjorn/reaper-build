----------------------------------------------------------------------------------------------------------------------
--  Схема раненого
--  автор: Диденко Руслан (Stohe)
--  TODO:
----------------------------------------------------------------------------------------------------------------------

local string_find = string.find
local string_sub = string.sub
local xr_meet_parse_data = xr_meet.parse_data

---------------------------------------------------------------------------------------------------------------------
--Evaluators
----------------------------------------------------------------------------------------------------------------------
class "evaluator_wound" (property_evaluator)
function evaluator_wound:__init(name, storage) super(nil, name)
    self.a = storage
end

function evaluator_wound:evaluate ()
  local npc=self.object
  if self.a.wounded_set ~= true then return false end
  if not self.a.regen then
    self.a.regen=npc:character_community()=="zombied" or npc:character_community()=="monolith"
  end

  local sobj=AI:object(npc:id())
  if npc.health>0.95 and self.a.regen and tostring(xr_logic.pstor_retrieve(self.object, "wounded_state")) ~= "nil" then
    sobj.wounded=false
    self.a.wound_manager:hit_callback()
  elseif tostring(xr_logic.pstor_retrieve(self.object, "wounded_state")) == "nil" and sobj.wounded then
    self.a.wound_manager:hit_callback()
  end
  if self.mgr == nil then
    self.mgr = self.object:motivation_action_manager()
  end
  if self.object:critically_wounded() == true then
    return false
  end
  if self.mgr:evaluator(stalker_ids.property_enemy):evaluate() and
     xr_logic.pstor_retrieve(self.object, "wounded_fight") == "true"
  then
    return false
  end
  return tostring(xr_logic.pstor_retrieve(self.object, "wounded_state")) ~= "nil"
end

class "evaluator_can_fight" (property_evaluator)
function evaluator_can_fight:__init(name, storage) super(nil, name)
    self.a = storage
end
function evaluator_can_fight:evaluate ()
  if self.object:critically_wounded() == true then
    return true
  end

    return xr_logic.pstor_retrieve(self.object, "wounded_fight") ~= "false"
end

----------------------------------------------------------------------------------------------------------------------
--Actions
----------------------------------------------------------------------------------------------------------------------
class "action_wounded" (action_base)
function action_wounded:__init(name, storage) super(nil, name)
    self.a = storage
end
function action_wounded:initialize ()
    action_base.initialize (self)
  self.object:set_desired_position()
  self.object:set_desired_direction()
  self.sound = "nil"
  if self.a.help_start_dialog then
    self.object:set_start_dialog(self.a.help_start_dialog)
  end
  if not self.a.regen then
		self.object:disable_trade()	-- Запрет торговли, пока раненый
    self.object:wounded(true)
  end
	news_main.on_wound(self.object)
end
function action_wounded:execute ()
    action_base.execute (self)

  if self.object:character_community()~="monolith" and
	self.object:character_community()~="zombied" then
	self.object:enable_talk()
  else
	self.object:disable_talk()
  end

	local wound_manager_state = xr_logic.pstor_retrieve(self.object, "wounded_state")
	local wound_manager_sound = xr_logic.pstor_retrieve(self.object, "wounded_sound")

  local synsound = nil
  if wound_manager_state == "true" then
    local h = hit()
    h.power = 0
    h.direction = self.object:direction()
    h.bone = "bip01_spine"
    h.draftsman = Actor
    h.impulse = 0
    h.type = hit.wound
    self.object:hit(h)
  else
    -- является ли текущий звук синхронным для текущего стейта
    for k,v in pairs(self.a.syndata) do
      if v.state == wound_manager_state and
         v.sound == wound_manager_sound
      then
        synsound = wound_manager_sound
      end
    end
    --' жрание аптечек и прочей срани.
    --' Использовать можно только если нам можно сейчас есть аптечку.
    if self.a.use_medkit == true then
      self.a.wound_manager:eat_medkit()
    end

		local victim = xr_logic.pstor_retrieve(self.object, "wounded_victim")
		if victim == "actor" then
			victim = Actor
		elseif tostring(victim) == "nil" then
			victim = nil
		else
			victim = AI:story_object(victim)
		end

		if wound_manager_state == "psy_shoot" then
			state_mgr.set_state(self.object, wound_manager_state, nil, nil, {look_object = victim}, {animation_nout = true}, synsound)
		else
			if not wound_manager_state or wound_manager_state == "nil" then
				wound_manager_state = "wounded"
			end
			state_mgr.set_state(self.object, wound_manager_state, nil, nil, {look_object = victim}, nil, synsound)
		end
  end

  if synsound == nil then
    -- нужно отыграть фоновый
    if self.sound ~= wound_manager_sound then
      self.sound = wound_manager_sound
      if self.sound == "nil" then
        xr_sound.set_sound(self.object, nil)
      else
        xr_sound.set_sound(self.object, wound_manager_sound)
      end
    end
  else
    -- нужно зарубить фоновый
    if self.sound ~= nil then
      self.sound = "nil"
      xr_sound.set_sound(self.object, nil)
    end
  end

  local tt = db.storage[self.object:id()]
  if tt.active_scheme and not self.object:is_talking() then
		xr_logic.try_switch_to_another_section(self.object, tt[tt.active_scheme])
  end
end

function action_wounded:finalize ()
    action_base.finalize (self)
    self.object:disable_talk()
    xr_sound.set_sound(self.object, nil)
	self.object:enable_trade()	-- вылечили - разрешаем торговлю
    self.object:wounded(false)
end

----------------------------------------------------------------------------------------------------------------------
-- Class wound_manager
----------------------------------------------------------------------------------------------------------------------
class "Cwound_manager"
function Cwound_manager:__init(npc, storage)
  self.npc = npc
  self.a = storage
  self.can_use_medkit = false
  self.medkit_eaten=nil
end

function Cwound_manager:update()
  local hp  = 100*self.npc.health
  local psy = 100*self.npc.psy_health
  local sobj=AI:object(self.npc:id())
  if sobj.wounded and (not self.a.regen) and (not self.medkit_eaten) then
    hp=1 -- симулируем раненость
  end

  self.state, self.sound = self:process_psy_wound(psy)

  if self.state == "nil" and
     self.sound == "nil"
  then
    -- проверяем на обычную раненость
    self.fight  = self:process_fight(hp)
    self.victim = self:process_victim(hp)
    self.state, self.sound = self:process_hp_wound(hp)
		if self.state~="nil" and sobj.wounded and self.medkit_eaten==true and hp>99 then --если были ранены, но потом кто-то полечил, но схема стоит "всегда раненый" - отпустить бота
			self.state="nil"
		end
  else
    -- устанавливаем пси раненость
    self.fight = "false"
    self.cover = "false"
    self.victim = "nil"
  end

  xr_logic.pstor_store(self.npc, "wounded_state", self.state)
  xr_logic.pstor_store(self.npc, "wounded_sound", self.sound)
  xr_logic.pstor_store(self.npc, "wounded_fight", self.fight)
  xr_logic.pstor_store(self.npc, "wounded_victim", self.victim)

	if self.state == nil or self.state == "nil" or self.npc:story_id() == 109 then
    self.medkit_eaten=nil
    sobj.wounded=false
		self.npc:wounded(false)
  else
    sobj.wounded=true
  end
end

function Cwound_manager:unlock_medkit()
  self.can_use_medkit = true
	xrs_medic.wounded[self.npc:id()] = nil
end

function Cwound_manager:eat_medkit()
	if self.can_use_medkit == true then
		local medkit_eaten=false
		if is_psy_wounded_by_id(self.npc:id()) then
			self.npc.psy_health=1.0
			medkit_eaten=true
		else
			if self.npc:object("medkit") ~= nil then
				self.npc:eat(self.npc:object("medkit"))
			self.npc.health = 0.5
				medkit_eaten=true
			elseif self.npc:object("medkit_army") ~= nil then
				self.npc:eat(self.npc:object("medkit_army"))
			self.npc.health = 0.75
				medkit_eaten=true
			elseif self.npc:object("medkit_scientic") ~= nil then
				self.npc:eat(self.npc:object("medkit_scientic"))
			self.npc.health = 1.0
				medkit_eaten=true
			end
		end
		if medkit_eaten then
			local sobj=server_object(self.npc:id())
			sobj.wounded = false -- позволяем выйти из состояния ранености
			self.npc:wounded(false)
			self.medkit_eaten=true
			self.can_use_medkit = false
		end		
	end
	self:hit_callback()
end
function Cwound_manager:process_fight(hp)
  local key = self:get_key_from_distance(self.a.hp_fight, hp)
  if key ~= nil then
    if self.a.hp_fight[key].state then
      return tostring(xr_logic.pick_section_from_condlist(self.npc, self.a.hp_fight[key].state))
    end
  end
  return "true"
end
function Cwound_manager:process_victim(hp)
  local key = self:get_key_from_distance(self.a.hp_victim, hp)
  if key ~= nil then
    if self.a.hp_victim[key].state then
      return tostring(xr_logic.pick_section_from_condlist(self.npc, self.a.hp_victim[key].state))
    end
  end
  return "nil"
end
function Cwound_manager:process_hp_wound(hp)
	local key = self:get_key_from_distance(self.a.hp_state, hp)
	if key ~= nil then
		local r1,r2, key_state
		if self.npc:see(Actor) then
			key_state = self.a.hp_state_see[key]
			if key_state.state then
				r1 = xr_logic.pick_section_from_condlist(self.npc, key_state.state)
			end
			if key_state.sound then
				r2 = xr_logic.pick_section_from_condlist(self.npc, key_state.sound)
			end
		else
			key_state = self.a.hp_state[key]
			if key_state.state then
				r1 = xr_logic.pick_section_from_condlist(self.npc, key_state.state)
			end
			if key_state.sound then
				r2 = xr_logic.pick_section_from_condlist(self.npc, key_state.sound)
			end
		end
		return tostring(r1),tostring(r2)
	end
	return "nil","nil"
end
function Cwound_manager:process_psy_wound(hp)
	local key = self:get_key_from_distance(self.a.psy_state, hp)
	if key ~= nil then
		local r1,r2
		local key_state = self.a.psy_state[key]
		if key_state.state then
			r1 = xr_logic.pick_section_from_condlist(self.npc, key_state.state)
		end
		if key_state.sound then
			r2 = xr_logic.pick_section_from_condlist(self.npc, key_state.sound)
		end
		return tostring(r1),tostring(r2)
	end
	return "nil","nil"
end
function Cwound_manager:get_key_from_distance(t, hp)
  local key
  for k,v in pairs(t) do
    if v.dist >= hp then
      key = k
    else
      return key
    end
  end
  return key
end
function Cwound_manager:hit_callback()
  if self.npc:alive() == false then
    return
  end

  if self.npc:critically_wounded() == true then
    return
  end

  self:update()
end

----------------------------------------------------------------------------------------------------------------------
-- binder
----------------------------------------------------------------------------------------------------------------------

local prop_wounded = xr_evaluators_id.sidor_wounded_base
local prop_can_fight = xr_evaluators_id.sidor_wounded_base + 1
local operator_wounded = xr_actions_id.sidor_act_wounded_base + 0
local state_mgr_to_idle_combat = xr_actions_id.state_mgr + 1
local state_mgr_to_idle_alife = xr_actions_id.state_mgr + 2
local xr_actions_id_alife = xr_actions_id.alife
local stalker_ids_action_gather_items = stalker_ids.action_gather_items
local stalker_ids_action_combat_planner = stalker_ids.action_combat_planner
local stalker_ids_action_danger_planner = stalker_ids.action_danger_planner
local stalker_ids_action_anomaly_planner = stalker_ids.action_anomaly_planner

local wp_stalker_ids_property_alive_true = world_property(stalker_ids.property_alive, true)
local wp_stalker_ids_property_enemy_false = world_property(stalker_ids.property_enemy, false)
local wp_prop_wounded_true = world_property(prop_wounded, true)
local wp_prop_wounded_false = world_property(prop_wounded, false)
local wp_prop_can_fight_true = world_property(prop_can_fight, true)

function add_to_binder(object, st)
    local manager = object:motivation_action_manager ()
    manager:add_evaluator (prop_wounded, this.evaluator_wound("wounded", st))
    manager:add_evaluator (prop_can_fight, this.evaluator_can_fight("can_fight", st))

    local action = this.action_wounded("wounded_action", st)
    action:add_precondition (wp_stalker_ids_property_alive_true)
    action:add_precondition (wp_prop_wounded_true)
    action:add_effect (wp_prop_wounded_false)
    action:add_effect (wp_stalker_ids_property_enemy_false)
    action:add_effect (wp_prop_can_fight_true)
   	manager:add_action      (operator_wounded, action)

	action = manager:action(state_mgr_to_idle_alife)
	action:add_precondition(wp_prop_wounded_false)
	
	action = manager:action(state_mgr_to_idle_combat)
	action:add_precondition(wp_prop_wounded_false)

    action = manager:action (xr_actions_id_alife)
    action:add_precondition (wp_prop_wounded_false)

    action = manager:action (stalker_ids_action_gather_items)
    action:add_precondition (wp_prop_wounded_false)

    action = manager:action (stalker_ids_action_combat_planner)
	action:add_precondition(wp_prop_wounded_false)
    action:add_precondition (wp_prop_can_fight_true)

    action = manager:action (stalker_ids_action_danger_planner)
	action:add_precondition(wp_prop_wounded_false)
    action:add_precondition (wp_prop_can_fight_true)

    action = manager:action (stalker_ids_action_anomaly_planner)
	action:add_precondition(wp_prop_wounded_false)
    action:add_precondition (wp_prop_can_fight_true)
end

------------
-- Вызывается только в начале на чтении логики, создает экшены, эвалуаторы и производит
-- первичную настройку.
function set_wounded(npc, ini, scheme, section)
  local st = xr_logic.assign_storage_and_bind(npc, ini, scheme, section)
  st.wound_manager = Cwound_manager(npc, st)
end
-- Вызывается на переключении на новую секцию. Производит вычитывание настроек из текущей секции.
function reset_wounded(npc, scheme, st, section)
  local wounded_section
	if scheme == nil or scheme == "nil" then
		section = st.section_logic
	end
	wounded_section = (st.ini:line_exist(section, "wounded") and st.ini:r_string(section, "wounded")) or nil
  init_wounded(npc, st.ini, wounded_section, st.wounded, scheme)
  st.wounded.wound_manager:hit_callback()
end
-- Функция чтения настроек. В нее передается секция, откуда их нужно читать.
local wounded_by_state = {
	"wounded",
	"wounded_heavy",
	"wounded_heavy_2",
	"wounded_heavy_3"
}

function init_wounded(npc, ini, section, st, scheme)
	local function get_field_string(field, default)
		return (ini:line_exist(section, field) and ini:r_string(section, field)) or default
	end

	section = tostring(section)
	if section == "nil" then
		st.wounded_section = "<nil>"
	else
		if section == st.wounded_section then
			return
		end
		st.wounded_section = section
	end

	local def = {}
	local npc_community = npc:character_community()
	if npc_community == "monolith" then
    local state = table.random(wounded_by_state)
    def.hp_state      = "50|"..state.."@nil"
    def.hp_state_see    = "50|"..state.."@nil"
    def.psy_state     = ""
    def.hp_victim     = "50|nil"
    def.hp_cover      = "50|false"
    def.hp_fight      = "50|false"
    def.syndata       = ""
    def.help_dialog     = nil
    def.help_start_dialog = nil
		def.use_medkit			= true

  elseif npc_community == "zombied" then
    def.hp_state      = "50|wounded_zombie@nil"
    def.hp_state_see    = "50|wounded_zombie@nil"
    def.psy_state     = ""
    def.hp_victim     = "50|nil"
    def.hp_cover      = "50|false"
    def.hp_fight      = "50|false"
    def.syndata       = ""
    def.help_dialog     = nil
    def.help_start_dialog = nil
    def.use_medkit      = false

  else
    local state = table.random(wounded_by_state)
    def.hp_state      = "10|"..state.."@help_heavy"
    def.hp_state_see    = "10|"..state.."@help_heavy"
    def.psy_state     = "50|{=best_pistol}psy_armed,psy_pain@wounded_psy|20|{=best_pistol}psy_shoot,psy_pain@{=best_pistol}wounded_psy_shoot,wounded_psy"
    def.hp_victim     = "10|nil"
    def.hp_cover      = "10|false"
    def.hp_fight      = "10|false"
    def.syndata       = ""
    def.help_dialog     = "dm_help_wounded_medkit_dialog"
    def.help_start_dialog = nil
    def.use_medkit      = true
  end

	if section == "nil" or not ini:section_exist(section) then
		-- Загружаем дефолты!
		st.hp_state		= xr_meet_parse_data(def.hp_state)
		st.hp_state_see	= xr_meet_parse_data(def.hp_state_see)
		st.psy_state	= xr_meet_parse_data(def.psy_state)
		st.hp_victim	= xr_meet_parse_data(def.hp_victim)
		st.hp_cover		= xr_meet_parse_data(def.hp_cover)
		st.hp_fight		= xr_meet_parse_data(def.hp_fight)
		st.syndata		= xr_meet.parse_syn_data(def.syndata)
		st.help_dialog	= def.help_dialog
		st.help_start_dialog = nil
		st.use_medkit   = def.use_medkit
	else
		st.hp_state		= xr_meet_parse_data(get_field_string("hp_state", def.hp_state))
		st.hp_state_see	= xr_meet_parse_data(get_field_string("hp_state_see", def.hp_state_see))
		st.psy_state	= xr_meet_parse_data(get_field_string("psy_state", def.psy_state))
		st.hp_victim	= xr_meet_parse_data(get_field_string("hp_victim", def.hp_victim))
		st.hp_cover		= xr_meet_parse_data(get_field_string("hp_cover", def.hp_cover))
		st.hp_fight		= xr_meet_parse_data(get_field_string("hp_fight", def.hp_fight))
		st.syndata		= xr_meet.parse_syn_data(get_field_string("syndata", def.syndata))
		st.help_dialog	= get_field_string("help_dialog", def.help_dialog)
		st.help_start_dialog = get_field_string("help_start_dialog", nil)
		if ini:line_exist(section, "use_medkit") then
			st.use_medkit = ini:r_bool(section, "use_medkit")
		else
			st.use_medkit = def.use_medkit
		end
	end

  -- флажок, что функция хотя бы раз вызывалась
  st.wounded_set = true
end

function unlock_medkit(npc)
	local id = npc:id()
	local wnd = db.storage[id].wounded
	if wnd ~= nil then
		wnd.wound_manager:unlock_medkit()
		xrs_medic.wounded[id] = nil
	end
end

function is_wounded(npc)
	local wnd = db.storage[npc:id()].wounded
	return wnd and tostring(wnd.wound_manager.state) ~= "nil" or false
end

function hit_callback(npc_id)
	local wnd = db.storage[npc_id].wounded
	if wnd then
		wnd.wound_manager:hit_callback()
	end
end

function is_heavy_wounded_by_id(npc_id)
	local wnd = db.storage[npc_id].wounded
	return wnd and tostring(wnd.wound_manager.state) ~= "nil" or false
end

local psy_wounded_states = table.tohash({
	"psy_pain", "psy_armed", "psy_shoot",
	"psycho_pain", "psycho_shoot"
})

function is_psy_wounded_by_id(npc_id)
	local wnd = db.storage[npc_id].wounded
	return wnd and psy_wounded_states[wnd.wound_manager.state] or false
end

-- Помощь раненому
function help_wounded(npc)
	if npc:name()=="esc_vagon_wounded" or npc:name()=="val_escort_bandit_halfdead" then return end

	amk.start_timer("healing_enemies", math.random(20, 30), npc:id(), npc:character_community())
	npc:set_character_community("stalker", 0, 0)
	npc:set_relation(game_object.friend, Actor)

	npc:enable_memory_object( Actor, false )
	local sobj = server_object(npc)
	if sobj then
		sobj:brain():can_choose_alife_tasks( false )
	end
end

	local smarts = {
		l01_escape = {
			esc2_most = {0,1},
			esc2_bandit_les = {0,1},
			esc2_smart_stalker_exit = {0,1},
			esc_farm_lager = {0,1},
			esc2_st_fox_place = {0,1}
		},
		l02_garbage = {
			gar_smart_graveyard = {0,1},
			gar_smart_garage = {0,1},
			gar_smart_bandit3 = {0,1},
			gar_smart_stalkers_1 = {0,1}
		},
		l03_agroprom = {
			agr2_st_factory = {0,1}
		},
		l03u_agr_underground = {
			agr2_st_factory = {0,1}
		},
		l04_darkvalley = {
			val_smart_bandit_1 = {0,3}
		},
		l04u_labx18 = {
			val_smart_bandit_1 = {0,1}
		},
		l06_rostok = {
			ros_smart_stalker1 = {1,2},
			ros_smart_stalker3 = {1,2},
			ros_smart_stalker_bandits1 = {1,2}
		},
		l07_military = {
			mil_smart_dolg_kamp = {2,3},
			mil_lager = {2,3}
		},
		l08_yantar = {
			yan_st_stalker2 = {1,2}
		},
		l10_radar = {
			rad2_loner_0000 = {2,3},
			rad2_loner_0001 = {2,3},
			rad2_loner_0002 = {2,3}
		},
		l11_pripyat = {
			pri_smart_neutral_stalker1 = {3,3},
			pri_stadium_help = {3,3}
		}
	}

local smarts_avail = {}
--local smarts_other = {}
local wound_id
function custom_change(npc)
	local obj = AI:object(npc:id())
	local packet_wounded = amk.read_stalker_params(obj)
	local level = level.name()
	local obj_rank = get_npc_rank(npc)
	if level and smarts[level] then
		for k,v in pairs(smarts) do
			for kk,vv in pairs(smarts[k]) do
				local smarts_rank_min = vv[1]
				local smarts_rank_max = vv[2]
				if obj_rank and obj_rank >= smarts_rank_min and obj_rank <= smarts_rank_max then
					local smart = AI:object(kk)
					if smart and smart:is_gulag_available() and smart.gulag_working then
						if string_find(level,string_sub(kk,1,3)) then
							table.insert(smarts_avail,smart)
						end
					end
				end
			end
		end
	end
	wound_id = npc:id()
	if smarts_avail and npc:alive() then
		if #smarts_avail > 1 then
			table.sort(smarts_avail,max_comp)
		end
		if #smarts_avail > 0 then
			packet_wounded.custom = "[smart_terrains]\n"..smarts_avail[1]:name().." = true"
			packet_wounded.health = 1
			packet_wounded.updhealth = 1
			amk.write_stalker_params(packet_wounded,obj)
		end
	end
	local unreg_id = obj:smart_terrain_id()
	if unreg_id ~= 65535 and npc:alive() then
		local unreg = AI:object(unreg_id)
		if unreg then
			unreg:unregister_npc(obj)
		end
	end

	-- dsh +
	obj.smart_terrain_conditions = nil
	obj:brain():can_choose_alife_tasks( true )
	obj:brain():update()
end

function get_npc_rank(obj)
	local sobj = AI:object(obj:id())
	if sobj and sobj.rank and sobj:rank()  then
		return math.floor(sobj:rank()/290)
	end
	return nil
end

function max_comp(i1,i2) -- возвращает true если i1 меньше i2
	if wound_id then
		local sobj = AI:object(wound_id)
		local sobj_pos = sobj.position
		return i1.position:distance_to(sobj_pos) < i2.position:distance_to(sobj_pos)
	end
end
