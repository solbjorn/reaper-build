----------------------------------------------------------------------------------------------------
-- Physic door control
----------------------------------------------------------------------------------------------------
-- Исходный скрипт: Evgeniy Negrobov (Jon) jon@gsc-game.kiev.ua
-- Перевод на xr_logic: Andrey Fidrya (Zmey) af@svitonline.com
-- Доработка: Oleg Kreptul (Haron) haronk@ukr.net
----------------------------------------------------------------------------------------------------

class "action_door"

function action_door:__init(obj, storage)
	self.object = obj
	self.st = storage
	self.snd_obj = nil
end
function action_door:reset_scheme(loading)
	self.initialized = false

	local ph_shell = self.object:get_physics_shell()
	if not ph_shell then
		return
	end
	self.joint = ph_shell:get_joint_by_bone_name("door")

	self.low_limits, self.hi_limits = 0, 0
	self.low_limits, self.hi_limits	= self.joint:get_limits(self.low_limits, self.hi_limits, 0)

	self.block = false
	self.soundless_block = false

	self.show_tips = self.st.show_tips

	local disable_snd
	-- Звук нужно отключить, только если скрипт двери для этого объекта используется
	-- впервые (т.е. после загрузки уровня или после загрузки сохраненной игры),
	-- иначе игрок услышит хлопок...
	if not self.st.script_used_more_than_once then
		disable_snd = true
		self.st.script_used_more_than_once = true
	end

	if self.st.closed then
		--' Если дверь уже закрыта - то нужно закрыть без звука
		if self:is_closed() then
			disable_snd = true
		end
		self:close_door(disable_snd)
	else
		self:open_door(disable_snd)
	end

	self.object:set_nonscript_usable(false)

	self.initialized = true
end

function action_door:door_play_snd_from_set(sndset)
    if self.snd_obj ~= nil then
       self.snd_obj:stop ()
       self.snd_obj = nil
    end

	self.snd_obj = xr_sound.get_sound_object(sndset, "random")
	if not self.snd_obj then
		abort("object '%s': unable to create a sound object for sound '%s' (soundset '%s')",
			self.object:name(), snd, sndset)
	end
	self.snd_obj:play_at_pos(self.object, self.object:position())
end

function action_door:update(delta)
	if not self.initialized then
		abort("object '%s': door failed to initialize", self.object:name())
	end

	xr_logic.try_switch_to_another_section(self.object, self.st)
end

function action_door:fastcall()
	if not self.initialized then
		return false
	end

	if self.block and self:is_closed() then
		self:close_action()
		return true
	end
	return false
end

function action_door:close_action()
	-- Закрыли до предела, будем блокировать
	if self.st.no_force == true then
		self.joint:set_max_force_and_velocity(0, 0, 0)
	else
		self.joint:set_max_force_and_velocity(10000, 1, 0)
	end
	self.block = false
	-- Отыграть звук когда дверь захлопнулась:
	if not self.soundless_block and self.st.snd_close_stop then
		self:door_play_snd_from_set(self.st.snd_close_stop)
	end
end

function action_door:open_door(disable_snd)
	if not disable_snd then
		if self.st.snd_open_start then
			self:door_play_snd_from_set(self.st.snd_open_start)
		end
	end

	if self.st.no_force == true then
		self.joint:set_max_force_and_velocity(0, 0, 0)
	else
		self.joint:set_max_force_and_velocity(2100, -3, 0)
	end
	self.block = false

	if self.show_tips and self.st.tip_close then
		self.object:set_tip_text(self.st.tip_close)
	end
end

function action_door:is_closed()
	local angle = self.joint:get_axis_angle(90)
	if angle <= self.low_limits then
		return true
	end
	return false
end

function action_door:close_door(disable_snd)
	if not disable_snd then
		if self.st.snd_close_start then
			self:door_play_snd_from_set(self.st.snd_close_start)
		end
	end

	-- Ставим коллбек для отлова окончания закрытия двери (чтобы заблокировать ее и проиграть звук, если нужно):
	self.object:set_fastcall(self.fastcall,self)
	self.object:set_fastcall(self.fastcall,self)
	self.object:set_fastcall(self.fastcall,self)

	if self.st.no_force == true then
		self.joint:set_max_force_and_velocity(0, 0, 0)
	else
		self.joint:set_max_force_and_velocity(200, 3, 0)
	end
	self.block = true -- Закрываем и блокируем
	self.soundless_block = disable_snd

	if self.show_tips then
		if self.st.locked == true and self.st.tip_unlock then
			self.object:set_tip_text(self.st.tip_unlock)
			return
		end

		if self.st.tip_open then
			self.object:set_tip_text(self.st.tip_open)
		end
	end
end

function action_door:try_switch()
	if self.st.on_use then
		if xr_logic.switch_to_section(self.object, self.st,
		   xr_logic.pick_section_from_condlist(self.object, self.st.on_use.condlist)) then
			return true
		end
	end
	return false
end

function action_door:use_callback(door, actor)
	if self.st.locked then
		if self.st.snd_open_start then
			self:door_play_snd_from_set(self.st.snd_open_start)
		end
	end

	if self:try_switch() then
		return
	end
end
function action_door:hit_callback(obj, amount, local_direction, who, bone_index)
	if self.st.hit_on_bone[bone_index] ~= nil then
		local section = xr_logic.pick_section_from_condlist(self.object, self.st.hit_on_bone[bone_index].state)
		xr_logic.switch_to_section(obj, self.st, section)
		return
	end
end
function action_door:deactivate()
	self.object:set_tip_text("")
end

---------------------------------------------------------------------------------------------------------------------
function add_to_binder(npc, storage)
	storage.actions[ action_door( npc, storage ) ] = true
end

function set_scheme(npc, ini, scheme, section, gulag_name)
	local function get_field_string(field, default)
		return (ini:line_exist(section, field) and ini:r_string(section, field)) or default
	end
	local function get_field_bool(field, default)
		if ini:line_exist(section, field) then return ini:r_bool(section, field) end
		return default or false
	end

	local st = xr_logic.assign_storage_and_bind(npc, ini, scheme, section)

	st.logic     = xr_logic.cfg_get_switch_conditions(ini, section, npc)

	if section and ini:section_exist(section) then
		st.closed    = get_field_bool("closed", true)
		st.locked    = get_field_bool("locked", false)
		st.no_force  = get_field_bool("no_force", false)

		st.show_tips = get_field_bool("show_tips", true)

		st.tip_open  = get_field_string("tip_open", "tip_door_open")
		st.tip_unlock  = get_field_string("tip_open", "tip_door_locked")
		st.tip_close = get_field_string("tip_close", "tip_door_close")

		st.snd_open_start  = get_field_string("snd_open_start", "trader_door_open_start")
		st.snd_close_start = get_field_string("snd_close_start", "trader_door_close_start")
		st.snd_close_stop  = get_field_string("snd_close_stop", "trader_door_close_stop")

		st.on_use    = xr_logic.cfg_get_condlist(ini, section, "on_use", npc)

	st.hit_on_bone = utils.parse_data_1v(npc, get_field_string("hit_on_bone"))
	else
		st.closed    = true
		st.locked    = false
		st.no_force  = false
		st.show_tips = true

		st.tip_open    = "tip_door_open"
		st.tip_unlock  = "tip_door_locked"
		st.tip_close   = "tip_door_close"

		st.snd_open_start  = "trader_door_open_start"
		st.snd_close_start = "trader_door_close_start"
		st.snd_close_stop  = "trader_door_close_stop"

		st.on_use    = nil

		st.hit_on_bone = utils.parse_data_1v(npc, nil)
	end
end
