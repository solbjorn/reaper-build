--*********************************************************************************************************
--==============================================================================================
log1("--LUA version: ["..(jit.version or _VERSION).."]")
--==============================================================================================
FFI = require('ffi') --Делать только здесь и только один раз!
--==============================================================================================
math.randomseed(os.time())
--=================================[CUIScriptWnd Extension]=====================================
-- Вызов обычный, как и в AddCallback, но после последнего аргумента можно передавать множество дополнительных.
function CUIScriptWnd:Connect(name, event, func, ...)
	if ... ~= nil then
		local args = { ... }
		return self:AddCallback(name, event, function() func(self, unpack(args)) end)
	else
		return self:AddCallback(name, event, func, self)
	end
end
--==============================================================================================
function cmd(scmd, ...)
	local args = {...}
	if #args > 0 then
		scmd = scmd..' '..table.concat(args, ' ')
	end
	console:execute(scmd)
end
--==============================================================================================

local early_modules = {
	[1]	= { "sa_init", "xr_extensions" },
	[2]	= { "lua_ext", "reap_lua" }
}

function do_early(n)
	local stage = early_modules[n]

	for _, mod in ipairs(stage) do
		if not _G[mod] then
			fail(mod .. " is nil")
		end
	end

	early_modules[n] = nil
	if table.size(early_modules) == 0 then
		early_modules = nil
		do_early = nil
	end
end

screen = device()
refactor = 1

do_early(1)

schemes = {} -- соответствие схем модулям
stypes = {} -- типы схем

-- Загружает схему из файла на диске и активирует в мотиваторе.
-- Здесь:
--  filename - имя файла, в котором реализована схема, без расширения
--  scheme - имя схемы
function load_scheme(filename, scheme, stype)
  schemes[scheme] = filename
  stypes[scheme] = stype
	if not _G[filename] then
		abort("[ERROR]: Scheme file %s.script is not valid!", tostring(filename))
	end
end

-- Глобальные singletone классы
config = system_ini()
console = get_console()

-- Следующие singletone классы задаются в start_game_callback
AI = nil
netpacket = nil

-- before_objs_load_callback
graph = nil

-- В after_objs_load_callback
container = nil
freeplay_stats = nil
random_task = nil
Treasure = nil
Variable = nil

-- В bind_actor.net_spawn
Actor = nil
AObj = nil
Inventory = nil
hud = nil
Arena = nil
Dream = nil

curr_level = nil
time_real_ms = nil
time_game_ct = nil
time_game_hours = nil

do_early(2)

function init_clsids()
	clsid_script_stalker = clsid.script_stalker
	clsid_car = clsid.car
	clsid_actor = clsid.actor
	clsid_smart_terrain = clsid.smart_terrain
	clsid_bloodsucker_s = clsid.bloodsucker_s

	init_clsids = nil
end

-- Старт игры
function start_game_callback()
	init_clsids()
	xrs_grenade.init_clsids()

	AI = alife()
	netpacket = m_netpk.c_net_packet()
	game.get_start_time()

	local death = ini_file("misc\\death_generic.ltx")
	ammo_section = death:key_true("ammo_sections")
	quest_section = death:key_true("keep_items")

	news_manager.prepare_data()
	xr_info.init()

	xr_sound.clear_all_sound_object()
	dialog_manager.fill_phrase_table()

	iam_any.iAmAnyInit()
	--AMK UTILS--
	amk.on_game_start()
	--AMK UTILS--

	start_game_callback = nil
end

function before_objs_load_callback()
	graph = game_graph()

	before_objs_load_callback = nil
end

function after_objs_load_callback() --калбек вызывается после загрузки объектов из сейва
	-- Чтение контейнера и создание классов из его данных
	container = keyvals()
	Variable = xr_logic.CVariable()
	freeplay_stats = xr_statistic_freeplay.freeplay_statistic()
	random_task = task_manager.CRandomTask()
	Treasure = treasure_manager.CTreasure()

	after_objs_load_callback = nil
end

-- запущена ли игра
function game_is_running()
	return level.present() and actor_flags.alive
end

-- Короткие имена для частых функций
voice = xr_sound.get_safe_sound_object
sms = news_manager.send_tip
translate = game.translate_string

-- метки на карте
map_spot = level.map_add_object_spot_ser
level_map_spot = level.map_add_object_spot
has_map_spot = level.map_has_object_spot
del_map_spot = level.map_remove_object_spot

-- переменные
function set_value(var, value)
	return Variable:set(var, value)
end
function get_value(var, default, delete)
	return Variable:get(var, default, delete)
end
function del_value(var)
	return Variable:del(var)
end
function has_value(var)
	return Variable:has(var)
end

-- Инвентарь ГГ, объявляется в bind_actor.net_spawn
function has(s, i)
	return Inventory:has(s, i)
end
function has_good(s, i)
	return Inventory:has_good(s, i)
end
function got(s, i)
	Inventory:got(s, i)
end
function lost(s, i)
	Inventory:lost(s, i)
end
function lost_good(s, i)
	Inventory:lost(s, i, true)
end
function transfer(v, s, t)
	Inventory:transfer(v, s, t)
end

function transfer_good(v, s, t)
	Inventory:transfer(v, s, t, true)
end

function has_bad(s, i)
	return Inventory:has_bad(s, i)
end

function has_random(s, i)
	return Inventory:has_random(s, i)
end

function has_random_good(s, i)
	return Inventory:has_random_good(s, i)
end

function got_random(s, i)
	Inventory:got_random(s, i)
end

function lost_random(s, i)
	Inventory:lost_random(s, i)
end

function lost_random_good(s, i)
	Inventory:lost_random(s, i, true)
end

function transfer_random_good(v, s, t)
	Inventory:transfer_random(v, s, t, true)
end

function has_random_bad(s, i)
	return Inventory:has_random_bad(s, i)
end

function condition_item(s)
	return config:r_bool_cache(s, "degradable") == true
end

-- Спавн секции в инвентарь актора без вывода сообщения
function got_item(s)
	return create(s, xyz(), 0, 0, 0)
end

function got_item_random(s)
	return create_random(s, xyz(), 0, 0, 0)
end

-- Деньги
function got_money(m)
	Actor:give_money(m)
	news_manager.relocate_money("in", m)
end
function lost_money(m)
	Actor:give_money(-m)
	news_manager.relocate_money("out", m)
end
function has_money(m)
	return Actor:money() >= m
end

-- Проиграть звук
function say(s, vol)
	if type(s) == "string" then s = voice(s) end
	s:play_no_feedback(Actor, sound_object.s2d, 0, xyz(), vol or 1)
end

-- Вместо has_alife_info, AI:has_info, Actor:has_info
function has_info(i)
	return AI:has_info(0,i)
end
has_alife_info = has_info

-- Вместо Actor:give_info_portion
function give_info(i)
	return Actor:give_info_portion(i)
end

-- Вместо Actor:disable_info_portion
function disable_info(i)
	return Actor:disable_info_portion(i)
end

-- Вместо AI:create() все варианты
function create(...)
	return AI:create(...)
end

function create_random(sect, ...)
	return AI:create(table.fastrand(reap.random_skin(sect)), ...)
end

-- Вместо AI:release(), AI:release(AI:object(id|name)) со всеми проверками.
-- В качестве параметра можно передавать серверный объект, клиентский объект и просто id. Для объектов алспауна можно передавать name.
function release(o)
	if not o then return end

	o = server_object(o)
	if o then
		AI:release(o)
	end
end

-- Вместо AI:object(id|name)
-- В качестве параметра можно передавать серверный объект, клиентский объект и просто id. Для объектов алспауна можно передавать name.
function server_object(o)
	if not o then return nil end

	if type(o) ~= "userdata" then		-- id или name
		return AI:object(o)
	elseif o.section_name then			-- серверный объект
		return AI:object(o.id)
	else								-- клиентский объект
		return AI:object(o:id())
	end
end

-- Вместо AI:story_object()
function story_object(o)
	return AI:story_object(o)
end

-- Уровень, на котором находится объект
function object_level(o)
	return graph:vertex(o.m_game_vertex_id or o:game_vertex_id()):level_id()
end

-- Название уровня, на котором находится объект
function object_level_name(o)
	return AI:level_name(object_level(o))
end

-- Вместо level.object_by_id()
level_object = level.object_by_id

-- Вместо level_object_by_sid()
function level_story_object(sid)
	local o = story_object(sid)
	return o and level_object(o.id)
end
level_object_by_sid = level_story_object

-- Получение id по story_id
function id_by_sid(sid)
	local o = story_object(sid)
	return o and o.id
end

-- Это использовать только при разовых указаниях позиции для create и т.п. Для всего остального использовать свой экземпляр класса vector().
local pos_only = vector()
function xyz(x,y,z)
	return pos_only:set(x or 0, y or 0, z or 0)
end

-- Запуск таймера
timer = nil

-- Спавн/удаление особых объектов

-- Спавн телепортов
function create_teleport(section, pos, lv, gv)
	local o = AI:create(section, pos, lv, gv)
	set_value(section, o.id)
	return o
end

-- Удаление телепортов
function release_teleport(section)
	release(get_value(section, -1, true))
end

-- Вывод в лог
function log(fmt,...)
	log1(string.format(tostring(fmt), ...))
end

function action(obj,...)
    local arg = {...}
    local act = entity_action()
    local i = 1
    while true do
        if (arg[i] ~= nil) then
            act:set_action(arg[i])
        else
            break
        end
        i = i + 1
    end
    if (obj ~= nil) then
        obj:command(act,false)
    end
    return  entity_action(act)
end

function distance_between(obj1, obj2)
    return obj1:position():distance_to(obj2:position())
end

function reset_action(npc, name)
	if npc:get_script() then
		npc:script(false, name)
	end

	npc:script(true, name)
end

-- Константа, которую использовать в местах, где нужно задать неограниченное время действия
time_infinite = 100000000

-- Рандомный выбор из списка параметров
function random_choice(...)
	return table.fastrand({ ... })
end

function is_object_online(obj_id)
	return level_object(obj_id) ~= nil
end

-- Вычисляет yaw в радианах
function yaw(v1, v2)
	return math.acos( ( (v1.x*v2.x) + (v1.z*v2.z ) ) / math.sqrt((v1.x*v1.x + v1.z*v1.z ) * (v2.x*v2.x + v2.z*v2.z )) )
end

function yaw_degree(v1, v2)
	return (math.acos( ( (v1.x*v2.x) + (v1.z*v2.z ) ) / math.sqrt((v1.x*v1.x + v1.z*v1.z ) * (v2.x*v2.x + v2.z*v2.z )) ) * 57.2957)
end
function yaw_degree3d(v1, v2)
	return (math.acos((v1.x*v2.x + v1.y*v2.y + v1.z*v2.z)/math.sqrt((v1.x*v1.x + v1.y*v1.y + v1.z*v1.z )*(v2.x*v2.x + v2.y*v2.y + v2.z*v2.z)))*57.2957)
end

function vector_cross (v1, v2)
    return vector ():set (v1.y  * v2.z  - v1.z  * v2.y, v1.z  * v2.x  - v1.x  * v2.z, v1.x  * v2.y  - v1.y  * v2.x)
end

-- Вращает вектор вокруг оси y против часовой стрелки
function vector_rotate_y (v, angle)
    angle = angle * 0.01745329252
    local c = math.cos (angle)
    local s = math.sin (angle)
    return vector ():set (v.x * c - v.z * s, v.y, v.x * s + v.z * c)
end

function stop_play_sound(obj)
  if obj:alive() == true then
    obj:set_sound_mask(-1)
    obj:set_sound_mask(0)
  end
end

function switch_online(id)
	if id == -1 then return end
	AI:set_switch_online(id, true)
	AI:set_switch_offline(id, false)
end

function switch_offline(npc)
	if not npc or ((npc:is_stalker() or npc:is_monster()) and not npc:alive()) then return end
	local id = npc:id()
	AI:set_switch_online(id, false)
	AI:set_switch_offline(id, true)
end

-- быстрый if
function iif(t,t1,t2)
	return t and t1 or t2
end

-- Крешнуть игру (после вывода сообщения об ошибке в лог)
function abort(fmt, ...)
	fmt = tostring(fmt)
	local reason = ... == nil and fmt or string.format(fmt, ...)

	log1("FATAL ERROR: " .. reason)
	log1(debug.traceback())
	error(reason)

	console:execute("quit")
end

function set_inactivate_input_time(delta)
	db.storage[0].disable_input_time = game.get_game_time()
	db.storage[0].disable_input_idle = delta
	level.disable_input()
end

-- проверяет целую часть числа на нечётность
function odd(x)
	return math.fmod(x, 2) >= 1
end

--' Усталость
function on_actor_critical_power()
end

function on_actor_critical_max_power()
end

--' Кровотечение
function on_actor_bleeding()
end

function on_actor_satiety()
end

--' Радиация
function on_actor_radiation()
end

--' Заклинило оружие
function on_actor_weapon_jammed()
end

--' не может ходить изза веса
function on_actor_cant_walk_weight()
end

--' пси воздействие
function on_actor_psy()
end

--' инвентарное название объекта
function get_inv_name(section)
	return translate(config:r_string(section, "inv_name"))
end

function get_texture_info(id_name, id_default)
  if id_default == nil then id_default = id_name end

  local task_info = GetTextureInfo(id_name, id_default)
  local r = task_info:get_rect()

  r.x2 = r.x2 - r.x1
  r.y2 = r.y2 - r.y1
  return task_info:get_file_name(), r
end

function get_icon_info(sect, real)
	local mul = real and 50 or 1

	return {
		x	= config:r_u32_cache(sect, "inv_grid_x") * mul,
		y	= config:r_u32_cache(sect, "inv_grid_y") * mul,
		w	= config:r_u32_cache(sect, "inv_grid_width") * mul,
		h	= config:r_u32_cache(sect, "inv_grid_height") * mul
	}
end
