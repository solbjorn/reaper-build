if (jit == nil) then
  profiler.setup_hook ()
end

prefetch("sa_init")

db_actor = nil
db_actor_id = 0
g_alife = nil

local string_gfind = string.gfind

schemes = {} -- ёююЄтхЄёЄтшх ёїхь ьюфєы ь
stypes = {} -- Єшя√ ёїхь

-- ╟руЁєцрхЄ ёїхьє шч Їрщыр эр фшёъх ш ръЄштшЁєхЄ т ьюЄштрЄюЁх.
-- ╟фхё№:
--  filename - шь  Їрщыр, т ъюЄюЁюь Ёхрышчютрэр ёїхьр, схч Ёрё°шЁхэш 
--  scheme - шь  ёїхь√
function load_scheme(filename, scheme, stype)
  schemes[scheme] = filename
  stypes[scheme] = stype
	if not _G[filename] then
		abort("[ERROR]: Scheme file %s.script is not valid!", tostring(filename))
	end
end

----------------------------------------------------------------------

function printf(fmt,...)
end

----------------------------------------------------------------------
if nil == time_global then
  time_global = function () return device():time_global() end
end

function action(obj,...)
    local arg = {...}
    local act = entity_action()
    local i = 1
    while true do
        if (arg[i] ~= nil) then
            act:set_action(arg[i])
        else
            break
        end
        i = i + 1
    end
    if (obj ~= nil) then
        obj:command(act,false)
    end
    return  entity_action(act)
end

function distance_between(obj1, obj2)
    return obj1:position():distance_to(obj2:position())
end

--// ┼ёыш юфшэ юс·хъЄ nil, эряЁшьхЁ эхЄ ръЄхЁр, Єю ёўшЄрхь, ўЄю юэ фрыхъю
function distance_between_safe(obj1, obj2)
    if(obj1 == nil or obj2 == nil) then return 100000 end
  return obj1:position():distance_to(obj2:position())
end


--' ╧ЁютхЁър эр шэЇюяюЁ°э√, фрцх хёыш шуЁюър эх ёє∙хёЄтєхЄ
function has_alife_info(info_id)
	local aa = alife()
	return (aa and aa:has_info(0, info_id)) or false
end

function reset_action (npc, script_name)
    if npc:get_script () then
       npc:script (false, script_name)
    end
    npc:script (true, script_name)
end

--------------------------------------------------
-- Functions and variables added by Zmey
--------------------------------------------------

-- │юэёЄрэЄр, ъюЄюЁє│ шёяюы№чютрЄ№ т ьхёЄрї, уфх эєцэю чрфрЄ№ эхюуЁрэшўхээюх тЁхь  фхщёЄтш 
time_infinite = 100000000

function random_choice(...)
    local arg = {...}
    local r = math.random(1, #arg)
    return arg[r]
end

function new_action(...)
    local arg = {...}
    local act = entity_action()
    for i = 1, #arg do
        act:set_action(arg[i])
    end
    return act;
end

function if_then_else(cond, if_true, if_false)
    if cond then
        return if_true
    end
    return if_false
end

--------------------------------------------------------------------------------
class "enabled_evaluator" (property_evaluator)

function enabled_evaluator:__init (name, storage) super ()
    self.a = storage
end

function enabled_evaluator:evaluate()
    return  self.a.enabled
end

-- парсит строку вида "ааа, ббб, ввв..." в таблицу { "ааа", "ббб", "ввв", ... }
-- Чугай
function parse_names( s )
    local t = {}
    for name in string_gfind( s, "([%w_\\]+)%p*" ) do
        t[#t+1] = name
    end

    return t
end


function parse_key_value( s )
  if s == nil then
    return nil
  end
    local t = {}
    local key, nam = nil, nil
    for name in string_gfind( s, "([%w_\\%-]+)[,%s]*" ) do
    if key == nil then
      key = name
    else
      t[key] = name
      key = nil
    end
    end
    return t
end

-- парсит строку вида "n1, n2, n3..." в таблицу { n1, n2, n3, ... } где n1, n2, n3... - дробные числа
function parse_nums( s )
  local t = {}

  for entry in string_gfind( s, "([%d%.]+)%,*" ) do
    t[#t+1] = tonumber( entry )
  end

  return t
end

-- проверяет, есть ли объект в онлайне
function is_object_online(obj_id)
  return level.object_by_id(obj_id) ~= nil
end

function init_clsids()
	clsid_crow = clsid.crow
	clsid_script_stalker = clsid.script_stalker
	clsid_script_trader = clsid.script_trader

	clsid_wpn_ammo = clsid.wpn_ammo
	clsid_equ_stalker_s = clsid.equ_stalker_s
	clsid_wpn_grenade_f1 = clsid.wpn_grenade_f1
	clsid_wpn_grenade_fake = clsid.wpn_grenade_fake
	clsid_wpn_grenade_rgd5 = clsid.wpn_grenade_rgd5

	clsid_actor = clsid.actor
	clsid_smart_terrain = clsid.smart_terrain
	clsid_level_changer = clsid.level_changer

	clsid_bloodsucker_s = clsid.bloodsucker_s
	clsid_snork_s = clsid.snork_s
	clsid_zombie_s = clsid.zombie_s
	clsid_rat_s = clsid.rat_s

	clsid_wpn_ak74_s = clsid.wpn_ak74_s
	clsid_wpn_bm16_s = clsid.wpn_bm16_s
	clsid_wpn_walther_s = clsid.wpn_walther_s
end

function get_clsid(npc)
	return npc and npc:clsid()
end

-- проверяет оружие ли это (передавать game_object)
function isWeapon(object)
	local id = (object and object:clsid()) or 0

	return (id >= clsid_wpn_bm16_s and id <= clsid_wpn_walther_s) or id == clsid_wpn_ak74_s or
	       id == clsid_wpn_grenade_f1 or id == clsid_wpn_grenade_rgd5 or
	       id == clsid_wpn_grenade_fake
end

--Tvўшёы хЄ yaw т Ёрфшрэрї
function yaw( v1, v2 )
    return  math.acos( ( (v1.x*v2.x) + (v1.z*v2.z ) ) / ( math.sqrt(v1.x*v1.x + v1.z*v1.z ) * math.sqrt(v2.x*v2.x + v2.z*v2.z ) ) )
end

function yaw_degree( v1, v2 )
    return  (math.acos( ( (v1.x*v2.x) + (v1.z*v2.z ) ) / ( math.sqrt(v1.x*v1.x + v1.z*v1.z ) * math.sqrt(v2.x*v2.x + v2.z*v2.z ) ) ) * 57.2957)
end
function yaw_degree3d( v1, v2 )
    return  (math.acos((v1.x*v2.x + v1.y*v2.y + v1.z*v2.z)/(math.sqrt(v1.x*v1.x + v1.y*v1.y + v1.z*v1.z )*math.sqrt(v2.x*v2.x + v2.y*v2.y + v2.z*v2.z)))*57.2957)
end

function vector_cross (v1, v2)
    return vector ():set (v1.y  * v2.z  - v1.z  * v2.y, v1.z  * v2.x  - v1.x  * v2.z, v1.x  * v2.y  - v1.y  * v2.x)
end

--//┬Ёр∙рхЄ тхъЄюЁ тюъЁєу юёш y яЁюЄшт ўрёютющ ёЄЁхыъш

function vector_rotate_y (v, angle)
    angle = angle * 0.01745329252
    local c = math.cos (angle)
    local s = math.sin (angle)
    return vector ():set (v.x * c - v.z * s, v.y, v.x * s + v.z * c)
end

-- юўшёЄър ЄрсышЎ√
function clear_table (t)
	local table_remove = table.remove
	while #t > 0 do
		table_remove (t, #t)
	end
end

--Использует для монстров. Выбор точки, куда идти в некотором радиусе и чтоб точка была дальше на расстоянии
-- min_radius от текущей позиции(если это получится). center_id - центр позиции, вокруг которой живем,
-- position_id - тукущая позиция, radius - в каком радиусе выбирать точку, min_radius - минимальное расстояние, от текущей позиции до новой точки.
function new_point(center_id, position_id,radius, min_radius)
    local math_random =  math.random
    local dir = vector():set(math_random(-1000, 1000)/1000.0, 0.0001, math_random(-1000, 1000)/1000.0)
    local pos = level.vertex_in_direction(center_id, dir, radius)
    local i   = 1

    while(level.vertex_position(position_id):distance_to(level.vertex_position(pos) ) < min_radius and i < 20) do
        dir = vector():set(math_random(-1000, 1000)/1000.0, 0.0001, math_random(-1000, 1000)/1000.0)
        pos = level.vertex_in_direction(center_id, dir, radius)
        i   = i + 1
    end

    return (level.vertex_position(pos))
end

function stop_play_sound(obj)
  if obj:alive() == true then
    obj:set_sound_mask(-1)
    obj:set_sound_mask(0)
  end
end

--// ▀ты хЄё  ыш юbj ьюэёЄЁюь
function is_object_monster(obj)
	local otype = (obj and obj:clsid()) or 0
	return (otype >= clsid_bloodsucker_s and otype <= clsid_zombie_s) or otype == clsid_rat_s or otype == clsid_crow
end

--возвращает произвольную точку пути у которой установлен бит
function point_with_bit(patrol_path, bit, old_point)      -- old_point - индекс точки, которую не надо выбирать,
  local points = {}                                       -- параметр не обязательный( например текущей точки )

    for i = 0, patrol_path:count()-1 do
      --Добовляем в таблицу точки с нужным битом
      if( patrol_path:flag(i, bit)) then
            --Добавляем точку если old_point == nil или новая точка не совпадает с old_point
            if(old_point == nil) then
                points[#points+1] = patrol_path:point(i)
            elseif(old_point ~= i) then
                points[#points+1] = patrol_path:point(i)
            end
        end
    end

    local number_point = #points

    if(number_point == 0) then
        return nil
    elseif(number_point == 1) then
        return points[1]
    else
        return points[math.random(1, number_point)]
    end
end

--возвращает произвольную точку пути у которой установлен бит
function point_with_bit_id(patrol_path, bit, old_point)        -- old_point - индекс точки, которую не надо выбирать,
    local points = {}                                          -- параметр не обязательный( например текущей точки )

    for i = 0, patrol_path:count()-1 do
      --Добовляем в таблицу точки с нужным битом
      if( patrol_path:flag(i, bit)) then
            --Добавляем точку если old_point == nil или новая точка не совпадает с old_point
            if(old_point == nil) then
                points[#points+1] = i
            elseif(old_point ~= i) then
                points[#points+1] = i
            end
        end
    end

    local number_point = #points

    if(number_point == 0) then
        return nil
    elseif(number_point == 1) then
        return patrol_path:level_vertex_id(points[1])
    else
        return patrol_path:level_vertex_id(points[math.random(1, number_point)])
    end
end

--Возвращает индекс самой ближней точки пути с заданым битом, от текущей точки
function near_point_with_bit(point, patrol_path, bit)
    local new_point = nil
    local index     = nil
    local dist      = 1000.0

    for i = 0, patrol_path:count()-1 do
        if( patrol_path:flag(i, bit) ) then
            if(new_point == nil or patrol_path:point(i):distance_to(point) < dist) then
                --Если эта точка первая из нашедшихся, либо от нее путь ближе, то запоминаем ее
                new_point   = patrol_path:point(i)
                index       = i
                dist        = new_point:distance_to(point)
             end
        end
    end

    return index
end

-- Рекурсивная распечатка таблицы
function print_table(table, subs)
end

-------------------------------------------------------------------------------------------
function switch_online (id)
    if id == -1 then return end
    local sim = alife ()
    if sim ~= nil then
       sim:set_switch_online  (id, true)
       sim:set_switch_offline (id, false)
    end
end
-------------------------------------------------------------------------------------------
function switch_offline (npc)
    if npc == nil or npc:alive () == false then return end
    local sim = alife ()
    if sim ~= nil then
       sim:set_switch_online  (npc:id (), false)
       sim:set_switch_offline (npc:id (), true)
    end
end
-------------------------------------------------------------------------------------------
function IsMonster (object, class_id)
	local id = class_id or (object and object:clsid()) or 0
	return (id >= clsid_bloodsucker_s and id <= clsid_zombie_s) or id == clsid_rat_s
end
-------------------------------------------------------------------------------------------
function IsStalker (object, class_id)
	local id = class_id or (object and object:clsid()) or 0
	return id == clsid_script_stalker or id == clsid_actor
end
-------------------------------------------------------------------------------------------
function level_object_by_sid( sid )
  local sim = alife()

  if sim then
    local se_obj = sim:story_object( sid )
    if se_obj then
      return level.object_by_id( se_obj.id )
    end
  end

  return nil
end

function id_by_sid( sid )
  local sim = alife()

  if sim then
    local se_obj = sim:story_object( sid )
    if se_obj then
      return se_obj.id
    end
  end

  return nil
end

-- ╩Ёх°эєЄ№ шуЁє (яюёых т√тюфр ёююс∙хэш  юс ю°шсъх т ыюу)
function abort(fmt, ...)
	fail(string.format(tostring(fmt), ...))
end

function set_inactivate_input_time(delta)
	db.storage[db_actor_id].disable_input_time = game.get_game_time()
	db.storage[db_actor_id].disable_input_idle = delta
	level.disable_input()
end

-- яЁютхЁ хЄ Ўхыє■ ўрёЄ№ ўшёыр эр эхў╕ЄэюёЄ№
function odd( x )
  return math.floor( x * 0.5 ) * 2 == math.floor( x )
end

--' ╙ёЄрыюёЄ№
function on_actor_critical_power()
	if not alife():has_info(0, "encyclopedy_tutorial_weakness") then
		if alife():has_info(0, "esc_trader_newbie") then
			game.start_tutorial("part_11_weakness")
		end
		db_actor:give_info_portion("encyclopedy_tutorial_weakness")
	end
end

function on_actor_critical_max_power()
end

--' ╩ЁютюЄхўхэшх
function on_actor_bleeding()
	if not alife():has_info(0, "encyclopedy_tutorial_wound") then
		if alife():has_info(0, "esc_trader_newbie") then
			game.start_tutorial("part_8_wound")
		end
		db_actor:give_info_portion("encyclopedy_tutorial_wound")
	end
end

function on_actor_satiety()
end

--' ╨рфшрЎш 
function on_actor_radiation()
	if not alife():has_info(0, "encyclopedy_tutorial_radiation") then
		if alife():has_info(0, "esc_trader_newbie") then
			game.start_tutorial("part_6_radiation")
		end
		db_actor:give_info_portion("encyclopedy_tutorial_radiation")
	end
end

--' ╟ръышэшыю юЁєцшх
function on_actor_weapon_jammed()
	if not alife():has_info(0, "encyclopedy_tutorial_weapon") then
		if alife():has_info(0, "esc_trader_newbie") then
			game.start_tutorial("part_9_weapon")
		end
		db_actor:give_info_portion("encyclopedy_tutorial_weapon")
	end
end

--' эх ьюцхЄ їюфшЄ№ шччр тхёр
function on_actor_cant_walk_weight()
end

--' яёш тючфхщёЄтшх
function on_actor_psy()
end

function get_texture_info(id_name, id_default)
  if id_default == nil then id_default = id_name end

  local task_info = GetTextureInfo(id_name, id_default)
  local r = task_info:get_rect()

  r.x2 = r.x2 - r.x1
  r.y2 = r.y2 - r.y1
  return task_info:get_file_name(), r
end

function start_game_callback()
	init_clsids()
	fill_ammo_section()

	g_alife = alife()

  task_manager.clear_task_manager()
  treasure_manager.clear_treasure_manager()
  xr_sound.clear_all_sound_object()
  dialog_manager.fill_phrase_table() 

  --AMK UTILS--
  amk.on_game_start(obj)
  amk_utils.start_game()
  --AMK UTILS--
end

ammo_section = { }

function fill_ammo_section()
	local ini = ini_file("misc\\death_generic.ltx")

	local n = ini:line_count("ammo_sections")
	local result, id, value
	for i = 0, n - 1 do
		result, id, value = ini:r_line("ammo_sections", i, "", "")
		ammo_section[id] = true
	end
end
