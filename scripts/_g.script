if not jit then fail("JIT is nil") end

screen = device()
refactor = 1

prefetch("sa_init")
prefetch('xr_extensions')

math.randomseed(os.time())

schemes = {} -- соответствие схем модулям
stypes = {} -- типы схем

-- Загружает схему из файла на диске и активирует в мотиваторе.
-- Здесь:
--  filename - имя файла, в котором реализована схема, без расширения
--  scheme - имя схемы
function load_scheme(filename, scheme, stype)
  schemes[scheme] = filename
  stypes[scheme] = stype
	if not _G[filename] then
		abort("[ERROR]: Scheme file %s.script is not valid!", tostring(filename))
	end
end

-- Глобальные singletone классы
config = system_ini()
console = get_console()
graph = game_graph()

-- Следующие singletone классы задаются в start_game_callback
AI = nil
netpacket = nil

-- В init_container
container = nil
freeplay_stats = nil
random_task = nil
Treasure = nil
Variable = nil

-- В bind_actor.net_spawn
Actor = nil
Inventory = nil
hud = nil
Arena = nil
Dream = nil

curr_level = nil
time_real_ms = nil
time_game_ct = nil
time_game_hours = nil

prefetch("lua_ext")
prefetch("reap_lua")

function init_clsids()
	clsid_script_stalker = clsid.script_stalker
	clsid_car = clsid.car
	clsid_actor = clsid.actor
	clsid_smart_terrain = clsid.smart_terrain
	clsid_bloodsucker_s = clsid.bloodsucker_s
end

-- Старт игры
function start_game_callback()
	init_clsids()

	AI = alife()
	netpacket = m_netpk.c_net_packet()
	game.get_start_time()

	xr_sound.clear_all_sound_object()
	dialog_manager.fill_phrase_table()

	iam_any.iAmAnyInit()
	--AMK UTILS--
	amk.on_game_start()
	--AMK UTILS--
end

-- Чтение контейнера и создание классов из его данных
function init_container()
	if not container then
		container = keyvals()
		Variable = xr_logic.CVariable()
		freeplay_stats = xr_statistic_freeplay.freeplay_statistic()
		random_task = task_manager.CRandomTask()
		Treasure = treasure_manager.CTreasure()
	end
end

function after_objs_load_callback() --калбек вызывается после загрузки объектов из сейва
	init_container()
	level.show_indicators()
end

-- запущена ли игра
function game_is_running()
	return level.present() and Actor and Actor:alive() or false
end

-- Короткие имена для частых функций
voice = xr_sound.get_safe_sound_object
sms = news_manager.send_tip
translate = game.translate_string

-- метки на карте
map_spot = level.map_add_object_spot_ser
level_map_spot = level.map_add_object_spot
has_map_spot = level.map_has_object_spot
del_map_spot = level.map_remove_object_spot

-- переменные
function set_value(var, value)
	return Variable:set(var, value)
end
function get_value(var, default, delete)
	return Variable:get(var, default, delete)
end
function del_value(var)
	return Variable:del(var)
end
function has_value(var)
	return Variable:has(var)
end

-- Инвентарь ГГ, объявляется в bind_actor.net_spawn
function has(s, i)
	return Inventory:has(s, i)
end
function got(s, i)
	Inventory:got(s, i)
end
function lost(s, i)
	Inventory:lost(s, i)
end
function transfer(v, s, t)
	Inventory:transfer(v, s, t)
end

-- Деньги
function got_money(m)
	Actor:give_money(m)
	news_manager.relocate_money("in", m)
end
function lost_money(m)
	Actor:give_money(-m)
	news_manager.relocate_money("out", m)
end
function has_money(m)
	return Actor:money() >= m
end

-- Проиграть звук
function say(s, vol)
	if type(s) == "string" then s = voice(s) end
	s:play_no_feedback(Actor, sound_object.s2d, 0, xyz(), vol or 1)
end

-- Вместо has_alife_info, AI:has_info, Actor:has_info
function has_info(i)
	return AI:has_info(0,i)
end
has_alife_info = has_info

-- Вместо Actor:give_info_portion
function give_info(i)
	return Actor:give_info_portion(i)
end

-- Вместо Actor:disable_info_portion
function disable_info(i)
	return Actor:disable_info_portion(i)
end

-- Вместо AI:create() все варианты
function create(...)
	return AI:create(...)
end

-- Вместо AI:release(), AI:release(AI:object(id|name)) со всеми проверками.
-- В качестве параметра можно передавать серверный объект, клиентский объект и просто id. Для объектов алспауна можно передавать name.
function release(o)
	if not o then return end

	o = server_object(o)
	if o then
		AI:release(o)
	end
end

-- Вместо AI:object(id|name)
-- В качестве параметра можно передавать серверный объект, клиентский объект и просто id. Для объектов алспауна можно передавать name.
function server_object(o)
	if not o then return nil end

	if type(o) ~= "userdata" then		-- id или name
		return AI:object(o)
	elseif o.section_name then			-- серверный объект
		return AI:object(o.id)
	else								-- клиентский объект
		return AI:object(o:id())
	end
end

-- Вместо AI:story_object()
function story_object(o)
	return AI:story_object(o)
end

-- Уровень, на котором находится объект
function object_level(o)
	return graph:vertex(o.m_game_vertex_id or o:game_vertex_id()):level_id()
end

-- Название уровня, на котором находится объект
function object_level_name(o)
	return AI:level_name(object_level(o))
end

-- Вместо level.object_by_id()
level_object = level.object_by_id

-- Вместо level_object_by_sid()
function level_story_object(sid)
	local o = story_object(sid)
	return o and level_object(o.id)
end
level_object_by_sid = level_story_object

-- Получение id по story_id
function id_by_sid(sid)
	local o = story_object(sid)
	return o and o.id
end

-- Это использовать только при разовых указаниях позиции для create и т.п. Для всего остального использовать свой экземпляр класса vector().
local pos_only = vector()
function xyz(x,y,z)
	return pos_only:set(x or 0, y or 0, z or 0)
end

-- Запуск таймера
timer = nil

-- Спавн/удаление особых объектов

-- Спавн телепортов
function create_teleport(section, pos, lv, gv)
	local o = AI:create(section, pos, lv, gv)
	set_value(section, o.id)
	return o
end

-- Удаление телепортов
function release_teleport(section)
	release(get_value(section, -1, true))
end

-- Вывод в лог
function log(fmt,...)
	log1(string.format(tostring(fmt), ...))
end

function action(obj,...)
    local arg = {...}
    local act = entity_action()
    local i = 1
    while true do
        if (arg[i] ~= nil) then
            act:set_action(arg[i])
        else
            break
        end
        i = i + 1
    end
    if (obj ~= nil) then
        obj:command(act,false)
    end
    return  entity_action(act)
end

-- Имитация движкового класса Fvector2

class "vector2"

function vector2:__init()
	self.x = 0
	self.y = 0
end

function vector2:__finalize()
end

function vector2:set(x, y)
	self.x = x
	self.y = y

	return self
end

function vector2:add(vec2)
	self.x = self.x + vec2.x
	self.y = self.y + vec2.y

	return self
end

function vector2:sub(vec2)
	self.x = self.x - vec2.x
	self.y = self.y - vec2.y

	return self
end

function vector2:div(x, y)
	if not y then y = x end

	self.x = self.x/x
	self.y = self.y/y

	return self
end

function vector2:mul(x, y)
	if not y then y = x end

	self.x = self.x*x
	self.y = self.y*y

	return self
end

function vector2:get()
	return self.x, self.y
end

function vector2:distance_to(vec2)
	local dx, dy = (self.x - vec2.x), (self.y - vec2.y)

	return math.sqrt(dx*dx + dy*dy)
end

function vector2:clamp(rect)
	self.x = math.clamp(self.x, rect.x1, rect.x2)
	self.y = math.clamp(self.y, rect.y1, rect.y2)

	return self
end

function distance_between(obj1, obj2)
    return obj1:position():distance_to(obj2:position())
end

function reset_action (npc, script_name)
    if npc:get_script () then
       npc:script (false, script_name)
    end
    npc:script (true, script_name)
end

-- Константа, которую использовать в местах, где нужно задать неограниченное время действия
time_infinite = 100000000

-- Рандомный выбор из списка параметров
function random_choice(...)
    local arg = {...}
    local r = math.random(1, #arg)
    return arg[r]
end

function is_object_online(obj_id)
	return level_object(obj_id) ~= nil
end

-- Вычисляет yaw в радианах
function yaw(v1, v2)
	return math.acos( ( (v1.x*v2.x) + (v1.z*v2.z ) ) / math.sqrt((v1.x*v1.x + v1.z*v1.z ) * (v2.x*v2.x + v2.z*v2.z )) )
end

function yaw_degree(v1, v2)
	return (math.acos( ( (v1.x*v2.x) + (v1.z*v2.z ) ) / math.sqrt((v1.x*v1.x + v1.z*v1.z ) * (v2.x*v2.x + v2.z*v2.z )) ) * 57.2957)
end
function yaw_degree3d(v1, v2)
	return (math.acos((v1.x*v2.x + v1.y*v2.y + v1.z*v2.z)/math.sqrt((v1.x*v1.x + v1.y*v1.y + v1.z*v1.z )*(v2.x*v2.x + v2.y*v2.y + v2.z*v2.z)))*57.2957)
end

function vector_cross (v1, v2)
    return vector ():set (v1.y  * v2.z  - v1.z  * v2.y, v1.z  * v2.x  - v1.x  * v2.z, v1.x  * v2.y  - v1.y  * v2.x)
end

-- Вращает вектор вокруг оси y против часовой стрелки
function vector_rotate_y (v, angle)
    angle = angle * 0.01745329252
    local c = math.cos (angle)
    local s = math.sin (angle)
    return vector ():set (v.x * c - v.z * s, v.y, v.x * s + v.z * c)
end

function stop_play_sound(obj)
  if obj:alive() == true then
    obj:set_sound_mask(-1)
    obj:set_sound_mask(0)
  end
end

function switch_online(id)
	if id == -1 then return end
	AI:set_switch_online(id, true)
	AI:set_switch_offline(id, false)
end

function switch_offline(npc)
	if not npc or ((npc:is_stalker() or npc:is_monster()) and not npc:alive()) then return end
	local id = npc:id()
	AI:set_switch_online(id, false)
	AI:set_switch_offline(id, true)
end

-- быстрый if
function iif(t,t1,t2)
	return t and t1 or t2
end

-- Крешнуть игру (после вывода сообщения об ошибке в лог)
function abort(fmt, ...)
	fmt = tostring(fmt)
	local reason = ... == nil and fmt or string.format(fmt, ...)

	log1("FATAL ERROR: " .. reason)
	log1(debug.traceback())
	fail(reason)

	console:execute("quit")
end

function set_inactivate_input_time(delta)
	db.storage[0].disable_input_time = game.get_game_time()
	db.storage[0].disable_input_idle = delta
	level.disable_input()
end

-- проверяет целую часть числа на нечётность
function odd(x)
	return math.fmod(x, 2) >= 1
end

--' Усталость
function on_actor_critical_power()
end

function on_actor_critical_max_power()
end

--' Кровотечение
function on_actor_bleeding()
end

function on_actor_satiety()
end

--' Радиация
function on_actor_radiation()
end

--' Заклинило оружие
function on_actor_weapon_jammed()
end

--' не может ходить изза веса
function on_actor_cant_walk_weight()
end

--' пси воздействие
function on_actor_psy()
end

--' инвентарное название объекта
function get_inv_name(section)
	return translate(config:r_string(section, "inv_name"))
end

function get_texture_info(id_name, id_default)
  if id_default == nil then id_default = id_name end

  local task_info = GetTextureInfo(id_name, id_default)
  local r = task_info:get_rect()

  r.x2 = r.x2 - r.x1
  r.y2 = r.y2 - r.y1
  return task_info:get_file_name(), r
end

ammo_section = ini_file("misc\\death_generic.ltx"):key_true("ammo_sections")
quest_section = ini_file("misc\\death_generic.ltx"):key_true("keep_items")
news_manager.prepare_data()
