local string_parse_names = string.parse_names

local time_open = 22	-- время (час) открытия арены, min = 0, max = 23
local time_close = 7	-- время (час) закрытия, min = 0, max = 23
local delay_min = 0		-- минимальное количество полных дней (суток) между закрытием и открытием арены, min = 0
local delay_max = 2		-- максимальное количество полных дней (суток) между закрытием и открытием арены, min = 1
local delay_mut = 4		-- количество полных дней (суток) до открытия полного списка мутантов, min = 0
local stake1 = 500		-- ставка №1 в тотализаторе (руб.)
local stake2 = 1000		-- ставка №2 в тотализаторе (руб.)
local stake3 = 2000		-- ставка №3 в тотализаторе (руб.)
local perc_min = 30		-- минимальный процент дохода с суммы ставки
local perc_max = 100	-- максимальный процент дохода с суммы ставки
local aem_only = false	-- (!!!МЕНЯТЬ ТОЛЬКО ОДИН РАЗ!!!) false - мод активируется после прохождения оригинальной арены / true - мод активируется сразу.
---------------------------------------------------------------------------------------------------
local time_def = nil	-- время в мире на момент начала игры (CTime)
local update_time = game.CTime()

local aem_storage

function aem_get_value(vn, def, del)
	local var = aem_storage[vn]
	if var == nil then return def end

	if del then aem_storage[vn] = nil end
	return var
end

function aem_set_value(vn, val)
	aem_storage[vn] = val
end

function aem_del_value(vn)
	aem_storage[vn] = nil
end

---------------------------------------------------------------------------------------------------
-- функции для работы с ltx
---------------------------------------------------------------------------------------------------

function read_string(ini, section, field, candef, def)
	if ini:section_exist(section) and ini:line_exist(section, field) then
		return ini:r_string(section, field)
	end
	if candef == false then
		abort("can't read string field '" .. field .. "' from section [" .. section .. "]")
	end
	return def
end

function read_number(ini, section, field, candef, def)
	if ini:section_exist(section) and ini:line_exist(section, field) then
		return ini:r_float(section, field)
	end
	if candef == false then
		abort("can't read number field '" .. field .. "' from section [" .. section .. "]")
	end
	return def
end

function parse_place(line)
	if line == nil then
		abort("no value for section [place] in aem_manager.ltx")
	end
	local t = string.parse_nums(line)
	local n = table.getn(t)
	if n ~= 5 then
		abort("inalid value for section [place] in aem_manager.ltx")
	end

	local place = {}
	place.pos = vector():set(tonumber(t[1]), tonumber(t[2]), tonumber(t[3]))
	place.lvid = tonumber(t[4])
	place.gvid = tonumber(t[5])

	return place
end

function load_team(ini, section)
	--printf("load_team('%s')", section)
	local info = {}
	info.name   = read_string(ini, section, "name", true, "aem_" .. section)
	info.name1  = read_string(ini, section, "name1", true, "aem_" .. section .. "1")
	info.name2  = read_string(ini, section, "name2", true, "aem_" .. section .. "2")
	info.intro  = read_string(ini, section, "intro", true, nil)
	info.extro  = read_string(ini, section, "extro", true, nil)
	info.spawn1 = string_parse_names(read_string(ini, section, "spawn1", true, ""))
	info.spawn2 = string_parse_names(read_string(ini, section, "spawn2", true, ""))
	info.place1 = string_parse_names(read_string(ini, section, "place1", false, nil))
	info.place2 = string_parse_names(read_string(ini, section, "place2", false, nil))
	info.humans_min = read_number(ini, section, "humans_min", true, 6)
	info.humans_max = read_number(ini, section, "humans_max", true, 6)
	info.mutants_min = read_number(ini, section, "mutants_min", true, 6)
	info.mutants_max = read_number(ini, section, "mutants_max", true, 6)
	return info
end

function load_group(ini, section)
	--printf("load_group('%s')", section)
	local info = {}

	if section == "turnament" then
		info.title  = read_string(ini, section, "title", true, "aem_" .. section)
		info.info   = read_string(ini, section, "info", true, "aem_" .. section .. "_info")
		info.done   = read_string(ini, section, "done", true, "aem_" .. section .. "_done")
		info.teams  = string_parse_names(read_string(ini, section, "teams", false, nil))
		info.fights = string_parse_names(read_string(ini, section, "fights", false, nil))
		info.dlg_size = 100 + 100 * (table.getn(info.teams) * (table.getn(info.teams) - 1))
	elseif section == "stakes" then
		info.title  = read_string(ini, section, "title", true, "aem_" .. section)
		info.info   = read_string(ini, section, "info", true, "aem_" .. section .. "_info")
		info.done   = read_string(ini, section, "done", true, "aem_" .. section .. "_done")
		info.teams1 = string_parse_names(read_string(ini, section, "teams1", false, nil))
		info.teams2 = string_parse_names(read_string(ini, section, "teams2", false, nil))
		info.fights = string_parse_names(read_string(ini, section, "fights", false, nil))
		info.dlg_size = 100 + 100 * (table.getn(info.teams1) * table.getn(info.teams2))
	else
		info.title  = read_string(ini, section, "title", true, "aem_" .. section)
		info.info   = read_string(ini, section, "info", true, "aem_" .. section .. "_info")
		info.done   = read_string(ini, section, "done", true, "aem_" .. section .. "_done")
		info.fights = string_parse_names(read_string(ini, section, "fights", false, nil))
		info.dlg_size = 100
	end

	return info
end

function load_fight(ini, section, group)
	--printf("load_fight('%s')", section)
	local info = {}
	info.group = group

	if group == "turnament" then
		info.done  = read_string(ini, section, "done", true, "aem_" .. section .. "_done")
		info.intro = read_string(ini, section, "intro", true, nil)
		info.extro = read_string(ini, section, "extro", true, nil)
		info.team1 = read_string(ini, section, "team1", true, "aem_" .. section .. "_1")
		info.team2 = read_string(ini, section, "team2", true, "aem_" .. section .. "_2")
		info.winer = read_string(ini, section, "winer", true, nil)
		info.dlg_size = 0
	elseif group == "stakes" then
		info.done  = read_string(ini, section, "done", true, "aem_" .. section .. "_done")
		info.intro = read_string(ini, section, "intro", true, nil)
		info.extro = read_string(ini, section, "extro", true, nil)
		info.team1 = read_string(ini, section, "team1", true, "aem_" .. section .. "_1")
		info.team2 = read_string(ini, section, "team2", true, "aem_" .. section .. "_2")
		info.dlg_size = 0
	else
		info.title = read_string(ini, section, "title", true, "aem_" .. section)
		info.done  = read_string(ini, section, "done", true, "aem_" .. section .. "_done")
		info.intro = read_string(ini, section, "intro", true, nil)
		info.extro = read_string(ini, section, "extro", true, nil)
		info.spawn = string_parse_names(read_string(ini, section, "spawn", false, nil))
		info.place = string_parse_names(read_string(ini, section, "place", false, nil))
		info.money = read_number(ini, section, "money", false, 0)
		info.bonus_5s = read_number(ini, section, "bonus_5s", true, 0)
		info.bonus_10s = read_number(ini, section, "bonus_10s", true, 0)
		info.bonus_15s = read_number(ini, section, "bonus_15s", true, 0)
		info.bonus_20s = read_number(ini, section, "bonus_20s", true, 0)
		info.bonus_30s = read_number(ini, section, "bonus_30s", true, 0)
		info.bonus_40s = read_number(ini, section, "bonus_40s", true, 0)
		info.bonus_50s = read_number(ini, section, "bonus_50s", true, 0)
		info.bonus_60s = read_number(ini, section, "bonus_60s", true, 0)
		info.bonus = read_string(ini, section, "bonus", true, nil)
		info.unlimit = read_string(ini, section, "unlimit", true, nil)
		info.nounlimit = read_string(ini, section, "nounlimit", true, nil)
		info.dlg_size = 100
	end

	return info
end

---------------------------------------------------------------------------------------------------
-- собственно аренный manager
---------------------------------------------------------------------------------------------------

class "CArenaext"
function CArenaext:__init()
	local i, j, n, n2, id, id2, value, info

	time_def = game.get_start_time()
	aem_storage = container:get("aem", { })

	self.nextupd = 0
	-- время последнего обновления (update)
	self.lt = aem_get_value("aem_lt", 0)
	-- время последнего/следующего открытия арены
	self.nt = aem_get_value("aem_nt", 0)
	-- время последней реальной активации (reinit)
	self.it = aem_get_value("aem_it", 0)
	-- время последнего сражения с монстрами
	self.mt = aem_get_value("aem_mt", 0)

	-- битовая маска уничтоженных группировок
	self.mk = aem_get_value("aem_mk", 0)
	self.mk_all = 0

	-- чтение LTX
	local ini = ini_file("misc\\aem_manager.ltx")

	-- вещи, которые нельзя выносить с арены (удаляются при выходе с арены)
	self.arena_items = ini:key_true("arena_items")
	
	-- запрещённые для боя на арене вещи
	self.remove_items = ini:key_true("remove_items")

	-- вещи оставляемые ГГ во время тотализатора
	self.keep_items = ini:key_true("keep_items")

	-- чтение списка стартовых позиций
	if not ini:section_exist("places") then
		abort("no section [places] in aem_manager.ltx")
	end
	self.places = {}
	ini:iterate_lines("places", function(result, id, value)
		self.places[id] = parse_place(value)
	end)

	-- чтение команд
	if not ini:section_exist("teams") then
		abort("no section [teams] in aem_manager.ltx")
	end
	self.teams = {}
	ini:iterate_lines("teams", function(result, id, value)
		self.teams[id] = load_team(ini, id)
	end)

	-- чтение груп и боёв
	if not ini:section_exist("groups") then
		abort("no section [groups] in aem_manager.ltx")
	end
	self.groups = {}
	self.fights = {}
	self.groups_order = string_parse_names(read_string(ini, "groups", "order", false, nil))
	n = table.getn(self.groups_order)
	local bit = 1
	for i=1,n do
		id = self.groups_order[i]
		self.groups[id] = load_group(ini, id)

		n2 = table.getn(self.groups[id].fights)
		for j=1,n2 do
			id2 = self.groups[id].fights[j]
			self.fights[id2] = load_fight(ini, id2, id)
		end

		if id ~= "mutants" and id ~= "special" then
			self.groups[id].mk = bit
			self.mk_all = self.mk_all + bit
			bit = bit * 2
		end
	end

	-- чтение 'stakes'
	id = "stakes"
	self.groups[id] = load_group(ini, id)
	n2 = table.getn(self.groups[id].fights)
	for j=1,n2 do
		id2 = self.groups[id].fights[j]
		self.fights[id2] = load_fight(ini, id2, id)
	end

	-- чтение 'turnament'
	id = "turnament"
	self.groups[id] = load_group(ini, id)
	n2 = table.getn(self.groups[id].fights)
	for j=1,n2 do
		id2 = self.groups[id].fights[j]
		self.fights[id2] = load_fight(ini, id2, id)
	end

	-- настройка id фраз диалога
	local dlg_id = 100
	-- для групп
	for id,value in pairs(self.groups) do
		self.groups[id].dlg_id = dlg_id
		dlg_id = dlg_id + self.groups[id].dlg_size
	end
	-- для боёв
	for id,value in pairs(self.fights) do
		self.fights[id].dlg_id = dlg_id
		dlg_id = dlg_id + self.fights[id].dlg_size
	end

	-- вспомогательные таблицы для поиска id фраз диалога
	self.stakes_phrase = {}
	self.turnament_phrase = {}

	info = self.groups["stakes"]
	value = info.dlg_id + 100
	n = table.getn(info.teams1)
	n2 = table.getn(info.teams2)
	for i=1, n do
		for j=1, n2 do
			self.stakes_phrase[info.teams1[i] .. info.teams2[j]] = value
			value = value + 100
		end
	end

	info = self.groups["turnament"]
	value = info.dlg_id + 100
	n = table.getn(info.teams)
	for i=1, n do
		for j=1, n do
			if i ~= j then
				self.turnament_phrase[info.teams[i] .. info.teams[j]] = value
				value = value + 100
			end
		end
	end
end

-------
-- возвращает имя текущего боя
-------
function CArenaext:current()
	return aem_get_value("aem_cr")
end

-------
-- возвращает описание боя с указанным именем
-------
function CArenaext:description(name)
	return self.fights[name]
end

-------
-- является ли текущий бой ставочным
-------
function CArenaext:is_stake()
	local info = self:description(self:current())
	return (info.group == "stakes" or info.group == "turnament")
end

-------
-- выиграла ли ставка
-------
function CArenaext:is_stake_win()
	return	((Actor:has_info("aem_stake_team1") and aem_get_value("aem_team1") > 0) or
		 (Actor:has_info("aem_stake_team2") and aem_get_value("aem_team2") > 0))
end

-------
-- сколько времени (часов) прошло после последнего боя с мутантами
-------
function CArenaext:get_mutants_time()
	return (time_game_hours - self.mt)
end

-------
-- были ли все группировки уничтожены Меченым хотябы по одному разу
-------
function CArenaext:is_stalkers_evil()
	return (bit_and(self.mk, self.mk_all) == self.mk_all)
end

-------
-- проверяет группу текущего боя
-------
function CArenaext:is_group_name(name)
	local info = self:description(self:current())
	return info.group == name
end

-------
-- проверяет начальную озвучку текущего боя
-------
function CArenaext:is_intro_name(name)
	local info = self:description(self:current())
	return info.intro == name
end

-------
-- проверяет конечную озвучку текущего боя
-------
function CArenaext:is_extro_name(name)
	local info = self:description(self:current())
	if info.extro ~= nil then
		return info.extro == name
	end
	-- для тотализатора две озвучки, в зависимости от результата
	if info.group == "stakes" or info.group == "turnament" then
		if aem_get_value("aem_team1") > 0 then
			local team = aem_get_value(info.team2, "")
			aem_lights.win_team1()
			return self.teams[team].extro == name
		elseif aem_get_value("aem_team2") > 0 then
			local team = aem_get_value(info.team1, "")
			aem_lights.win_team2()
			return self.teams[team].extro == name
		end
	end
	-- озвучка не найдена
	return false
end

-------
-- вызывается в случае смерти каждого участника боя
-------
function CArenaext:on_death(npc, team)
	--printf("CArenaext:on_death('%s'-'%s')", team, npc:section())

	if team ~= "team1" and team ~= "team2" then
		abort("CArenaext:on_death('invalid team')")
	end

	-- уменьшаем счётчик команды
	local cnt = aem_get_value("aem_" .. team, 0)
	if cnt > 0 then
		cnt = cnt - 1
		aem_set_value("aem_" .. team, cnt)
	end

	if Actor:has_info("aem_timeover") then
		-- убийство по истечению времени наказуемо
		Actor:give_info_portion("aem_fight_foul")
	elseif cnt == 0 and not has_info("aem_fight_done") then
		-- команда уничтожена, необходимо закончить бой
		Actor:give_info_portion("aem_fight_done")
		-- мигалки для ставочных боёв
		local info = self:description(self:current())
		if info.group ~= "turnament" and info.group ~= "stakes" then
			aem_lights.win()
		end
	end
end

-------
-- вызывается при выходе с арены
-------
function CArenaext:on_done_fight()
	local name = self:current()
	--printf("CArenaext:on_done_fight('%s')", name)
	local info = self:description(name)

	-- запрещаем бой для диалога
	Actor:give_info_portion(info.done)

	local cnt_t1 = aem_get_value("aem_team1")
	local cnt_t2 = aem_get_value("aem_team2")

	-- выход в следующий круг для турнира
	if info.group == "turnament" then
		if info.winer ~= nil and info.winer ~= "" then
			local winer
			if cnt_t1 > 0 then
				winer = aem_get_value(info.team1, "")
			elseif cnt_t2 > 0 then
				winer = aem_get_value(info.team2, "")
			else
				-- !!! ничья, что будем делать?
				winer = aem_get_value(info.team1, "")
			end
			aem_set_value(info.winer, winer)
		end
	end

	-- условия для организации специальных боёв
	-- только если противник реально изничтожен, а не таймаут
	if cnt_t1 == 0 then
		if info.group == "mutants" then
			-- запоминаем дату последнего уничтожения мутантов
			self.mt = time_game_hours
			aem_set_value("aem_mt", self.mt)
		else
			-- запоминаем уничтоженние актёром крупных команд группировок
			local group = self.groups[info.group]
			if group.mk ~= nil then
				if table.getn(info.spawn) == 6 then
					self.mk = bit_or(self.mk, group.mk)
					aem_set_value("aem_mk", self.mk)
					--printf("mk=%x", self.mk)
				end
			end
		end
	end

	-- проверим всю группу, которой принадлежит бой, на предмет завершения
	local t = self.groups[info.group].fights
	local cnt = table.getn(t)
	local done = true
	for i=1,cnt do
		if not has_info(self.fights[t[i]].done) then
			done = false
			break
		end
	end
	-- все бои данной группы завершены
	if done == true then
		self:on_done_group(info.group)
	end
end

-------
-- вызывается в случае завершения группы боёв
-------
function CArenaext:on_done_group(name)
	--printf("CArenaext:on_done_group('%s')", name)
	local info = self.groups[name]

	-- запрещаем группу для диалога
	Actor:give_info_portion(info.done)

	-- проверим все группы, может уже все закончены?
	local done = true
	for id, info in pairs(self.groups) do
		if not has_info(info.done) then
			done = false
			break
		end
	end
	-- все бои завершены, арена пройдена
	if done == true then
		self:on_done_all()
	end
end

-------
-- вызывается в случае завершения всех боёв арены
-------
function CArenaext:on_done_all()
	--printf("CArenaext:on_done_all()")
	Actor:give_info_portion("aem_done")
end

-------
-- инициализация мода
-------
function CArenaext:startup()
	--printf("CArenaext:startup()")
	if not has_info("aem_startup") then
		Actor:give_info_portion("aem_spam")
		Actor:give_info_portion("aem_startup")

		local ct = level.get_time_minutes()
		aem_set_value("aem_ct", ct)

		-- очистка ящичка
		local box = level_object_by_sid(574)
		if box ~= nil then
			clear_box(box)
		else
			clear_offline_box(574)
		end

		-- удаление 'деревянного' долговца
		local obj = AI:object("bar_physic_object_stalker_0004")
		if obj ~= nil then
			AI:release(obj)
		end

		-- освободим место в баре, если оно занято
		local obj = AI:object("bar_bar_visitors_1_2")
		if obj ~= nil then
			AI:release(obj)
		end
	end
	timeup()
end

function CArenaext:timeup()
	self.lt = time_game_hours
	self.nt = time_get_next(self.lt + 12)	-- хотя бы 12 часов обождать
	if aem_only == true then
		self.it = self.nt
	else
		self.it = 0
	end
	self.mt = self.nt
	self.mk = 0
	Actor:give_info_portion(self.groups["special"].done)

-- тест первой инициализации, что бы не ждать долго
--	self.nt = time_get_next(self.lt - 3)

-- тест повторной инициализации
--	self.nt = time_get_next(self.lt - 3)
--	self.it = self.nt

-- тест всех монстров
--	self.nt = time_get_next(self.lt - 3)
--	self.it = self.nt
--	self.mt = 0

-- тест сборной
--	self.nt = time_get_next(self.lt - 3)
--	self.it = self.nt
--	self.mk = self.mk_all

-- тест сборной, перешедшей в следующую активацию
--	self.nt = time_get_next(self.lt - 3)
--	self.it = self.nt
--	Actor:disable_info_portion(self.groups["special"].done)

	aem_set_value("aem_lt", self.lt)
	aem_set_value("aem_nt", self.nt)
	aem_set_value("aem_it", self.it)
	aem_set_value("aem_mt", self.mt)
	aem_set_value("aem_mk", self.mk)
end

-------
-- удаление мода
-------
function CArenaext:cleanup()
	local i, n, result, id, value, obj, section
	--printf("CArenaext:cleanup()")

	-- чтение LTX
	local ini = ini_file("misc\\aem_manager.ltx")

	-- возврат стандартного освещения на арене
	aem_lights.remove_all_aem_lamps()
	aem_lights.turn_arena_lamps_on()

	-- создание списка удаляемых инфопоршинов
	local info = ini:list("info")
	for id, value in pairs(self.groups) do
		table.insert(info, value.done)
	end
	for id, value in pairs(self.fights) do
		table.insert(info, value.done)
	end

	-- создание списка удаляемых переменных
	local pstor = ini:list("pstor")
	for id, value in pairs(self.fights) do
		if value.group == "stakes" or value.group == "turnament" then
			table.insert(pstor, value.team1)
			table.insert(pstor, value.team2)
		end
	end

	-- удаление инфопоршинов
	for id, value in pairs(info) do
		Actor:disable_info_portion(value)
	end

	-- удаление переменных
	for id, value in pairs(pstor) do
		aem_del_value(value)
	end

	aem_storage = nil
	container:del("aem")

	-- удаление объектов
	for id=0, 65535 do
		obj = AI:object(id)
		if obj ~= nil then
			if string.find(obj:name(), "aem_") then
				AI:release(obj)
			end
		end
	end
	news_manager.send_tip("%c[25,240,25,25]МОД УДАЛЁН", nil, nil, 30000)
end

-------
-- сгенерить доступные бои
-------
function CArenaext:reinit()
	--printf("CArenaext:reinit()")
	local name, info, t, tt, i, j, n, nn, cnt, rnd, fight

	---- именно здесь, до установки info_portion-ов
	local special = self:is_stalkers_evil() or not has_info(self.groups["special"].done)

	-- запрещаем все группы
	for name, info in pairs(self.groups) do
		Actor:give_info_portion(info.done)
	end

	-- запрещаем все бои
	for name, info in pairs(self.fights) do
		Actor:give_info_portion(info.done)
	end

	-- мутанты
	info = self.groups["mutants"]
	Actor:disable_info_portion(info.done)	-- разрешаем группу мутантов
	if is_init_mutants() then			-- разрешаем все бои
		for i, name in pairs(info.fights) do
			Actor:disable_info_portion(self.fights[name].done)
		end
	else						-- разрешаем 3-4 случайных боя
		t = {}
		for i, name in pairs(info.fights) do
			table.insert(t, name)
		end
		n = math.random(3, 4)
		for i=1, n do
			cnt = table.getn(t)
			rnd = math.random(cnt)
			Actor:disable_info_portion(self.fights[t[rnd]].done)
			table.remove(t, rnd)
		end
	end

	-- инициализация stakes
	t = {}
	tt = {}
	info = self.groups["stakes"]
	Actor:disable_info_portion(info.done)
	for i, name in pairs(info.teams1) do
		table.insert(t, name)
	end
	for i, name in pairs(info.teams2) do
		table.insert(tt, name)
	end
	n = table.getn(info.fights)
	nn = math.random(3, 4)
	if nn > n then nn = n end
	for i=1, n do
		fight = self.fights[info.fights[i]]
		if i <= nn then
			cnt = table.getn(t)
			rnd = math.random(cnt)
			aem_set_value(fight.team1, t[rnd])
			table.remove(t, rnd)
			cnt = table.getn(tt)
			rnd = math.random(cnt)
			aem_set_value(fight.team2, tt[rnd])
			table.remove(tt, rnd)
			Actor:disable_info_portion(fight.done)
		else
			aem_set_value(fight.team1, "")
			aem_set_value(fight.team2, "")
			Actor:give_info_portion(fight.done)
		end
	end

	-- инициализация turnament
	t = {}
	info = self.groups["turnament"]
	Actor:disable_info_portion(info.done)
	for i, name in pairs(info.teams) do
		table.insert(t, name)
	end
	for i=1, 2 do
		fight = self.fights[info.fights[i]]
		cnt = table.getn(t)
		rnd = math.random(cnt)
		aem_set_value(fight.team1, t[rnd])
		table.remove(t, rnd)
		rnd = math.random(cnt-1)
		aem_set_value(fight.team2, t[rnd])
		table.remove(t, rnd)
		Actor:disable_info_portion(fight.done)
	end
	fight = self.fights[info.fights[3]]
	aem_set_value(fight.team1, "")
	aem_set_value(fight.team2, "")
	Actor:disable_info_portion(fight.done)

	-- инициализация остальных групп и боёв
	if special then						-- бой со сборной
		info = self.groups["special"]
		Actor:disable_info_portion(info.done)
		for i, name in pairs(info.fights) do
			Actor:disable_info_portion(self.fights[name].done)
		end
		-- сброс статистики, что бы фраза не появлялась в диалоге больше одного раза
		-- если бой не завершить, то он перейдёт в следующую активацию по info_portion
		self.mk = 0
	else
		t = {}
		for name, info in pairs(self.groups) do
			if name ~= "mutants" and name ~= "special" and
			   name ~= "stakes" and name ~= "turnament"
			then
				table.insert(t, name)
			end
		end

		n = math.random(3, 4)  -- колличество случайных групп
		for i=1, n do
			cnt = table.getn(t)
			rnd = math.random(cnt)
			info = self.groups[t[rnd]]
			table.remove(t, rnd)
			Actor:disable_info_portion(info.done)

			tt = {}
			for j, name in pairs(info.fights) do  -- составление 'таблиц' боёв для каждой группы
				table.insert(tt, name)
			end
			nn = math.random(1, 4)  -- колличество разрешаемых боёв
			for j=1, nn do
				cnt = table.getn(tt)
				rnd = math.random(cnt)
				Actor:disable_info_portion(self.fights[tt[rnd]].done)
				table.remove(tt, rnd)
			end
		end
	end

	-- обновляем рестрикты каждый раз при начале новой арены
	for id=0, 65535 do
		obj = level.object_by_id(id)
		if obj ~= nil then
			section = obj:section()
			if section == "aem_sound" or section == "aem_timer" then
				AI:release(AI:object(id), true)
			end
		end
	end

	-- рестриктор, который будет выполнять озвучку и выход с арены
	AI:create("aem_sound", vector():set(150.14, -14.16, 74.03), Actor:level_vertex_id(), Actor:game_vertex_id())

	-- рестриктор, который будет выполнять функции таймера, при сражениях на время
	AI:create("aem_timer", vector():set(150.14, -14.16, 74.03), Actor:level_vertex_id(), Actor:game_vertex_id())

	self.it = self.nt
	aem_set_value("aem_it", self.it)
	Actor:give_info_portion("aem_ready")
end

-------
-- update() вызывается из "bind_actor.script" <actor_binder:update(delta)>
-------
function CArenaext:update_slow(curr)
	local id, npc, ctm, rt, ct

	if aem_only == true and not has_info("aem_startup") then
		Actor:give_info_portion("bar_arena_fight_8_done")
		startup()
	end

	id = aem_get_value("aem_id", 0)

	-- удаляем Арни и создаём его клона
	if id == 0 then
		npc = AI:object("bar_arena_man")
		if npc ~= nil then
			AI:release(npc)
			if npc:alive() ~= true then
				-- мёртвый
				Actor:give_info_portion("aem_arny_dead")
				Actor:give_info_portion("aem_arny_dis_1")
				admin_dead()
			else
				-- живой
				local obj = AI:create("aem_arny", vector():set(149.561569213867,0.429975032806396,69.2308807373047), 40035, 1180)
				-- сохранение id
				aem_set_value("aem_id", obj.id)
			end
		else
			Actor:give_info_portion("aem_arny_spread_out")
			Actor:give_info_portion("aem_arny_dis_2")
			admin_dead()
		end
	end

	-- проверка Арни(админа) по сохранённому id: мёртв или уничтожен
	if  update_time < game.get_game_time() then
		local idle_time = game.CTime()
		idle_time:setHMSms(0, 5, 0, 0)
		update_time = game.get_game_time() + idle_time
		--printf("CArenaext:update(30sec_update_done)")
		if id > 0 then
			id = aem_get_value("aem_id")
			npc = AI:object(id)
			if npc ~= nil and npc:clsid() == clsid.script_stalker then
				if npc:alive() ~= true then
					-- мёртвый
					if npc:profile_name() == "aem_arny" then
						Actor:give_info_portion("aem_arny_dead")
						Actor:give_info_portion("aem_arny_dis_1")
					elseif string.find(npc:name(), "aem_admin") then
						Actor:give_info_portion("aem_admin_dead")
					else
						-- Арни(админа) порвало -> заспавнился левый id -> левый умер -> update
						if not has_info("aem_arny_dis_1") and not has_info("aem_arny_dis_2") then
							Actor:give_info_portion("aem_arny_spread_out")
							Actor:give_info_portion("aem_arny_dis_2")
						else
							Actor:give_info_portion("aem_admin_spread_out")
						end
					end
					admin_dead()
				else
					-- живой
					if npc:profile_name() ~= "aem_arny" and not string.find(npc:name(), "aem_admin") then
						-- уничтожен (порвало в аномалии)
						if not has_info("aem_arny_dis_1") and not has_info("aem_arny_dis_2") then
							Actor:give_info_portion("aem_arny_spread_out")
							Actor:give_info_portion("aem_arny_dis_2")
						else
							Actor:give_info_portion("aem_admin_spread_out")
						end
						admin_dead()
					end
				end
			else
				-- уничтожен (порвало в аномалии)
				if not has_info("aem_arny_dis_1") and not has_info("aem_arny_dis_2") then
					Actor:give_info_portion("aem_arny_spread_out")
					Actor:give_info_portion("aem_arny_dis_2")
				else
					Actor:give_info_portion("aem_admin_spread_out")
				end
				admin_dead()
			end
		end
	end

	-- выдача сообщения о восстановлении работы арены
	-- инициализация спавна админа
	rt = aem_get_value("aem_rt")
	if rt ~= nil then
		if (curr + rt >= self.nt) and (self.lt + rt < self.nt) then
			msg("aem_restore")
			Actor:disable_info_portion("aem_arny_dead")
			Actor:disable_info_portion("aem_admin_dead")
			Actor:disable_info_portion("aem_arny_spread_out")
			Actor:disable_info_portion("aem_admin_spread_out")
			Actor:give_info_portion("aem_spam")
			admin_spawn()
			aem_del_value("aem_rt")
		end
	end

	-- 5 мин. после закрытия арены: сообщение + info для смены рестрикта
	ct = aem_get_value("aem_ct")
	if ct ~= nil then
		ctm = level.get_time_minutes()

		if ctm >= ct then
			x = 0
		else --if ctm < ct
			x = 60
		end

		if ctm >= ct + 5 - x then
			if Actor:has_info("aem_spam") then
				local txt = {"aem_drunk_1", "aem_drunk_2", "aem_drunk_3", "aem_drunk_4"}
				local cnt = table.getn(txt)
				local rnd = math.random(cnt)
				msg(txt[rnd])
			end
			Actor:give_info_portion("aem_go_bar")
			aem_del_value("aem_ct")
		end
	end

	self.lt = curr
	aem_set_value("aem_lt", self.lt)
end

function CArenaext:update()
	local curr = time_game_hours

	if self.nextupd < time_real_ms then
		self:update_slow(curr)
		self.nextupd = time_real_ms + 1000
	end

	if Actor:has_info("aem_startup") then
		if Actor:has_info("aem_open") then
			if Actor:has_info("aem_done") then
				--printf("CArenaext:update(~aem_open)")
				self.nt = time_get_next(curr + 1) -- хотя бы часовой перерыв
				aem_set_value("aem_nt", self.nt)
				Actor:disable_info_portion("aem_done")
				Actor:disable_info_portion("aem_open")
				Actor:disable_info_portion("aem_ready")
				if Actor:has_info("aem_spam") then
					msg("aem_msg_done")
				end
				-- отключение мегафона и освещения щита "Арена"
				Actor:disable_info_portion("aem_megafone")
				--aem_lights.shield_off()
				-- запомним время закрытия арены
				local ct = level.get_time_minutes()
				aem_set_value("aem_ct", ct)
			elseif time_need_close(curr, self.nt) and
				not has_info("bar_arena_fight") and
				not has_info("aem_fight_wait")
			then
				--printf("CArenaext:update(~aem_open)")
				self.nt = time_get_next(curr + 1) -- хотя бы часовой перерыв
				aem_set_value("aem_nt", self.nt)
				Actor:disable_info_portion("aem_open")
				Actor:disable_info_portion("aem_ready")
				if Actor:has_info("aem_spam") then
					msg("aem_msg_close")
				end
				-- отключение мегафона и освещения щита "Арена"
				Actor:disable_info_portion("aem_megafone")
				--aem_lights.shield_off()
				-- запомним время закрытия арены
				local ct = level.get_time_minutes()
				aem_set_value("aem_ct", ct)
			end
		else
			if curr >= self.nt then
				--printf("CArenaext:update(aem_open)")
				Actor:give_info_portion("aem_open")
				Actor:disable_info_portion("aem_go_bar")
			elseif (curr + 3 >= self.nt) and (self.lt + 3 < self.nt) then
				-- включение мегафона и освещения щита "Арена"
				Actor:give_info_portion("aem_megafone")
				--aem_lights.shield_on()
				Actor:disable_info_portion("aem_go_bar")
			end
			if Actor:has_info("aem_spam") then
				if (curr >= self.nt) and (self.lt < self.nt) then
					msg("aem_msg_open")
				elseif (curr + 3 >= self.nt) and (self.lt + 3 < self.nt) then
					msg("aem_msg_3h")
				elseif (curr + 6 >= self.nt) and (self.lt + 6 < self.nt) then
					msg("aem_msg_6h")
				elseif (curr + 12 >= self.nt) and (self.lt + 12 < self.nt) then
					msg("aem_msg_12h")
				elseif (curr + 24 >= self.nt) and (self.lt + 24 < self.nt) then
					msg("aem_msg_24h")
				elseif (curr + 48 >= self.nt) and (self.lt + 48 < self.nt) then
					msg("aem_msg_48h")
				elseif (curr + 72 >= self.nt) and (self.lt + 72 < self.nt) then
					msg("aem_msg_72h")
				elseif (curr + 96 >= self.nt) and (self.lt + 96 < self.nt) then
					msg("aem_msg_96h")
				end
			end
		end

		-- проверка на разрыв диалога после передачи денег для ставки
		if not Actor:is_talking() and Actor:has_info("aem_fight_wait") then
			self:start_stake()
		end

		-- ???
		if self.grenads then
			if aem_grenade.unload2(self.grenads) then
				self.grenads = nil
			end
		end
	end
end

-------
-- начать бой
-------
function CArenaext:start(phr_id)
	local name = self:fight_by_phrase(phr_id)
	--printf("CArenaext:start('%s')", name)

	-- запоминаем имя боя
	aem_set_value("aem_cr", name)

	-- запомним группировку ГГ
	aem_set_value("aem_cm", Actor:character_community())

	local info = self.fights[name]

	if info.group == "stakes" then

		-- спавн первой команды - мутанты
		local team1 = self.teams[aem_get_value(info.team1, "")]
		local a1 = team1.mutants_min
		local b1 = team1.mutants_max
		local n1 = math.random(a1,b1)

		aem_set_value("aem_team1", n1)
		for i=1, n1 do
			local spawn = team1.spawn1[i]
			local place = self.places[team1.place1[i]]
			local obj = AI:create(spawn, place.pos, place.lvid, place.gvid)
		end

		-- спавн второй команды - люди
		local team2 = self.teams[aem_get_value(info.team2, "")]
		local a2 = team1.humans_min
		local b2 = team1.humans_max
		local n2 = math.random(a2,b2)

		aem_set_value("aem_team2", n2)
		for i=1, n2 do
			local spawn = team2.spawn2[i]
			local place = self.places[team2.place2[i]]
			local obj = AI:create(spawn, place.pos, place.lvid, place.gvid)
		end

		-- ставка
		if Actor:has_info("aem_stake1") then
			manage_money(stake1, "out")
		elseif Actor:has_info("aem_stake2") then
			manage_money(stake2, "out")
		elseif Actor:has_info("aem_stake3") then
			manage_money(stake3, "out")
		end

		-- отложенный старт
		Actor:give_info_portion("aem_fight_wait")

	elseif info.group == "turnament" then

		-- спавн первой команды
		local team1 = self.teams[aem_get_value(info.team1, "")]
		local n1 = table.getn(team1.spawn1)
		aem_set_value("aem_team1", n1)
		for i=1, n1 do
			local spawn = team1.spawn1[i]
			local place = self.places[team1.place1[i]]
			local obj = AI:create(spawn, place.pos, place.lvid, place.gvid)
		end

		-- спавн второй команды
		local team2 = self.teams[aem_get_value(info.team2, "")]
		local n2 = table.getn(team2.spawn2)
		aem_set_value("aem_team2", n2)
		for i=1, n2 do
			local spawn = team2.spawn2[i]
			local place = self.places[team2.place2[i]]
			local obj = AI:create(spawn, place.pos, place.lvid, place.gvid)
		end

		-- ставка
		if Actor:has_info("aem_stake1") then
			manage_money(stake1, "out")
		elseif Actor:has_info("aem_stake2") then
			manage_money(stake2, "out")
		elseif Actor:has_info("aem_stake3") then
			manage_money(stake3, "out")
		end

		-- отложенный старт
		Actor:give_info_portion("aem_fight_wait")

	else

		-- спавн участников
		local n = table.getn(info.spawn)
		aem_set_value("aem_team1", n)
		for i=1, n do
			local spawn = info.spawn[i]
			local place = self.places[info.place[i]]
			local obj = AI:create(spawn, place.pos, place.lvid, place.gvid)
		end

		-- 'волшебный' ящичек
		local box = level_object_by_sid(574)
		-- отнимем у ГГ опасные вещи
		put_items_to_box(box, self.remove_items)

		-- ???
		self.grenads = aem_grenade.unload1()

		-- запускаем кучу логики, завязанную на этот info_portion
		Actor:give_info_portion("bar_arena_fight")

	end
end

-------
-- начать отложенный бой
-------
function CArenaext:start_stake()
	-- отключаем отложенный старт
	Actor:disable_info_portion("aem_fight_wait")

	-- 'волшебный' ящичек
	local box = level_object_by_sid(574)
	-- отнимем у ГГ всё, кроме самого необходимого, дабы он не вмешивался в ход боя
	put_items_to_box_exept(box, self.keep_items)

	-- ГГ временно пополняет ряды торговцев
	Actor:set_character_community("trader",0,0)

	-- телепортация к зрителям
	level.add_pp_effector ("teleport.ppe", 2006, false)
	Actor:set_actor_position(vector():set(140.05,-13.387,108.039))
	Actor:set_actor_direction(1.57)

	-- запускаем кучу логики, завязанную на этот info_portion
	Actor:give_info_portion("bar_arena_fight")

	-- смена группировки для team2
	local npc
	for id=0, 65535 do
		npc = level.object_by_id(id)
		if npc ~= nil and string.find(npc:section(),"_t2_") then
			npc:set_character_community("stalker", 0, 0)
		end
	end
end

-------
-- выход с арены после финальной озвучки
-------
function CArenaext:finish()
	local name = self:current()
	--printf("CArenaext:finish('%s')", name)
	local info = self.fights[name]

	-- бой окончен, пометим это и кое-что ещё
	self:on_done_fight()

	-- телепортация к Арни
	bar_arena_teleport_2_tp(Actor)

	-- ГГ покидает ряды торговцев
	local community = aem_get_value("aem_cm")
	Actor:set_character_community(community,0,0)
	aem_del_value("aem_cm")

	-- удаление оружия, незаконно вынесеного с арены
	if info.group ~= "turnament" or info.group ~= "stakes" then
		clear_items(self.arena_items)
	end

	-- 'волшебный' ящичек
	bar_arena_teleport_2_box(Actor)

	-- перезапуск логики рестриктов
	Actor:disable_info_portion("bar_arena_fight")
	Actor:disable_info_portion("bar_arena_fight_begin")

	-- массовое убийство врагов, оставшихся на арене после выхода ГГ
	local bot
	for id=1, 65534 do
		bot = level.object_by_id(id)
		if bot ~= nil and bot:alive() == true then
			if string.find(bot:out_restrictions(),"bar_arena_restrictor") then
				bot:kill(bot)
			end
		end
	end
end

-------
-- получить награду и почистить инфу о бое, чтобы можно было приступить к следующему
-------
function CArenaext:close()
	local name = self:current()
	--printf("CArenaext:close('%s')", name)
	local info = self.fights[name]

	if info.group == "turnament" or info.group == "stakes" then
		if (Actor:has_info("aem_stake_team1") and aem_get_value("aem_team1") > 0) or
		   (Actor:has_info("aem_stake_team2") and aem_get_value("aem_team2") > 0) then
			local money = 0
			if Actor:has_info("aem_stake1") then
				money = stake1 + math.random(stake1*perc_min/100, stake1*perc_max/100)
			elseif Actor:has_info("aem_stake2") then
				money = stake2 + math.random(stake2*perc_min/100, stake2*perc_max/100)
			elseif Actor:has_info("aem_stake3") then
				money = stake3 + math.random(stake3*perc_min/100, stake3*perc_max/100)
			end
			manage_money(money, "in")
		else
			manage_money(0, "in")
		end
		Actor:disable_info_portion("aem_stake_team1")
		Actor:disable_info_portion("aem_stake_team2")
		Actor:disable_info_portion("aem_stake1")
		Actor:disable_info_portion("aem_stake2")
		Actor:disable_info_portion("aem_stake3")
	else

		if Actor:has_info("aem_fight_foul") then
			manage_money(info.money, "out")
		elseif Actor:has_info("aem_timeover") then
			manage_money(0, "in")
		else
			manage_money(info.money, "in")

			if Actor:has_info("aem_bonus") and not has_info("aem_timeover") then
				local money = 0
				if Actor:has_info("aem_bonus_5s") then
					money = info.bonus_5s
				elseif Actor:has_info("aem_bonus_10s") then
					money = info.bonus_10s
				elseif Actor:has_info("aem_bonus_15s") then
					money = info.bonus_15s
				elseif Actor:has_info("aem_bonus_20s") then
					money = info.bonus_20s
				elseif Actor:has_info("aem_bonus_30s") then
					money = info.bonus_30s
				elseif Actor:has_info("aem_bonus_40s") then
					money = info.bonus_40s
				elseif Actor:has_info("aem_bonus_50s") then
					money = info.bonus_50s
				elseif Actor:has_info("aem_bonus_60s") then
					money = info.bonus_60s
				end

				if money ~= nil and money > 0 then
					manage_money(money, "in")
				end
			end
		end
		Actor:disable_info_portion("aem_bonus")
		Actor:disable_info_portion("aem_bonus_5s")
		Actor:disable_info_portion("aem_bonus_10s")
		Actor:disable_info_portion("aem_bonus_15s")
		Actor:disable_info_portion("aem_bonus_20s")
		Actor:disable_info_portion("aem_bonus_30s")
		Actor:disable_info_portion("aem_bonus_40s")
		Actor:disable_info_portion("aem_bonus_50s")
		Actor:disable_info_portion("aem_bonus_60s")
		Actor:disable_info_portion("aem_timeover")
		Actor:disable_info_portion("aem_fight_foul")
	end

	-- сброс освещения после боя
	--aem_lights.lights_reset()
	aem_lights.remove_all_aem_lamps()

	Actor:disable_info_portion("aem_fight_done")
	aem_del_value("aem_cr")
	aem_del_value("aem_team1")
	aem_del_value("aem_team2")
end

---------------------------------------------------------------------------------------------------
-- функции для работы с динамическим диалогом
---------------------------------------------------------------------------------------------------
--
-- Есть какие бои, Арни?
--   На сегодня всё, арена закрыта.
--   Выбирай...
--     <group1>
--     <group2>
--     ...
--     ret
--
-- <single>
-- Должане
--   В каком колличестве?
--     Один
--       Сколько времени тебе понадобится?
--         10 секунд
--         20 секунд
--         30 секунд
--         40 секунд
--         <ret>
--     ...
--     <ret>
--
-- <stake>
-- Тотализатор
--   Какой бой?
--     Военные против Свободы
--       На кого ставишь?
--         Военные
--           Сколько?
--             1000
--               Ну чтож, все ставки сделаны.
--                 Поехали
--             2000
--               Ну чтож, все ставки сделаны.
--                 Поехали
--             3000
--               Ну чтож, все ставки сделаны.
--                 Поехали
--             <nomoney>
--             <ret>
--         Свобода
--           Сколько?
--             1000
--               Ну чтож, все ставки сделаны.
--                 Поехали
--             2000
--               Ну чтож, все ставки сделаны.
--                 Поехали
--             3000
--               Ну чтож, все ставки сделаны.
--                 Поехали
--             <nomoney>
--             <ret>
--         <ret>
--     ...
--     <ret>
--
-- <turnament>
-- Турнир
--   Какой бой?
--     Военные против Свободы.
--       На кого ставишь?
--         Военные
--           Сколько?
--             1000
--               И так, все ставки сделаны.
--                 Поехали
--             2000
--               И так, все ставки сделаны.
--                 Поехали
--             3000
--               И так, все ставки сделаны.
--                 Поехали
--             <nomoney>
--             <ret>
--         Свобода
--           Сколько?
--             1000
--               И так, все ставки сделаны.
--                 Поехали
--             2000
--               И так, все ставки сделаны.
--                 Поехали
--             3000
--               И так, все ставки сделаны.
--                 Поехали
--             <nomoney>
--             <ret>
--         <ret>
--     <ret>
--
---------------------------------------------------------------------------------------------------

-------
-- создаётся диалог актера, в котором будут выдаваться задания
-------
function CArenaext:dlg_init(dlg)
	local phr = dlg:AddPhrase("aem_job_quest", "0", "", -10000)
	local phr_script = phr:GetPhraseScript()

	phr = dlg:AddPhrase("aem_job_closed", "1", "0", -10000)
	phr_script = phr:GetPhraseScript()
	phr_script:AddDontHasInfo("aem_ready")

	phr = dlg:AddPhrase("aem_job_select", "2", "0", -10000)
	phr_script = phr:GetPhraseScript()
	phr_script:AddHasInfo("aem_ready")

	phr = dlg:AddPhrase("aem_job_extra", "3", "2", -10000)
	phr_script = phr:GetPhraseScript()
	phr_script:AddPrecondition("aem_manager.is_stakes_or_turnament_valid")

	phr = dlg:AddPhrase("aem_job_extra_info", "4", "3", -10000)

	self:dlg_init_stakes(dlg, 4)
	self:dlg_init_turnament(dlg, 4)

	local i
	local count = table.getn(self.groups_order)
	for i=1, count do
		self:dlg_init_group(dlg, self.groups_order[i], 2)
	end

	dlg:AddPhrase("aem_job_extra_reject", "5", "4", -10000)

	dlg:AddPhrase("aem_job_reject", "6", "2", -10000)
end

-------
-- добавляет в диалог группу обычных боёв
-------
function CArenaext:dlg_init_group(dlg, name, parent)
	--printf("CArenaext:dlg_init_group('%s')", name)

	local group = self.groups[name]
	local dlg_id = group.dlg_id

	local phr = dlg:AddPhrase(group.title, dlg_id, parent, -10000)
	local phr_script = phr:GetPhraseScript()
	phr_script:AddDontHasInfo(group.done)

	dlg:AddPhrase(group.info, dlg_id+1, dlg_id, -10000)

	local i
	local count = table.getn(group.fights)
	for i=1, count do
		self:dlg_init_fight(dlg, group.fights[i], dlg_id+1)
	end

	dlg:AddPhrase("aem_job_group_reject", dlg_id+2, dlg_id+1, -10000)
end

-------
-- добавляет в диалог один обычный бой
-------
function CArenaext:dlg_init_fight(dlg, name, parent)
	--printf("CArenaext:dlg_init_fight('%s')", name)

	local fight = self.fights[name]
	local dlg_id = fight.dlg_id

	local phr = dlg:AddPhrase(fight.title, dlg_id, parent, -10000)
	local phr_script = phr:GetPhraseScript()
	phr_script:AddDontHasInfo(fight.done)

	if fight.bonus ~= nil then
		phr = dlg:AddPhrase(fight.bonus, dlg_id+1, dlg_id, -10000)
	else
		phr = dlg:AddPhrase("aem_job_time_quest", dlg_id+1, dlg_id, -10000)
	end

	if fight.nounlimit == nil then
		if fight.unlimit ~= nil then
			phr = dlg:AddPhrase(fight.unlimit, dlg_id+10, dlg_id+1, -10000)
		else
			phr = dlg:AddPhrase("aem_job_time_unlimited", dlg_id+10, dlg_id+1, -10000)
		end
		phr_script = phr:GetPhraseScript()
		phr_script:AddDisableInfo("aem_bonus")
		phr_script:AddAction("aem_manager.start_fight")
		phr_script:AddAction("dialogs.break_dialog")
	end
	if fight.bonus_5s > 0 then
		phr = dlg:AddPhrase("aem_job_time_5", dlg_id+9, dlg_id+1, -10000)
		phr_script = phr:GetPhraseScript()
		phr_script:AddGiveInfo("aem_bonus")
		phr_script:AddGiveInfo("aem_bonus_5s")
		phr_script:AddAction("aem_manager.start_fight")
		phr_script:AddAction("dialogs.break_dialog")
	end
	if fight.bonus_10s > 0 then
		phr = dlg:AddPhrase("aem_job_time_10", dlg_id+8, dlg_id+1, -10000)
		phr_script = phr:GetPhraseScript()
		phr_script:AddGiveInfo("aem_bonus")
		phr_script:AddGiveInfo("aem_bonus_10s")
		phr_script:AddAction("aem_manager.start_fight")
		phr_script:AddAction("dialogs.break_dialog")
	end
	if fight.bonus_15s > 0 then
		phr = dlg:AddPhrase("aem_job_time_15", dlg_id+7, dlg_id+1, -10000)
		phr_script = phr:GetPhraseScript()
		phr_script:AddGiveInfo("aem_bonus")
		phr_script:AddGiveInfo("aem_bonus_15s")
		phr_script:AddAction("aem_manager.start_fight")
		phr_script:AddAction("dialogs.break_dialog")
	end
	if fight.bonus_20s > 0 then
		phr = dlg:AddPhrase("aem_job_time_20", dlg_id+6, dlg_id+1, -10000)
		phr_script = phr:GetPhraseScript()
		phr_script:AddGiveInfo("aem_bonus")
		phr_script:AddGiveInfo("aem_bonus_20s")
		phr_script:AddAction("aem_manager.start_fight")
		phr_script:AddAction("dialogs.break_dialog")
	end
	if fight.bonus_30s > 0 then
		phr = dlg:AddPhrase("aem_job_time_30", dlg_id+5, dlg_id+1, -10000)
		phr_script = phr:GetPhraseScript()
		phr_script:AddGiveInfo("aem_bonus")
		phr_script:AddGiveInfo("aem_bonus_30s")
		phr_script:AddAction("aem_manager.start_fight")
		phr_script:AddAction("dialogs.break_dialog")
	end
	if fight.bonus_40s > 0 then
		phr = dlg:AddPhrase("aem_job_time_40", dlg_id+4, dlg_id+1, -10000)
		phr_script = phr:GetPhraseScript()
		phr_script:AddGiveInfo("aem_bonus")
		phr_script:AddGiveInfo("aem_bonus_40s")
		phr_script:AddAction("aem_manager.start_fight")
		phr_script:AddAction("dialogs.break_dialog")
	end
	if fight.bonus_50s > 0 then
		phr = dlg:AddPhrase("aem_job_time_50", dlg_id+3, dlg_id+1, -10000)
		phr_script = phr:GetPhraseScript()
		phr_script:AddGiveInfo("aem_bonus")
		phr_script:AddGiveInfo("aem_bonus_50s")
		phr_script:AddAction("aem_manager.start_fight")
		phr_script:AddAction("dialogs.break_dialog")
	end
		if fight.bonus_60s > 0 then
		phr = dlg:AddPhrase("aem_job_time_60", dlg_id+2, dlg_id+1, -10000)
		phr_script = phr:GetPhraseScript()
		phr_script:AddGiveInfo("aem_bonus")
		phr_script:AddGiveInfo("aem_bonus_60s")
		phr_script:AddAction("aem_manager.start_fight")
		phr_script:AddAction("dialogs.break_dialog")
	end
	dlg:AddPhrase("aem_job_time_reject", dlg_id+11, dlg_id+1, -10000)
end

-------
-- добавляет в диалог группу stakes
-------
function CArenaext:dlg_init_stakes(dlg, parent)
	--printf("CArenaext:dlg_init_stakes()")

	local group = self.groups["stakes"]
	local dlg_id = group.dlg_id

	local phr = dlg:AddPhrase(group.title, dlg_id, parent, -10000)
	local phr_script = phr:GetPhraseScript()
	phr_script:AddDontHasInfo(group.done)

	dlg:AddPhrase(group.info, dlg_id+1, dlg_id, -10000)

	local i, j
	local name1, name2
	local fight_id = dlg_id + 100
	local n1 = table.getn(group.teams1)
	local n2 = table.getn(group.teams2)
	for i=1, n1 do
		name1 = group.teams1[i]
		for j=1, n2 do
			name2 = group.teams2[j]
			self:dlg_init_stakes_fight(dlg, name1, name2, dlg_id+1, fight_id)
			fight_id = fight_id + 100
		end
	end

	dlg:AddPhrase("aem_job_group_reject", dlg_id+2, dlg_id+1, -10000)
end

-------
-- добавляет в диалог один бой stakes
-------
function CArenaext:dlg_init_stakes_fight(dlg, name1, name2, parent, dlg_id)
	--printf("CArenaext:dlg_init_stakes_fight('%s vs %s')", name1, name2)

	local team1 = self.teams[name1]
	local team2 = self.teams[name2]

	local title = game.translate_string(team1.name1)
	title = title .. " "
	title = title .. game.translate_string("aem_job_stake_vs")
	title = title .. " "
	title = title .. game.translate_string(team2.name2)

	local phr = dlg:AddPhrase(title, dlg_id, parent, -10000)
	local phr_script = phr:GetPhraseScript()
	phr_script:AddPrecondition("aem_manager.is_stakes_valid")

	dlg:AddPhrase("aem_job_stake_quest", dlg_id+1, dlg_id, -10000)

	phr = dlg:AddPhrase(team1.name, dlg_id+2, dlg_id+1, -10000)
	phr_script = phr:GetPhraseScript()
	phr_script:AddGiveInfo("aem_stake_team1")
	phr_script:AddDisableInfo("aem_stake_team2")

	dlg:AddPhrase("aem_job_stake_money", dlg_id+3, dlg_id+2, -10000)
	self:dlg_init_stake_tree(dlg, dlg_id+10, dlg_id+3)

	phr = dlg:AddPhrase(team2.name, dlg_id+4, dlg_id+1, -10000)
	phr_script = phr:GetPhraseScript()
	phr_script:AddGiveInfo("aem_stake_team2")
	phr_script:AddDisableInfo("aem_stake_team1")

	dlg:AddPhrase("aem_job_stake_money", dlg_id+5, dlg_id+4, -10000)
	self:dlg_init_stake_tree(dlg, dlg_id+50, dlg_id+5)

	dlg:AddPhrase("aem_job_stake_reject", dlg_id+6, dlg_id+1, -10000)
end

-------
-- добавляет в диалог группу turnament
-------
function CArenaext:dlg_init_turnament(dlg, parent)
	--printf("CArenaext:dlg_init_turnament()")

	local group = self.groups["turnament"]
	local dlg_id = group.dlg_id

	local phr = dlg:AddPhrase(group.title, dlg_id, parent, -10000)
	local phr_script = phr:GetPhraseScript()
	phr_script:AddDontHasInfo(group.done)

	dlg:AddPhrase(group.info, dlg_id+1, dlg_id, -10000)

	local i, j
	local name1, name2
	local fight_id = dlg_id + 100
	local n = table.getn(group.teams)
	for i=1, n do
		name1 = group.teams[i]
		for j=1, n do
			if i ~= j then
				name2 = group.teams[j]
				self:dlg_init_turnament_fight(dlg, name1, name2, dlg_id+1, fight_id)
				fight_id = fight_id + 100
			end
		end
	end

	dlg:AddPhrase("aem_job_group_reject", dlg_id+2, dlg_id+1, -10000)
end

-------
-- добавляет в диалог один бой turnament
-------
function CArenaext:dlg_init_turnament_fight(dlg, name1, name2, parent, dlg_id)
	--printf("CArenaext:dlg_init_turnament_fight('%s vs %s')", name1, name2)

	local team1 = self.teams[name1]
	local team2 = self.teams[name2]

	local title = game.translate_string(team1.name1)
	title = title .. " "
	title = title .. game.translate_string("aem_job_stake_vs")
	title = title .. " "
	title = title .. game.translate_string(team2.name2)

	local phr = dlg:AddPhrase(title, dlg_id, parent, -10000)
	local phr_script = phr:GetPhraseScript()
	phr_script:AddPrecondition("aem_manager.is_turnament_valid")

	dlg:AddPhrase("aem_job_stake_quest", dlg_id+1, dlg_id, -10000)

	phr = dlg:AddPhrase(team1.name, dlg_id+2, dlg_id+1, -10000)
	phr_script = phr:GetPhraseScript()
	phr_script:AddGiveInfo("aem_stake_team1")
	phr_script:AddDisableInfo("aem_stake_team2")

	dlg:AddPhrase("aem_job_stake_money", dlg_id+3, dlg_id+2, -10000)
	self:dlg_init_stake_tree(dlg, dlg_id+10, dlg_id+3)

	phr = dlg:AddPhrase(team2.name, dlg_id+4, dlg_id+1, -10000)
	phr_script = phr:GetPhraseScript()
	phr_script:AddGiveInfo("aem_stake_team2")
	phr_script:AddDisableInfo("aem_stake_team1")

	dlg:AddPhrase("aem_job_stake_money", dlg_id+5, dlg_id+4, -10000)
	self:dlg_init_stake_tree(dlg, dlg_id+50, dlg_id+5)

	dlg:AddPhrase("aem_job_stake_reject", dlg_id+6, dlg_id+1, -10000)
end

-------
-- добавляет в диалог ветку со ставками
-------
function CArenaext:dlg_init_stake_tree(dlg, stake, parent)

	local tm = " "..game.translate_string("aem_job_stake_money_tm")

	local phr = dlg:AddPhrase(tostring(stake1)..tm, stake, parent, -10000)
	local phr_script = phr:GetPhraseScript()
	phr_script:AddPrecondition("aem_manager.has_money_1")

	phr = dlg:AddPhrase("aem_job_stake_ready", stake+1, stake, -10000)
	phr_script = phr:GetPhraseScript()
	phr_script:AddGiveInfo("aem_stake1")
	phr_script:AddAction("aem_manager.start_fight")

	phr = dlg:AddPhrase("aem_job_stake_go", stake+2, stake+1, -10000)
	phr_script = phr:GetPhraseScript()
	phr_script:AddAction("dialogs.break_dialog")

	phr = dlg:AddPhrase(tostring(stake2)..tm, stake+10, parent, -10000)
	phr_script = phr:GetPhraseScript()
	phr_script:AddPrecondition("aem_manager.has_money_2")

	phr = dlg:AddPhrase("aem_job_stake_ready", stake+11, stake+10, -10000)
	phr_script = phr:GetPhraseScript()
	phr_script:AddGiveInfo("aem_stake2")
	phr_script:AddAction("aem_manager.start_fight")

	phr = dlg:AddPhrase("aem_job_stake_go", stake+12, stake+11, -10000)
	phr_script = phr:GetPhraseScript()
	phr_script:AddAction("dialogs.break_dialog")

	phr = dlg:AddPhrase(tostring(stake3)..tm, stake+20, parent, -10000)
	phr_script = phr:GetPhraseScript()
	phr_script:AddPrecondition("aem_manager.has_money_3")

	phr = dlg:AddPhrase("aem_job_stake_ready", stake+21, stake+20, -10000)
	phr_script = phr:GetPhraseScript()
	phr_script:AddGiveInfo("aem_stake3")
	phr_script:AddAction("aem_manager.start_fight")

	phr = dlg:AddPhrase("aem_job_stake_go", stake+22, stake+21, -10000)
	phr_script = phr:GetPhraseScript()
	phr_script:AddAction("dialogs.break_dialog")

	phr = dlg:AddPhrase("aem_job_stake_money_empty", stake+30, parent, -10000)
	phr_script = phr:GetPhraseScript()
	phr_script:AddPrecondition("aem_manager.hasnt_money")

	phr = dlg:AddPhrase("aem_job_stake_money_reject", stake+31, parent, -10000)
	phr_script = phr:GetPhraseScript()
	phr_script:AddPrecondition("aem_manager.has_money_1")
end

-------
-- возвращает id фразы боя turnament
-------
function CArenaext:turnament_phrase_id(name)
	local info = self.fights[name]
	local name1 = aem_get_value(info.team1, "")
	local name2 = aem_get_value(info.team2, "")
	return self.turnament_phrase[name1 .. name2]
end

-------
-- возвращает id фразы боя stakes
-------
function CArenaext:stakes_phrase_id(name)
	local info = self.fights[name]
	local name1 = aem_get_value(info.team1, "")
	local name2 = aem_get_value(info.team2, "")
	return self.stakes_phrase[name1 .. name2]
end

-------
-- возвращает имя боя по id фразы
-------
function CArenaext:fight_by_phrase(phr_id)
	local name, info

	info = self.groups["turnament"]
	if (phr_id >= info.dlg_id) and (phr_id < info.dlg_id + info.dlg_size) then
		local i, id
		local n = table.getn(info.fights)
		for i=1, n do
			name = info.fights[i]
			id = self:turnament_phrase_id(name)
			if (id ~= nil) and (phr_id >= id) and (phr_id < id + 100) then
				return name
			end
		end
		return ""
	end

	info = self.groups["stakes"]
	if (phr_id >= info.dlg_id) and (phr_id < info.dlg_id + info.dlg_size) then
		local i, id
		local n = table.getn(info.fights)
		for i=1, n do
			name = info.fights[i]
			id = self:stakes_phrase_id(name)
			if (id ~= nil) and (phr_id >= id) and (phr_id < id + 100) then
				return name
			end
		end
		return ""
	end

	for name, info in pairs(self.fights) do
		if (phr_id >= info.dlg_id) and (phr_id < info.dlg_id + info.dlg_size) then
			return name
		end
	end
	return ""
end

---------------------------------------------------------------------------------------------------
-- функции для работы с инвентарём и ящиком
---------------------------------------------------------------------------------------------------

-------
-- переносит заданные вещи из инвентаря ГГ в ящик
-- void put_items_to_box(game_object box, {["section1"]=true, ["section2"]=true, ...} items)
-------
function put_items_to_box(box, items)
	Actor:iterate_inventory(function(arg, item) 
		if items[item:section()] == true then
			Actor:transfer_item(item, box)
		end
	end)
end

-------
-- переносит все вещи, кроме заданных, из инвентаря ГГ в ящик
-- void put_items_to_box_exept(game_object box, {["section1"]=true, ["section2"]=true, ...} exept)
-------
function put_items_to_box_exept(box, exept)
	Actor:iterate_inventory(function(arg, item) 
		if exept[item:section()] ~= true then
			Actor:transfer_item(item, box)
		end
	end)
end

-------
-- удаляет заданные вещи из инвентаря ГГ
-- void clear_items({["section1"]=true, ["section2"]=true, ...} items)
-------
function clear_items(items)
	Actor:iterate_inventory(function(arg, item) 
		if items[item:section()] == true then
			release(item)
		end
	end)
end

-------
-- очистить ящик в онлайне
-- void clear_box(game_object box)
-------
function clear_box(box)
	--printf("clear_box('%s')", box:name())
	local obj
	local ids = enum_box_items(box)
	for i, id in pairs(ids) do
		AI:release(AI:object(id), true)
	end
end

-------
-- очистить ящик в офлайне
-- void clear_offline_box(number sid)
-------
function clear_offline_box(sid)
	--printf("clear_offline_box(sid=%d)", sid)
	local obj = AI:story_object(sid)
	if obj then
		local box = obj.id
		local id
		for id=0, 65535 do
			obj = AI:object(id)
			if obj and obj.parent_id == box then
				--printf("release(%s)", obj:name())
				AI:release(obj, true)
			end
		end
	end
end

-------
-- получить список id вещей лежащих в ящике
-- {id1, id2, ...} enum_box_items(game_object box)
-------
function enum_box_items(box)
	--printf("enum_box_items(box='%s')", box:name())
	local obj
	local own
	local ids = {}
	for id=0, 65535 do
		obj = level.object_by_id(id)
		if obj ~= nil then
			own = obj:parent()
			if own ~= nil and own:id() == box:id() then
				--printf("enum section='%s' id=%d", obj:section(), id)
				table.insert(ids, id)
			end
		end
	end
	return ids
end

---------------------------------------------------------------------------------------------------
-- переопределённые binder-ы, как алтернатива net_spawn
---------------------------------------------------------------------------------------------------

-------
-- binder для привязки сталкеров к 'bar_arena_restrictor'
-------
function bind_npc(npc)
	npc:add_restrictions("bar_arena_restrictor","")
	bind_stalker.init(npc)
end

-------
-- binder для привязки админов к 'bar_restrictor'
-------
function bind_admin(npc)
	if Actor:has_info("aem_go_bar") then
		npc:add_restrictions("bar_restrictor", "")
	else
		npc:remove_all_restrictions()
	end
	bind_stalker.init(npc)
end

-------
-- binder для привязки монстров к 'bar_arena_restrictor'
-- !!! не работает для контролёра !!!
-------
function bind_mob(mob)
	mob:add_restrictions("bar_arena_restrictor","")
	bind_monster.bind(mob)
end

---------------------------------------------------------------------------------------------------
-- получение и отнятие денег без передачи NPC
---------------------------------------------------------------------------------------------------
function manage_money(num, type)
	if Actor then
		if type == "in" then
			got_money(num)
		elseif type == "out" then
			lost_money(num)
		end
	end
end

---------------------------------------------------------------------------------------------------
-- вывод сообщений об арене
---------------------------------------------------------------------------------------------------
function msg(text)
	local npc, who, icon, msg, snd
	if Actor:has_info("aem_arny_dead") or
		Actor:has_info("aem_admin_dead") or
		Actor:has_info("aem_arny_spread_out") or
		Actor:has_info("aem_admin_spread_out") then
		who = game.translate_string("aem_barman")
		icon = Frect():set(332,235,84,45)
	else
		npc = AI:object(aem_get_value("aem_id"))
		if npc ~= nil and npc:alive() == true then
			if npc:profile_name() == "aem_arny" then
				who = game.translate_string("bar_arny_name")
				icon = Frect():set(332,141,84,45)
			else
				who = game.translate_string("aem_admin")
				icon = Frect():set(83,329,84,45)
			end
		end
	end

	msg = game.translate_string(text)
	snd = xr_sound.get_safe_sound_object([[device\pda\pda_tip]])
	snd:play_no_feedback(Actor, sound_object.s2d, 0, vector(), 1.0)
	Actor:give_game_news("%c[255,238,155,23]"..who..":\\n%c[default]"..msg, "ui\\ui_iconstotal", icon, 0, 15000)
end

function npc(npc)
	return npc
end
---------------------------------------------------------------------------------------------------
-- функции для работы со временем
---------------------------------------------------------------------------------------------------

-------
-- время следующего открытия
-------
function time_get_next(curr)
	-- задание случайного интервала следующего открытия арены
	if delay_min < 1 then
		curr = curr + (math.random(delay_max) - 1) * 24
	else
		curr = curr + math.random(delay_min, delay_max) * 24
	end

	local days = math.floor(curr / 24)
	local hour = curr - days * 24

	local next = days * 24 + time_open
	if hour >= time_open then
		next = next + 24
	end
	return next
end

-------
-- проверка, не пора ли закрывать арену
-------
function time_need_close(curr, open)
	local need = open + time_close - time_open
	if time_close < time_open then
		need = need + 24
	end
	return curr >= need
end

---------------------------------------------------------------------------------------------------
-- создание диалога выдачи боёв
---------------------------------------------------------------------------------------------------
function dlg_init(dlg, npc)
	aem:dlg_init(dlg)
end

---------------------------------------------------------------------------------------------------
-- Проверка условий диалогов - precondition
---------------------------------------------------------------------------------------------------

-------
-- проверка возможности показа в диалоге ветки дополнительных боёв
-------
function is_stakes_or_turnament_valid()
	return	not has_info(aem.groups["stakes"].done) or
		not has_info(aem.groups["turnament"].done)
end

-------
-- проверка возможности показа в диалоге боя 'stakes'
-------
function is_stakes_valid(npc1, npc2, dlg_name, phr_prev, phr_curr)
	name = aem:fight_by_phrase(tonumber(phr_curr))
	if name == "" then
		return false
	end
	return not has_info(aem.fights[name].done)
end

-------
-- проверка возможности показа в диалоге боя 'turnament'
-------
function is_turnament_valid(npc1, npc2, dlg_name, phr_prev, phr_curr)
	name = aem:fight_by_phrase(tonumber(phr_curr))
	if name == "" then
		return false
	end
	return not has_info(aem.fights[name].done)
end

-------
-- проверка наличия денег на ставку
-------
function has_money_1()
	return Actor:money() >= stake1
end

function has_money_2()
	return Actor:money() >= stake2
end

function has_money_3()
	return Actor:money() >= stake3
end

function hasnt_money()
	return Actor:money() < stake1
end

-------
-- проверка вариантов диалога награды за бой
-------

-- ставка выиграла
--
function is_reward_stake_win()
	if not aem:is_stake() then
		return false
	end
	return aem:is_stake_win()
end

-- ставка проиграла
--
function is_reward_stake_fail()
	if not aem:is_stake() then
		return false
	end
	return not aem:is_stake_win()
end

-- бой без ограничения времени
--
function is_reward_nostake_unlimit()
	if aem:is_stake() then
		return false
	end
	if Actor:has_info("aem_bonus") then
		return false
	end
	return true
end

-- бой с ограничением времени - победа
--
function is_reward_nostake_bonus()
	if aem:is_stake() then
		return false
	end
	if not has_info("aem_bonus") then
		return false
	end
	return not has_info("aem_timeover")
end

-- бой с ограничением времени - ничья
--
function is_reward_nostake_timeover()
	if aem:is_stake() then
		return false
	end
	if not has_info("aem_bonus") or not has_info("aem_timeover") then
		return false
	end
	return not has_info("aem_fight_foul")
end

-- бой с ограничением времени - фолл
--
function is_reward_nostake_foul()
	if aem:is_stake() then
		return false
	end
	if not has_info("aem_bonus") or not has_info("aem_timeover") then
		return false
	end
	return Actor:has_info("aem_fight_foul")
end

-------
-- проверка вариантов диалога для инициализации арены
-------

-- первая активация
--
function is_init_first()
	return aem.init_t == 0
end

-- не первая активация
--
function is_init_not_first()
	return not is_init_first()
end

-- сборная
--
function is_init_stalkers()
	return aem:is_stalkers_evil()
end

-- не сборная
--
function is_init_not_stalkers()
	return not is_init_stalkers()
end

-- мутанты
--
function is_init_mutants()
	return aem:get_mutants_time() >= delay_mut*24
end

-- не мутанты
--
function is_init_not_mutants()
	return not is_init_mutants()
end

---------------------------------------------------------------------------------------------------
-- функции диалогов - action
---------------------------------------------------------------------------------------------------

-------
-- инициализация мода
-------
function startup()
	aem:startup()
end

function timeup()
	aem:timeup()
end
-------
-- удаление мода
-------
function cleanup()
	aem:cleanup()
end

-------
-- сделать на арене посветлее
-------
function lights_on()
	aem_lights.lights_on()
end

-------
-- вернуть прежнее освещение
-------
function lights_off()
	aem_lights.lights_off()
end

-------
-- 'суточная' переинициализация боёв
-------
function reinit()
	aem:reinit()
end

-------
-- начать бой, какой именно - определяется по id фразы
-------
function start_fight(npc1, npc2, dlg_name, phr_curr)
-- отсекание случая закрытия арены во время диалога
	if not has_info("aem_ready") then
		Actor:disable_info_portion("aem_bonus")
		Actor:disable_info_portion("aem_bonus_5s")
		Actor:disable_info_portion("aem_bonus_10s")
		Actor:disable_info_portion("aem_bonus_15s")
		Actor:disable_info_portion("aem_bonus_20s")
		Actor:disable_info_portion("aem_bonus_30s")
		Actor:disable_info_portion("aem_bonus_40s")
		Actor:disable_info_portion("aem_bonus_50s")
		Actor:disable_info_portion("aem_bonus_60s")
		Actor:disable_info_portion("aem_stake_team1")
		Actor:disable_info_portion("aem_stake_team2")
		Actor:disable_info_portion("aem_stake1")
		Actor:disable_info_portion("aem_stake2")
		Actor:disable_info_portion("aem_stake3")
		dialogs.break_dialog(npc1, npc2)
		return
	end

	aem:start(tonumber(phr_curr))
end

-------
-- закрытие боя и получение награды, если она есть
-------
function close_fight()
	aem:close()
end

-------
-- функция части инициализации смерти аренных менеджеров
-------
function admin_dead()
	if Actor:has_info("aem_arny_dead") then
		msg("aem_arny_dead")
	elseif Actor:has_info("aem_arny_spread_out") then
		msg("aem_arny_spread_out")
	elseif Actor:has_info("aem_admin_dead") then
		local txt = {"aem_barm_1", "aem_barm_2", "aem_barm_3", "aem_barm_4"}
		local cnt = table.getn(txt)
		local rnd = math.random(cnt)
		msg(txt[rnd])
	elseif Actor:has_info("aem_admin_spread_out") then
		msg("aem_admin_spread_out")
	end

	if not has_info("aem_startup") then
		timeup()
	end

	-- иммитируется закрытие арены
	Actor:disable_info_portion("aem_spam")
	Actor:disable_info_portion("aem_megafone")

	rt = math.random(5,11)
	aem_set_value("aem_rt", rt)
	aem_set_value("aem_id", -1)
end

-------
-- заспавним-ка нового администратора для арены
-------
function admin_spawn()
	local obj = AI:create("aem_admin", vector():set(153.451, -0.00164, 42.0269), 40777, 1230)

	-- сохранение id нового админа
	aem_set_value("aem_id", obj.id)
end
