--[[---------------------------------------------------------------------------
 * Callbacks
--]]---------------------------------------------------------------------------

local start = true
local pause_menu_init = true

local load_slot_act
load_del_bolt = nil

local next_update_200 = 0
local next_update_1000 = 0
local next_update_5000 = 0

function net_spawn(self)
	if pause_menu_init then
		give_info("paused_on_load")
	end

	self.weapon_manager = reap_wpn.get_weapon_manager()
	reap_af.trans_init()

	bolt_ending.net_spawn()
	reap_misc.net_spawn()
end

function update(self)
	if start then
		level_tasks.check_lchanger_location()
		load_slot_hide()
		self.weather_manager:reset()
		ui_scroll_indicators.first_update()

		start = false
	end

	if pause_menu_init and screen.precache_frame <= 1 then
		load_slot_restore()

		console:execute("main_menu 1")
		pause_menu_init = false
	end

	update_timers()
	medkit_use.show_med()
	self.weapon_manager:update()

	if next_update_200 > time_real_ms then return end
	next_update_200 = time_real_ms + 200

	Inventory:update()
	safe_place()

	if next_update_1000 > time_real_ms then return end
	next_update_1000 = time_real_ms + 1000

	self.weather_manager:update()
	update_fires()
	check_spots()

	if next_update_5000 > time_real_ms then return end
	next_update_5000 = time_real_ms + 5000

	math.randomseed(os.time())
end

local detectors = table.tohash({
	"detector_simple", "detector_advances",
	"detector_elite", "detector_elite_sak"
})

function item_drop_from_belt(obj)
	Inventory:on_item_move_from_belt(obj)
	belt_redraw()

	local sect = obj:section()
	if detectors[sect] then
		detector_from_belt()
	elseif sect == "bioradar" then
		biodetector.switch(Inventory:on_belt("bioradar") ~= nil)
	end

	bolt_ending.on_item_drop_from_belt(obj, true)
end

function item_belt(obj)
	Inventory:on_item_belt(obj)
	belt_redraw()

	local sect = obj:section()
	if detectors[sect] then
		ui_rad.switch(true)
	elseif sect == "bioradar" then
		biodetector.switch(true)
	end

	bolt_ending.on_item_belt(obj)
	grenade_belt.on_item_belt(obj)
end

function item_move_from_belt(obj)
	Inventory:on_item_move_from_belt(obj)
	belt_redraw()

	local sect = obj:section()
	if detectors[sect] then
		detector_from_belt()
	elseif sect == "bioradar" then
		biodetector.switch(Inventory:on_belt("bioradar") ~= nil)
	end

	bolt_ending.on_item_drop_from_belt(obj)
end

function item_ruck(obj)
	ammo_belt.on_item_ruck(obj)
	grenade_belt.on_item_ruck(obj)
end

function item_slot(obj)
	grenade_belt.on_item_slot(obj)
end

function before_use_item(binded, obj)
	medkit_use.before_use_item(obj)
end

local use_fn = {
	["amk_transmutator"]	= transmutator.amkEnableDevice
}

function item_use(binded, obj)
	local sect = obj:section()
	local fn = use_fn[sect]

	if fn then
		fn(obj)
	else
		amk.item_use(obj)
		medkit_use.used_med(obj)
	end

	local sound = config:r_string_cache(sect, "use_sound")
	if sound then
		wpn_hide_disable()
		timer("reap.wpn_show_enable", (level.get_game_difficulty() + 1) * 2000, true)

		say(sound)
	end
end

local smart_info = table.tohash({
	"bar_deactivate_radar_done", "sar_finish_decoding",
	"sar2_monolith_miracle", "aes2_monolit_teleport_ready_final"
})

function info(info_id, ui_info)
	if ui_info then
		process_ui_info(info_id)
	elseif smart_info[info_id] then
		smart_terrain.init_level_groups()
	else
		mark_npc(info_id)
		dmx_sleep_binder.place_of_sleep_spawn(info_id)
	end
end

function attach_vehicle(obj)
	if has_map_spot(obj:id(), "green_location") > 0 then
		del_map_spot(obj:id(), "green_location")
	end
end

function new_game()
	level_tasks.add_lchanger_location()
	load_del_bolt = true

	fix_all_spawn()
	dmx_sleep_binder.place_of_sleep_spawn()
	ogse_zoneseffect.special_effects_spawn()
	spawn_dynamic_fires()

	news_main.new_game()
	trade_manager.new_game()
end

function actor_save(packet)
	local flags = 0
	if Actor:active_slot() < 10 then
		flags = bit_or(flags, 1)
	end

	packet:w_u8(flags)
end

function actor_load(reader)
	local flags = reader:r_u8()

	if bit_and(flags, 1) ~= 0 then
		load_slot_act = true
	end
end

--[[---------------------------------------------------------------------------
* Active slot management
--]]---------------------------------------------------------------------------

local vars = container:get("reap", { })
local load_slot_item

function load_slot_hide()
	if load_del_bolt then
		bolt_ending.del_bolt()
		load_del_bolt = nil

		if Actor:active_slot() == inventory_slots.BOLT then
			return
		end
	end

	load_slot_item = Actor:active_item()
	if load_slot_item then
		Actor:move_to_ruck(load_slot_item)
		load_slot_item = load_slot_item:id()
	end
end

function load_slot_restore()
	if vars.wpn_refcnt then
		Actor:hide_weapon()
	end

	if not load_slot_item then return end
	load_slot_item = level_object(load_slot_item)
	if not load_slot_item then return end

	if load_slot_act and not vars.wpn_refcnt then
		Actor:move_to_slot_and_activate(load_slot_item)
	else
		Actor:move_to_slot(load_slot_item)
	end
	load_slot_item = nil
	load_slot_act = nil
end

function drop_weapon(punch)
	local active_item = Actor:active_item()
	if active_item then
		local active_sect = active_item:section()
		if active_sect == "wpn_knife" then
			if punch == true then
				Actor:activate_slot(-1)
			else
				Actor:drop_item(active_item)
			end
		elseif active_sect == "bolt" then
			bolt_ending.drop_bolt()
		else
			Actor:drop_item(active_item)
		end
	end
end

function wpn_show_enable(info_id)
	if screen.precache_frame > 0 then
		timer(wpn_show_enable, 400, true, info_id)
		return
	end

	if info_id then
		ammo_belt.on_info(info_id)
		grenade_belt.on_info(info_id)
	end

	if not vars.wpn_refcnt then return end
	vars.wpn_refcnt = vars.wpn_refcnt - 1
	if vars.wpn_refcnt ~= 0 then return end

	vars.wpn_refcnt = nil
	Actor:restore_weapon()

	local act = vars.last_slot
	if not act then return end
	vars.last_slot = nil

	if act < 10 then
		level.parked_call(function()
			Actor:activate_slot(act)
		end)
	end
end

function wpn_hide_disable(info_id)
	if screen.precache_frame > 0 then
		timer(wpn_hide_disable, 400, true, info_id)
		return
	end

	vars.wpn_refcnt = (vars.wpn_refcnt or 0) + 1
	if vars.wpn_refcnt == 1 then
		local act = Actor:active_slot()
		if act < 10 then
			Actor:activate_slot(-1)
			vars.last_slot = act
		end

		Actor:hide_weapon()
	end

	if info_id then
		ammo_belt.on_info(info_id)
		grenade_belt.on_info(info_id)
	end
end

local info_fn = {
	ui_car_body		= wpn_hide_disable,
	ui_car_body_hide	= wpn_show_enable,
	ui_pda			= wpn_hide_disable,
	ui_pda_hide		= wpn_show_enable,

	ui_inventory = function(info_id)
		Inventory:on_inventory_info(info_id)
		wpn_hide_disable(info_id)
	end,
	ui_inventory_hide = function(info_id)
		Inventory:on_inventory_info(info_id)
		wpn_show_enable(info_id)
	end,
	ui_talk = function()
		if has_info("ui_trade_hide") then
			wpn_hide_disable()
		end
	end,
	ui_talk_hide = function()
		if not level.main_input_receiver() then
			wpn_show_enable()
		end
	end,
	ui_trade = function(info_id)
		if Actor:is_talking() then
			ammo_belt.on_info(info_id)
			grenade_belt.on_info(info_id)
		else
			wpn_hide_disable(info_id)
		end
	end,
	ui_trade_hide = function(info_id)
		if has_info("ui_talk") then
			ammo_belt.on_info(info_id)
			grenade_belt.on_info(info_id)
		else
			wpn_show_enable(info_id)
		end
	end
}

function process_ui_info(info_id)
	local fn = info_fn[info_id]
	if fn then
		fn(info_id)
	end

	belt_redraw()
end

--[[---------------------------------------------------------------------------
 * HUD
--]]---------------------------------------------------------------------------

local sleep_cs, hide

hit_effectors = reap_misc.hit_effectors

function safe_place()
	local need_hit, khit

	if hide == nil then
		hide = amk_hideouts.hide[curr_level] and true or false
	end
	if hide == true then
		need_hit, khit = amk_mod.blowout_khit()
	else
		need_hit, khit = false, 1
	end

	if khit < 0.5 then
		if not sleep_cs then
			hud:AddCustomStatic("sleep_static", true)
			sleep_cs = hud:GetCustomStatic("sleep_static")
		end
	else
		if sleep_cs then
			hud:RemoveCustomStatic("sleep_static")
			sleep_cs = nil
		end
	end
end

function detector_from_belt()
	for sect, v in pairs(detectors) do
		if Inventory:on_belt(sect) ~= nil then
			ui_rad.switch(true)
			return
		end
	end

	ui_rad.switch(false)
end

--[[---------------------------------------------------------------------------
 * Full belt on HUD
--]]---------------------------------------------------------------------------

local belt_pri = {
	bioradar	= 7,
	bolt_box	= 1
}
for sect in pairs(detectors) do
	belt_pri[sect] = 6
end

local belt_ui = { }

function belt_item(obj)
	local sect = obj:section()
	local ret = {
		sect	= sect,
		cost	= obj:cost()
	}

	ret.pri = belt_pri[sect]
	if ret.pri then
		return ret
	end

	if obj:is_ammo() then
		ret.width = config:r_u32_cache(sect, "inv_grid_width")
		ret.box = config:r_u32_cache(sect, "box_size")
		ret.pri = 3
	elseif obj:is_artefact() then
		ret.pri = 5
	elseif obj:is_grenade() then
		ret.pri = 2
	else
		ret.pri = 4
	end

	return ret
end

function belt_sort(a, b)
	if a.pri ~= b.pri then
		return a.pri > b.pri
	elseif a.box then
		if a.width ~= b.width then
			return a.width > b.width
		elseif a.box ~= b.box then
			return a.box > b.box
		end
	end
	if a.cost ~= b.cost then
		return a.cost > b.cost
	else
		return a.sect < b.sect
	end
end

local ui_icon_equipment = "ui\\ui_icon_equipment"

function belt_redraw()
	if #belt_ui > 0 then
		for i = 1, #belt_ui do
			hud:RemoveDialogToRender(belt_ui[i])
		end

		belt_ui = { }
	end

	if level.main_input_receiver() or Actor:belt_count() == 0 or
	   not is_hud_draw() then
		return
	end

	local belt_tbl = { }
	for id, obj in pairs(Inventory.belt_by_id) do
		belt_tbl[#belt_tbl + 1] = belt_item(obj)
	end

	table.sort(belt_tbl, belt_sort)

	local item, static
	local cur_x = 25
	local t, sta_w

	for i = 1, #belt_tbl do
		item = belt_tbl[i]
		t = get_icon_info(item.sect, true)
		sta_w = t.w * refactor / 2

		static = CUIStatic()
		static:Init(ui_icon_equipment, cur_x, 640, sta_w, 25)
		cur_x = cur_x + sta_w + 1

		static:SetOriginalRect(t.x, t.y, t.w, t.h)
		static:SetStretchTexture(true)
		hud:AddDialogToRender(static)

		belt_ui[i] = static
	end
end

--[[---------------------------------------------------------------------------
 * Timers
--]]---------------------------------------------------------------------------

local timer_res = 100
local timer_tick = game.CTime():set_table({ msec = timer_res * base_time_factor })

local timers = container:get("timers", { })
local timer_nextup = #timers > 0 and game.get_game_time() or nil

function timer_cmp(t1, t2)
	return t1.time > t2.time
end

_G.timer = function(event, delay, real, ...)
	if not event or not delay then return false end

	if real == true then
		delay = delay * base_time_factor
	end

	local exp = game.CTime():set_table({ msec = delay })
	local args = { ... }

	table.insert(timers, {
		event	= event,
		time	= time_game_ct + exp,
		args	= #args > 0 and args or nil
	})
	table.sort(timers, timer_cmp)

	if not timer_nextup then
		timer_nextup = time_game_ct
	end

	return true
end

function stop_timer(idx)
	table.remove(timers, idx)
	if #timers > 0 then
		table.sort(timers, timer_cmp)
	else
		timer_nextup = nil
	end
end

function update_timers()
	if not timer_nextup then return end

	if timer_nextup > time_game_ct then return end
	timer_nextup = time_game_ct + timer_tick

	local funcs = { }
	local tm
	for i = #timers, 1, -1 do
		tm = timers[i]
		if tm.time <= time_game_ct then
			funcs[#funcs + 1] = tm
			stop_timer(i)
		else
			break
		end
	end

	for i = 1, #funcs do
		tm = funcs[i]
		if type(tm.event) == "string" then
			loadstring("return function(args) " .. tm.event .. "(unpack(args or { })) end")()(tm.args)
		else
			tm.event(unpack(tm.args or { }))
		end
	end
end

--[[---------------------------------------------------------------------------
 * Dynamic fires (former Dynamic Campfire)
--]]---------------------------------------------------------------------------

local fire_excl = {
	l06_rostok = {
		zone_flame_0000		= "yantar_scientists_talk",
		zone_flame_0001		= "yantar_scientists_talk",
		zone_flame_0002		= "yantar_scientists_talk",
		zone_flame_small_0005	= "yantar_scientists_talk",
		zone_flame_small_0006	= "yantar_scientists_talk",
		zone_flame_small_0007	= "yantar_scientists_talk",
		zone_flame_small_0008	= "yantar_scientists_talk",
		zone_flame_small_0010	= "yantar_scientists_talk"
	}
}

local level_flames
local level_lights

function cache_level_fires()
	local level_excl = fire_excl[curr_level]
	local static = { }

	level_flames = { }
	level_lights = { }

	local obj, sect, exc
	for i = 1, 65534 do
		obj = level_object(i)
		if obj then
			sect = obj:section()
			if sect == "zone_dynamic_fire_light" then
				release(obj)
			elseif sect == "zone_flame_small" then
				exc = level_excl and level_excl[obj:name()]
				if not exc then
					level_flames[#level_flames + 1] = i
				elseif has_info(exc) then
					obj:disable_anomaly()
				else
					static[#static + 1] = i
				end
			elseif sect == "lights_hanging_lamp" then
				if string.find(obj:name(), "r1_r2") then
					level_lights[#level_lights + 1] = i
				end
			elseif sect == "zone_flame" then
				exc = level_excl and level_excl[obj:name()]
				if exc and has_info(exc) then
					obj:disable_anomaly()
				end
			end
		end
	end

	for i = 1, #static do
		obj = level_object(static[i])
		create("zone_dynamic_fire_light", obj:position(),
		       obj:level_vertex_id(), obj:game_vertex_id())
	end
end

function bind_dynamic_fire(obj)
	obj:bind_object(dynamic_fire(obj))
end

class "dynamic_fire" (object_binder)

function dynamic_fire:__init(obj)
	super(obj)
end

function dynamic_fire:reload(section)
	object_binder.reload(self, section)
end

function dynamic_fire:reinit()
	object_binder.reinit(self)
end

function dynamic_fire:net_destroy()
	dyn_offline(self.object:name())
	object_binder.net_destroy(self)
end

function dynamic_fire:net_save_relevant()
	return true
end

function dynamic_fire:update(delta)
	object_binder.update(self, delta)

	if self.nextup > time_real_ms then return end

	if self.nextup == 0 then
		local obj
		for i = 1, #level_flames do
			obj = level_object(level_flames[i])
			if obj and (obj:position()):distance_to_sqr(self.object:position()) < 1 then
				self.flame = obj
				break
			end
		end
		for i = 1, #level_lights do
			obj = level_object(level_lights[i])
			if obj and (obj:position()):distance_to_sqr(self.object:position()) < 1 then
				self.light = obj
				break
			end
		end

		if not self.flame then
			release(self.object)
			return
		end

		self.flame:disable_anomaly()
		if self.light then
			self.light:get_hanging_lamp():turn_off()
		end
	end

	local active = false
	for k, v in pairs(db.creatures) do
		if v:is_stalker() and v:alive() and (v:position()):distance_to(self.object:position()) < 4 then
			active = true
			break
		end
	end

	if active and not self.active then
		dyn_ignite(self)
		self.active = true
	elseif not active and self.active then
		dyn_extinguish(self)
		self.active = false
	end

	self.nextup = time_real_ms + 1000
end

function dynamic_fire:net_spawn(data)
	if not object_binder.net_spawn(self, data) then
		return false
	end

	self.active = false
	self.nextup = 0

	return true
end

function spawn_dynamic_fires()
	local obj, exc
	for i = 1, 65534 do
		obj = server_object(i)
		if obj and obj:section_name() == "zone_flame_small" then
			exc = fire_excl[obj:name()]
			if not exc or exc ~= object_level_name(obj) then
				create("zone_dynamic_fire", obj.position, obj.m_level_vertex_id,
				       obj.m_game_vertex_id)
			end
		end
	end
end

local transitions = { }
local spawned_lights = { }

function dyn_ignite(obj)
	transitions[obj.object:name()] = {
		flame		= obj.flame,
		light		= obj.light,
		["time"]	= time_real_ms
	}
end

function dyn_extinguish(obj)
	transitions[obj.object:name()] = {
		flame		= obj.flame,
		light		= obj.light,
		["time"]	= time_real_ms,
		prtcl		= particles_object("dyn_kfire\\dyingfire")
	}
end

function dyn_offline(name)
	release(spawned_lights[name])
	spawned_lights[name] = nil

	transitions[name] = nil
end

function update_fires()
	if not level_flames then
		cache_level_fires()
	end

	for name, v in pairs(transitions) do
		if v.prtcl == nil then
			if v.state == nil then
				v.state = 1
				v.flame:enable_anomaly()
			end

			if v.time + 5000 <= time_real_ms then
				if v.light then
					v.light:get_hanging_lamp():turn_on()
				end
				release(spawned_lights[name])
				spawned_lights[name] = create("zone_dynamic_fire_light",
							      v.flame:position(),
							      v.flame:level_vertex_id(),
							      v.flame:game_vertex_id())
				transitions[name] = nil
			end
		else
			if v.state == nil and v.time + 10000 <= time_real_ms then
				v.state = 1
				release(spawned_lights[name])
				spawned_lights[name] = nil
				v.prtcl:play_at_pos(v.flame:position())
			end

			if v.time + 15000 <= time_real_ms then
				v.flame:disable_anomaly()
			end

			if v.time + 48000 <= time_real_ms then
				if v.light then
					v.light:get_hanging_lamp():turn_off()
				end
			end

			if v.time + 120000 <= time_real_ms then
				v.prtcl:stop()
				transitions[name] = nil
			end
		end
	end
end

--[[---------------------------------------------------------------------------
 * Map spots for important NPCs
--]]---------------------------------------------------------------------------

local npc_spots_id = {
	[1]					= "trader_npc_mapspot",
	[2]					= "boss_npc_mapspot",
	[3]					= "repair_npc_mapspot"
}

local npc_spots_hints = {
	[1]					= "hint_trader",
	[2]					= "hint_commander",
	[3]					= "hint_repair"
}

local npc_spots = {
	l01_escape_level_info = {
		[story_ids.Escape_Trader]		= 1,
		[story_ids.Escape_novice_lager_volk]	= 2,
		[story_ids.esc_kuznetsov]		= 2,
		["esc_blokpost_commander"]		= 2,
		[story_ids.esc_dan]			= 1
	},
	l02_garbage_level_info = {
		[story_ids.Garbage_Seriy]		= 2,
		[story_ids.gar_hellcar]			= 2,
		[story_ids.gar_spot_dolg_blokpost]	= 2
	},
	l03_agroprom_level_info = {
		[story_ids.agr_krot]			= 2,
		["agr_nii_commander"]			= 2,
		[story_ids.Sherstuk]			= 2
	},
	agr_krot_band_done = {
		[story_ids.gar_kulinar]			= 1,
		[story_ids.gar_voron]			= 1
	},
	agroprom_military_case_have = {
		[story_ids.agr_adrenalin]		= 1
	},
	l04_darkvalley_level_info = {
		[story_ids.val_borov]			= 2,
		[story_ids.val_bandit_trader]		= 1
	},
	svoboda_sidor_news_done = {
		[story_ids.val_horyn]			= 1
	},
	l05_bar_level_info = {
		[story_ids.bar_Barman]			= 1,
		[story_ids.bar_dolg_captain_ivancov]	= 2,
		[story_ids.bar_dolg_polkovnik_petrenko]	= 1,
		[story_ids.bar_dolg_general_voronin]	= 2,
		[story_ids.Dolgovazyi]			= 3,
		[story_ids.stalker_green_zahar]		= 2
	},
	bar_dolg_community_leader_done = {
		[story_ids.bar_linspiro_ecolog]		= 1
	},
	bar_ecolog_crush_heli_start = {
		[story_ids.bar_freedom_volkodav]	= 2
	},
	yantar_scientists_talk = {
		[story_ids.yan_general_ecolog]		= 1
	},
	mil_dolg_dialog_already = {
		[story_ids.Mil_Master_Max]		= 2,
		[story_ids.Mil_Lukash]			= 2,
		[story_ids.Mil_Dolg_Zoneguard]		= 2,
		[story_ids.Mil_Kap]			= 2,
		[story_ids.Mil_Miser]			= 1,
		[story_ids.mil_Svoboda_engineer]	= 3
	},
	rad_start_svoboda_vs_dolg = {
		[story_ids.Sak]				= 1
	},
	pri_show_zones = {
		[story_ids.pri_monolith_leader]		= 2
	},
	doktor_alife = {
		[story_ids.Doktor]			= 1
	},
	aes_get_soldier_map = {
		["aes_Soldier_commander"]		= 2
	}
}

function mark_npc(info_id)
	local info = npc_spots[info_id]
	if not info then return end

	level.parked_call(function()
		local obj
		for id, _type in pairs(info) do
			obj = type(id) == "number" and story_object(id) or server_object(id)
			if obj and obj:is_stalker() and obj:alive() and
			   has_map_spot(obj.id, npc_spots_id[_type]) == 0 then
				map_spot(obj.id, npc_spots_id[_type], obj:get_netpk("character_name"))
			end
		end
	end, 2)
end

function check_spots()
	local obj
	for info_id, info in pairs(npc_spots) do
		if has_info(info_id) then
			for id, _type in pairs(info) do
				obj = type(id) == "number" and story_object(id) or server_object(id)
				if obj and obj:is_stalker() and not obj:alive() and
				   has_map_spot(obj.id, npc_spots_id[_type]) > 0 then
					del_map_spot(obj.id, npc_spots_id[_type])
				end
			end
		end
	end
end

--[[---------------------------------------------------------------------------
 * Misc
--]]---------------------------------------------------------------------------

local remove_items = {
	-- l01_escape
	"esc_tutorial_trigger", "esc_tutorial_zone", "esc_anomaly_tips_zone", "trader_zone",

	-- l02_garbage
	"gar_vagon_in_restrictor",

	-- l03u_agr_underground
	"agr_u_bloodsucker_rest",

	-- l04_darkvalley
	"val_ammo_9x19_pbp_0000", "val_ammo_5.56x45_ap_0000", "val_ammo_5.56x45_ss190_0000",
	"val_ammo_5.45x39_fmj_0001", "val_ammo_5.45x39_fmj_0003", "val_trader_tip_zone",

	-- l05_bar
	"bar_restrictor", "bar_no_weapon_zone",

	-- l06_rostok
	"rostok_sniper_killer_restrictor",

	-- l07_military
	"mil_wpn_pm_0000", "mil_wpn_pm", "mil_ammo_5.56x45_ss0000", "mil_ammo_5.56x45_ss0002",
	"mil_ammo_11.43x23_hydro0000", "mil_ammo_11.43x23_hydro0001", "mil_sr_sleep_1",

	-- l08_yantar
	"yan_no_weapon_restr",

	-- l10_radar
	"rad_sleep_room",

	-- l10u_bunker
	"bun_krovosos_nest",

	-- l12_stancia
	"aes_space_restrictor_sound_0054",

	-- l12_stancia_2
	"aes2_space_restrictor_no_weapon", "aes2_space_restrictor_zombies"
}

function fix_all_spawn()
	for i = 1, #remove_items do
		release(remove_items[i])
	end
end

function hit_by_actor(who)
	if who == nil then
		return -1
	end

	if type(who) == "userdata" then
		who = who.section_name and who.id or who:id()
	end
	if who == 0 or who == -1 then
		return who
	end

	local car_mgr = sa_cars.get_car_mgr()
	if car_mgr and car_mgr.object:id() == who then
		return 0
	end

	return who
end

function story_name(sid)
	local sobj = sid and story_object(tonumber(sid))

	return sobj and sobj:get_netpk("character_name")
end

function with_discount(num)
	return math.floor(num * freeplay_stats:get_found_pda_discount())
end

function translate_level(lvl)
	if type(lvl) == "userdata" then
		lvl = object_level_name(lvl)
	elseif type(lvl) == "number" then
		lvl = AI:level_name(lvl)
	end

	return translate(lvl)
end

function random_skin(sect)
	local basem, mod = string.match(sect, "^(.+)_m(%d+)$")
	if not basem then basem = sect end

	local base, skin = string.match(basem, "^(.+)_sk(%d+)$")
	if not base then base = basem end

	mod = mod and ("_m" .. mod) or ""
	local tbl = { }

	sect = base .. "_sk1" .. mod
	if not config:section_exist(sect) then
		sect = base .. mod
	end
	if config:section_exist(sect) then
		tbl[1] = sect
	end

	for i = 2, 100 do
		sect = base .. "_sk" .. i .. mod
		if config:section_exist(sect) then
			tbl[#tbl + 1] = sect
		else
			break
		end
	end

	if #tbl > 1 then
		table.sort(tbl, function(a, b)
			return math.random(0, 1) == 0 and a or b
		end)
	end

	return tbl
end
