--[[---------------------------------------------------------------------------
 * Globals
--]]---------------------------------------------------------------------------

_G.hit_mob_types = {
	npc			= 0,
	monster			= 1,
	generic			= 2
}

_G.object_flags = {
	UsedAI_Locations	= 128
}

_G.timer_types = {
	game			= 0,
	real			= 1
}

--[[---------------------------------------------------------------------------
 * Callbacks
--]]---------------------------------------------------------------------------

local next_update_200 = -1

function net_spawn()
	set_timer_tick()
	bolt_ending.net_spawn()
end

function net_destroy()
	bolt_ending.net_destroy()
end

function update()
	update_timers()
	bolt_ending.update()

	local time_ = time_global()

	if next_update_200 < time_ then
		next_update_200 = time_ + 200

		safe_place()
	end
end

function item_take(obj)
	bolt_ending.on_item_take(obj)
end

function item_drop(obj)
	bolt_ending.on_item_drop(obj)
end

function item_drop_from_belt(obj)
	bolt_ending.on_item_drop_from_belt(obj, true)
end

function item_belt(obj)
	inventory.on_item_belt(obj)
	bolt_ending.on_item_belt(obj)
end

function item_move_from_belt(obj)
	bolt_ending.on_item_drop_from_belt(obj)
end

function item_ruck(obj)
	inventory.on_item_ruck(obj)
end

function item_slot(obj)
	inventory.on_item_slot(obj)
end

function take_item_from_box(box, item)
	if box:section() == "m_inventory_box" and box:is_inv_box_empty() then
		local sim = g_alife
		level.start_stop_menu(level.main_input_receiver(), true)
		sim:create("treasure_item", box:position(), db_actor:level_vertex_id(),
			   db_actor:game_vertex_id())
		sim:release(sim:object(box:id()))
	end
end

function new_game()
	bolt_ending.del_bolt()
end

function save(packet)
	save_timers(packet)
end

function load(reader)
	load_timers(reader)
end

--[[---------------------------------------------------------------------------
 * HUD
--]]---------------------------------------------------------------------------

local gg_kick = read_line("gg_kick", "enabled") > 0

local hud = get_hud()
local sleep_cs = nil

function drop_weapon(punch)
	local actor = db_actor
	local active_item = actor:active_item()
	if active_item then
		local active_sect = active_item:section()
		if active_sect == "wpn_knife" then
			if punch and punch == true then
				actor:move_to_ruck(active_item)
				actor:move_to_slot(active_item)
			else
				actor:drop_item(active_item)
			end
		elseif active_sect == "bolt" then
			bolt_ending.drop_bolt()
		else
			actor:drop_item(active_item)
		end
	end
end

function hit_effectors(mob_type, obj, amount)
	if gg_kick ~= true or amount <= 0.05 or not db_actor:alive() then
		return
	end

	level.add_pp_effector("amk_shoot.ppe", effector_ids.hit, false)
	level.set_pp_effector_factor(effector_ids.hit, amount * 100)

	if amount <= 0.3 then
		return
	end

	level.add_cam_effector("camera_effects\\fusker.anm", 999, false, "")
	local snd_obj = xr_sound.get_safe_sound_object([[actor\pain_3]])
	snd_obj:play_no_feedback(db_actor, sound_object.s2d, 0, vector(), 1.0)

	if math.random() < (amount / 2) then
		drop_weapon()
	end
end

function safe_place()
	local need_hit, khit = amk_mod.blowout_khit()

	if khit < 0.5 then
		if not sleep_cs then
			hud:AddCustomStatic("sleep_static", true)
			sleep_cs = hud:GetCustomStatic("sleep_static")
		end
	else
		if sleep_cs then
			hud:RemoveCustomStatic("sleep_static")
			sleep_cs = nil
		end
	end
end

--[[---------------------------------------------------------------------------
 * Timers
--]]---------------------------------------------------------------------------

local timer_res = 100
local timer_tick

local timers = { }
local timer_nextup

local string_match = string.match

function set_timer_tick()
	timer_tick = game.CTime()
	timer_tick:setHMSms(0, 0, 0, timer_res * base_time_factor)
end

function start_timer(event, delay, type)
	if not event or not delay then return false end
	if not string_match(event, "(.+)[(].*[)]") then return false end

	if type and type == timer_types.real then
		delay = delay * base_time_factor
	end

	local exp = game.CTime()
	exp:setHMSms(0, 0, 0, delay)
	local now = game.get_game_time()

	local tm = {
		event	= event,
		time	= now + exp
	}
	table.insert(timers, tm)

	if not timer_nextup then
		timer_nextup = now
	end

	return true
end

function has_timer(event)
	if not timer_nextup or not event then return false end

	local func = string_match(event, "(.+)[(].*[)]")
	if not func then return false end

	local i = 1
	while i <= #timers do
		local tm = timers[i]
		if string_match(tm.event, "(.+)[(].*[)]") == func then
			return true
		else
			i = i + 1
		end
	end

	return false
end

function stop_timer(idx)
	table.remove(timers, idx)

	if #timers == 0 then
		timer_nextup = nil
	end
end

function update_timers()
	if not timer_nextup then return end

	local now = game.get_game_time()
	if timer_nextup > now then return end
	timer_nextup = now + timer_tick

	local tm, func
	local i = 1
	while i <= #timers do
		tm = timers[i]
		if tm.time <= now then
			func = loadstring(tm.event)
			stop_timer(i)

			if type(func) == "function" then
				pcall(func)
			end
		else
			i = i + 1
		end
	end
end

local utils_r_CTime = utils.r_CTime
local utils_w_CTime = utils.w_CTime

function save_timers(packet)
	local num = #timers
	packet:w_u16(num)

	local tm
	for i = 1, num do
		tm = timers[i]
		packet:w_stringZ(tm.event)
		utils_w_CTime(packet, tm.time)
	end
end

function load_timers(reader)
	local num = reader:r_u16()
	timers = { }

	for i = 1, num do
		timers[i] = {
			event	= reader:r_stringZ(),
			time	= utils_r_CTime(reader)
		}
	end

	timer_nextup = (num > 0 and game.get_game_time()) or nil
end

--[[---------------------------------------------------------------------------
 * Misc
--]]---------------------------------------------------------------------------

function with_discount(num)
	return math.floor(num * xr_statistic_freeplay.get_freeplay_statistic():get_found_pda_discount())
end
