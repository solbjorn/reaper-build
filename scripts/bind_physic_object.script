----------------------------------------------------------------------------------------------------
-- Physic objects binding
----------------------------------------------------------------------------------------------------
-- Разработчик: Evgeniy Negrobov (Jon) jon@gsc-game.kiev.ua
-- Доработки: Andrey Fidrya (Zmey) af@svitonline.com
----------------------------------------------------------------------------------------------------

local clsid_projector = clsid.projector

function init(obj)
	----------------------------------------------------------------------------------------
	-- Новые схемы
	----------------------------------------------------------------------------------------

	local ini = obj:spawn_ini()
	if not ini then
		return
	end
	-- Биндить предмет нет смысла, если у него нет секции logic
	if not (ini:section_exist("logic") or ini:section_exist("drop_box")) and
	-- Прожектор нужно биндить даже без logic
	   obj:clsid() ~= clsid_projector then
		return
	end

	obj:bind_object(generic_physics_binder(obj))
end

---------------------------------------------------------------------------------------------
local callback_hit = callback.hit
local callback_death = callback.death
local callback_use_object = callback.use_object

class "generic_physics_binder" (object_binder)
function generic_physics_binder:__init(obj) super(obj)
	self.initialized = false
	self.loaded = false
end

function generic_physics_binder:reload(section)
	object_binder.reload(self, section)
end

function generic_physics_binder:reinit()
	object_binder.reinit(self)

	self.st = { }
	db.storage[self.object:id()] = self.st

	self.is_drop_box = self.object:spawn_ini():section_exist("drop_box")

	self.car = self.object:get_car()
	if not self.car then return end

	self.health = self.car:GetfHealth()
	self.is_btr = self.object:is_btr()
	if self.is_btr then
		self.nextupd_1000 = 0
	end
end

function generic_physics_binder:update(delta)
	object_binder.update(self, delta)

	if self.initialized then
		if self.is_drop_box and not self.drop_box_cb_set then
			self.object:set_callback(callback_death, generic_physics_binder.death_callback, self)
			self.drop_box_cb_set = true
		end
	else
		self.initialized = true
		xr_logic.initialize_obj(self.object, self.st, self.loaded, modules.stype_item)

		local ini = self.st.ini
		local section = self.st.section_logic
		if section and ini:section_exist(section) then
			local function get_field_string(field)
				return ini:line_exist(section, field) and ini:r_string(section, field)
			end

			--' Запускаем ассоциированный с объектом партикл.
			local particle = get_field_string("particle")
			if particle then
				self.particle = particles_object(particle)
				self.particle:play_at_pos(self.object:position())
			end

			--' Дизаблим ассоциированный с объектом граф
			local graph_point_marker = get_field_string("graph_point_marker")
			if graph_point_marker then
				self.disable_graph_point = patrol(graph_point_marker):game_vertex_id(0)
				graph:accessible(self.disable_graph_point, false)
			end
			self.object:set_callback(callback_hit, generic_physics_binder.hit_callback, self)
			self.object:set_callback(callback_death, generic_physics_binder.death_callback, self)
			self.object:set_callback(callback_use_object, generic_physics_binder.use_callback, self)
		end
	end

	if self.st.active_section ~= nil then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "update", delta)

		-- для бтра hit_callback и death_callback не вызывается. заткнём эти дырки.
		if self.health and not self.nofixonhit then
			local health = self.car:GetfHealth()
			local amount = self.health - health
			self.health = health
			if health <= 0 then
				self:death_callback(self.object, Actor)
				self.nofixonhit = nil
			elseif amount > 0.0001 then
				self:hit_callback(self.object, amount, vector():set(1, 0, 0), Actor, 0)
				self.nofixonhit = nil
			end
		end
	end

	if self.is_btr and self.nextupd_1000 <= time_real_ms then
		if self.health > 0.005 and Actor:see(self.object) and
		   self.object:position():distance_to(Actor:position()) < 150 then
			amk.actor_see_enemy(self.object, true)
		end

		self.nextupd_1000 = time_real_ms + 1000
	end
end

function generic_physics_binder:net_spawn(data)
	if not object_binder.net_spawn(self, data) then
		return false
	end

	if self.is_drop_box then
		self.box_items = xr_box.ph_item_box(self.object)

		local h = hit()
		h.draftsman = self.object
		h.type = hit.strike
		h.direction = vector()
		h.power = 0.0001
		h.impulse = 0.0001
		self.object:hit(h)
	end

	-- flying cars fix
	if self.car then
		xr_logic.mob_capture(self.object, true)
		action(self.object, move(move.off, 0), cond(cond.time_end, 10))
	end

	if self.is_btr then
		amk.on_net_spawn(self.object, true)
		news_main.on_btr_seen(self.object)
	else
		sa_callbacks.physic_object_net_spawn(self.object)
	end

	return true
end

function generic_physics_binder:net_destroy()
	local id = self.object:id()
	local st = db.storage[id]
	if st.active_scheme then
		xr_logic.issue_event(self.object, st[st.active_scheme], "net_destroy")
	end

    if self.particle ~= nil then
        self.particle:stop()
    end

	if self.is_btr then
		amk_mod.btrs_friends[id] = nil
	end
	db.storage[id] = nil

	self.object:set_callback(callback_hit, nil)
	self.object:set_callback(callback_death, nil)
	self.object:set_callback(callback_use_object, nil)

	object_binder.net_destroy(self)
end

function generic_physics_binder:net_save_relevant()
	return true
end

function generic_physics_binder:save(packet)
	object_binder.save(self, packet)

	xr_logic.save_obj(self.object, packet)
end

function generic_physics_binder:load(reader)
	self.loaded = true

	object_binder.load(self, reader)

	xr_logic.load_obj(self.object, reader)
end

function generic_physics_binder:use_callback(obj, who)
	if self.st.active_section then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "use_callback", obj, who)
	end

	if self.is_btr then
		local snd = voice("characters_voice\\human_03\\military\\fight\\fire\\fire_" .. math.random(1, 5))
		snd:play_at_pos(obj, obj:position(), sound_object.s3d)
		snd = voice("weapons\\pm\\pm_shoot")
		snd:play_at_pos(obj, obj:position(), sound_object.s3d)
		Actor:kill(obj)
	end
end

function generic_physics_binder:hit_callback(obj, amount, local_direction, who, bone_index)
	if self.health then
		self.nofixonhit = true
	end

	if self.st.ph_on_hit then
		xr_logic.issue_event(self.object, self.st.ph_on_hit, "hit_callback", obj, amount, local_direction, who, bone_index)
	end
	if self.st.active_section then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "hit_callback", obj, amount, local_direction, who, bone_index)
	end

	if not self.car then return end

	local who_id = reap.hit_by_actor(who)
	if who_id ~= -1 then
		xr_logic.pstor_store(self.object, "last_hit", who_id)
	end

	if not self.is_btr then return end

	if amount > 0 and who_id == 0 then
		amk_mod.calc_adrenaline("actor_hit_enemy", obj, true)
	end

	if self.health < 0.2 and not self.in_flames then
		news_main.on_btr_flame(obj)
		self.in_flames = true
	end
end

function generic_physics_binder:death_callback(victim, who)
	if self.health then
		self.nofixonhit = true
	end

	if self.st.active_section then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "death_callback", victim, who)
	end

    if self.particle ~= nil then
        self.particle:stop()
    end

    if self.disable_graph_point ~= nil then
        graph:accessible(self.disable_graph_point, true)
    end

	if self.is_btr then
		amk_mod.btrs_friends[self.object:id()] = nil
		news_main.on_btr_die(victim)
	end
	if self.car then
		local who_id = reap.hit_by_actor(who)
		local hit_id = xr_logic.pstor_retrieve(victim, "last_hit", -1, true)

		if who_id == -1 then
			who_id = hit_id
		end
		if who_id == 0 then
			xr_statistic.addKillCount(self.object)
		end
	end

	if self.is_drop_box then
		self.box_items:spawn_items()
	end
end
