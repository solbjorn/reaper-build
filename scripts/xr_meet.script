----------------------------------------------------------------------------------------------------------------------
--  Схема встречи двух сталкеров
--  автор: Диденко Руслан (Stohe)
--  TODO:
----------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
--Evaluators
----------------------------------------------------------------------------------------------------------------------

local prop_contact = xr_evaluators_id.stohe_meet_base + 1
local prop_wounded = xr_evaluators_id.sidor_wounded_base
local prop_abuse = xr_evaluators_id.abuse_base
local operator_contact = xr_actions_id.stohe_meet_base + 1
local operator_state_mgr_to_idle_alife = xr_actions_id.state_mgr + 2
local xr_actions_id_alife = xr_actions_id.alife
local stalker_ids_property_enemy = stalker_ids.property_enemy
local wp_stalker_ids_property_alive_true = world_property(stalker_ids.property_alive, true)
local wp_stalker_ids_property_danger_false = world_property(stalker_ids.property_danger, false)
local wp_stalker_ids_property_enemy_false = world_property(stalker_ids_property_enemy, false)
local wp_stalker_ids_property_anomaly_false = world_property(stalker_ids.property_anomaly, false)
local wp_prop_contact_true = world_property(prop_contact, true)
local wp_prop_contact_false = world_property(prop_contact, false)
local wp_prop_wounded_false = world_property(prop_wounded, false)
local wp_prop_abuse_false = world_property(prop_abuse, false)

local string_gmatch = string.gmatch
local string_find = string.find
local string_sub = string.sub

--' Возвращает есть ли у нас контакт с другим сталкером
class "evaluator_contact" (property_evaluator)
function evaluator_contact:__init(name, storage) super (nil, name)
  self.a = storage
	self.updcnt = -1
end
function evaluator_contact:evaluate()
  if self.a.meet_set ~= true then return false end

   if xrs_armor.pickupers[self.object:id()]==true then return false end

  if Actor then
    if not Actor:alive() then
      return false
    end
-- Red75 +
    if xr_wounded.is_wounded(self.object) then
      self.begtime=nil
      return false
    end

		local meet_manager = self.a.meet_manager

		self.updcnt = self.updcnt-1
		if self.updcnt < 0 then
			self.updcnt = 5
			meet_manager:update()
		end

    if self.mgr == nil then
      self.mgr = self.object:motivation_action_manager()
    end
    if self.mgr:evaluator(stalker_ids_property_enemy):evaluate() then
      self.object:disable_talk()
      self.begtime=nil
      return false
    end

    -- Чтобы не стояли и не пялились часами
    local tken=(tostring(meet_manager.state)~="nil")
    local istk=self.object:is_talking()
    if self.begtime==nil and tken then
      self.begtime=time_global()
    elseif not tken then
      self.begtime=nil
    elseif tken and self.begtime+10000<time_global() and (not istk) and (not meet_manager.wpn_meet) then
    -- 10 секунд посмотрели на меченного и хватит
      return false
    elseif istk or meet_manager.wpn_meet then
      self.begtime=time_global()
    end

		if not meet_manager:actor_targets_npc(self.object) then
			return false
		end

    return tostring(meet_manager.state)~="nil"
  else
    return false
  end
-- Red75 -
end

----------------------------------------------------------------------------------------------------------------------
--Actions
----------------------------------------------------------------------------------------------------------------------
--' Приглашение к тороговле
class "action_meet_wait" (action_base)
function action_meet_wait:__init (action_name, storage) super (nil, action_name)
	self.a = storage
end
function action_meet_wait:initialize()
  action_base.initialize(self)
  self.object:set_desired_position()
  self.object:set_desired_direction()
  -- кешируемые данные
  self.sound = "nil"

	-- Здороваемся.
	if self.a.init_meet ~= "" then
		xr_sound.set_sound_play(self.object, self.a.init_meet)
	end
end
function action_meet_wait:execute ()
  action_base.execute(self)
  local meet_manager = self.a.meet_manager

  local victim = nil
  if meet_manager.victim == "actor" then
    victim = Actor
  elseif meet_manager.victim == "nil" then
    victim = nil
  else
    victim = story_object(victim)
  end

  local synsound = nil
  if meet_manager.state == "true" then
    local h = hit()
    h.power = 0
    h.direction = self.object:direction()
    h.bone = "bip01_spine"
    h.draftsman = Actor
    h.impulse = 0
    h.type = hit.wound
    self.object:hit(h)
    self.object:set_relation(game_object.enemy, Actor)
  else
    -- является ли текущий звук синхронным для текущего стейта
    for k,v in pairs(self.a.syndata) do
      if v.state == meet_manager.state and
         v.sound == meet_manager.sound
      then
        synsound = meet_manager.sound
      end
    end

    if meet_manager.state~="nil" then
      if meet_manager.emerg_state == true then
        state_mgr.set_state(self.object, meet_manager.state, nil, nil, {look_object = victim}, {animation = true}, synsound)
      else
        state_mgr.set_state(self.object, meet_manager.state, nil, nil, {look_object = victim}, nil, synsound)
      end
    end
  end

  if synsound == nil then
    -- нужно отыграть фоновый
    if self.sound ~= meet_manager.sound then
      self.sound = meet_manager.sound
      if self.sound == "nil" then
        xr_sound.set_sound(self.object, nil)
      else
				local idle_timeout = meet_manager.sound == "wait" and 10000 or 0
				xr_sound.set_sound(self.object, meet_manager.sound, nil, idle_timeout)
      end
    end
  else
    -- нужно зарубить фоновый
    if self.sound ~= nil then
      self.sound = "nil"
      xr_sound.set_sound(self.object, nil)
    end
  end

  local tt = db.storage[self.object:id()]
  if tt.active_scheme then
      xr_logic.try_switch_to_another_section(self.object, tt[tt.active_scheme])
  end
end
function action_meet_wait:finalize ()
  action_base.finalize(self)
  xr_sound.set_sound(self.object, nil)
end

class "Cmeet_manager"
function Cmeet_manager:__init(npc, storage)
  self.npc = npc
  self.a = storage
  self.emerg_state = false
  self.startdialog = nil
end
function Cmeet_manager:update()
	-- стартовый диалог

	local targets = container:get("kill_targets", { })
	local id, v, kill_dialog = self.npc:id()
	for i = 1, #targets do
		v = targets[i]
		if v.id == id then
			kill_dialog = v.dialog
			break
		end
	end

  if kill_dialog then
  -- NPC собрались убивать, поэтому ничего важнее быть не может. Всё остальное потом
    if self.startdialog~=kill_dialog then
      self.npc:set_start_dialog(kill_dialog)
      self.startdialog=kill_dialog
    end
  elseif self.a.meet_dialog ~= nil then
    local tmp = xr_logic.pick_section_from_condlist(self.npc, self.a.meet_dialog)
    if self.startdialog ~= tmp then
      self.startdialog = tmp
      if tmp == nil or tmp == "nil" then
        self.npc:restore_default_start_dialog()
      else
        self.npc:set_start_dialog(tmp)
      end
    end
  elseif (not kill_dialog) then
    self.npc:restore_default_start_dialog()
  end

  self:process_use()
  if self.a.precond == "usability" and not self.npc:is_talking() then
    self.state = "nil"
    self.sound = "nil"
    return
  end
  if self.a.precond == "visibility" and not self.npc:see(Actor) and not self.npc:is_talking() then
    self.state = "nil"
    self.sound = "nil"
    return
  end

  if self.npc:is_talking() then
    self.dist = 0
  else
    self.dist = self.npc:position():distance_to(Actor:position())
  end

  self.victim = self:process_victim()

  self.state_zone,self.sound_zone = self:process_zone()
  if self.state_zone ~= "nil" then
    if self.victim == "nil" then
      self.victim = "actor"
    end
    self.state,self.sound = self.state_zone,self.sound_zone
  else
    self.state,self.sound = self:process_meet()
  end
	-- Если актер говорит, и говорит не с нами, то мы не должны говорить звуков.
	-- Ray Twitty aka Shadows: вместо проверки на разговор ГГ добавим проверку на любое открытое меню
	if level.main_input_receiver() and not self.npc:is_talking() then
		self.sound = "nil"
	end
end
function Cmeet_manager:process_zone()
  if self.a.zone == nil then return "nil","nil" end
  local key
  key = self:get_key_from_zone(self.a.zone)
  if key ~= nil then
    local r1,r2
    if self.a.zone[key].state then
      r1 = xr_logic.pick_section_from_condlist(self.npc, self.a.zone[key].state)
      self.emerg_state = true
    end
    if self.a.zone[key].sound then
      r2 = xr_logic.pick_section_from_condlist(self.npc, self.a.zone[key].sound)
    end
    return tostring(r1), tostring(r2)
  end
  return "nil","nil"
end
function Cmeet_manager:process_meet()
  local key
  local is_talking = self.npc:is_talking()
	local act = Actor:active_item()
	if act and act:is_weapon() and not act:is_binoculars() and
       self.npc:relation(Actor) ~= game_object.friend and self:actor_targets_npc(self.npc)
    then
    key = self:get_key_from_distance(self.a.meet_state_wpn)
    if key ~= nil then
      self.wpn_meet=true
      local r1,r2
      if self.a.meet_state_wpn[key].state then
        r1 = xr_logic.pick_section_from_condlist(self.npc, self.a.meet_state_wpn[key].state)
        self.emerg_state = true
      end
      if is_talking then
        r2 = nil
      else
        if self.a.meet_state_wpn[key].sound then
          r2 = xr_logic.pick_section_from_condlist(self.npc, self.a.meet_state_wpn[key].sound)
        end
      end
      return tostring(r1), tostring(r2)
    end
  else
    self.wpn_meet=false
    key = self:get_key_from_distance(self.a.meet_state)
    if key ~= nil then
      local r1,r2
      if self.a.meet_state[key].state then
        r1 = xr_logic.pick_section_from_condlist(self.npc, self.a.meet_state[key].state)
        self.emerg_state = false
      end
      if is_talking then
        r2 = nil
      else
        if self.a.meet_state[key].sound then
          r2 = xr_logic.pick_section_from_condlist(self.npc, self.a.meet_state[key].sound)
        end
      end
      return tostring(r1), tostring(r2)
    end
  end
  return "nil","nil"
end
function Cmeet_manager:process_victim()
  local key
	local act = Actor:active_item()
	if act and act:is_weapon() then
    key = self:get_key_from_distance(self.a.victim_wpn)
    if key ~= nil then
      return tostring(xr_logic.pick_section_from_condlist(self.npc, self.a.victim_wpn[key].state))
    end
  else
    key = self:get_key_from_distance(self.a.victim)
    if key ~= nil then
      return tostring(xr_logic.pick_section_from_condlist(self.npc, self.a.victim[key].state))
    end
  end
  return "nil"
end

function Cmeet_manager:actor_targets_npc(npc)
  local dangerang=1/npc:position():distance_to(Actor:position())
	local ang=horz_angle(screen.cam_dir,npc:position():sub(screen.cam_pos))
  local tgt=ang>-dangerang and ang<dangerang
  if tgt then
    if self.tgt_time then
      return self.tgt_time<time_global()
    else
      self.tgt_time=time_global()+600
      return false
    end
  else
    self.tgt_time=nil
  end
  return false
end

function Cmeet_manager:get_key_from_distance(t)
  local key
  for k,v in pairs(t) do
    if v.dist >= self.dist then
      key = k
    else
      return key
    end
  end
  return key
end
function Cmeet_manager:get_key_from_zone(t)
  for k,v in pairs(t) do
    if utils.npc_in_zone(Actor, db.zone_by_name[v.zone]) then
      return k
    end
  end
  return nil
end
function Cmeet_manager:process_use()
  local is_talking = self.npc:is_talking()
--  printf("MM1 %s %s", self.npc:name(), tostring(is_talking))
  -- запрещаем юзать спящих
  if xr_sleeper.is_npc_asleep(self.npc) then
    self.npc:disable_talk()
    if is_talking then
      self.npc:stop_talk()
    end
    return
  end

  local t
	local act = Actor:active_item()
	if act and act:is_weapon() and not act:is_binoculars() then
    t = xr_logic.pick_section_from_condlist(self.npc, self.a.use_wpn)
  else
    t = xr_logic.pick_section_from_condlist(self.npc, self.a.use)
  end
  -- проверка по дистанции
  if (is_talking and self.npc:position():distance_to_sqr(Actor:position()) > 9) and
    t ~= "self"
  then
    self.npc:stop_talk()
  end

  if t == "true" then
    self.npc:enable_talk()
  elseif t == "false" then
    self.npc:disable_talk()
    if is_talking then
      self.npc:stop_talk()
    end
  elseif t == "self" then
		-- Eсли npc враг (Р.М.А.).
		self.npc:enable_talk()
    if not is_talking then
      Actor:run_talk_dialog(self.npc)
    end
  end
end

----------------------------------------------------------------------------------------------------------------------
-- binder
----------------------------------------------------------------------------------------------------------------------
function add_to_binder(object, st)
	local manager = object:motivation_action_manager()

	-- Evaluators
	manager:add_evaluator (prop_contact, 		evaluator_contact("meet_contact", st))

  -- Actions
	local action = action_meet_wait("action_process_meet", st)
	action:add_precondition		(wp_stalker_ids_property_alive_true)
	action:add_precondition		(wp_stalker_ids_property_enemy_false)
	action:add_precondition		(wp_stalker_ids_property_danger_false)
	action:add_precondition		(wp_stalker_ids_property_anomaly_false)
	action:add_precondition		(wp_prop_contact_true)
	action:add_precondition		(wp_prop_wounded_false)
	action:add_precondition		(wp_prop_abuse_false)
	action:add_effect (wp_prop_contact_false)
	manager:add_action (operator_contact, action)

	action = manager:action (xr_actions_id_alife)
	action:add_precondition		(wp_prop_contact_false)

	action = manager:action (operator_state_mgr_to_idle_alife)
	action:add_precondition		(wp_prop_contact_false)

  st.meet_manager = Cmeet_manager(object, st)
end

local def_meet = {
	["nil"] = {
		meet_state		= "5|wait@wait",
		meet_state_wpn		= "5|backoff@threat_weap",
		init_meet		= "talk_hello",
		victim			= "5|actor",
		victim_wpn		= "5|actor",
		use			= "true",
		use_wpn			= "false",
		syndata			= "backoff@threat_weap",
		precond			= "visibility",
		abuse			= "true"
	},
	kamp = {
		meet_state		= "2|wait",
		meet_state_wpn		= "",
		init_meet		= "",
		victim			= "2|actor",
		victim_wpn		= "",
		use			= "{=_kamp_talk}true,false",
		use_wpn			= "false",
		syndata			= "",
		precond			= "usability",
		abuse			= "false"
	},
	enemy = {
		meet_state		= "",
		meet_state_wpn		= "",
		init_meet		= "",
		victim			= "",
		victim_wpn		= "",
		use			= "false",
		use_wpn			= "false",
		syndata			= "",
		precond			= "visibility",
		abuse			= "false"
	},
	depends = {
		meet_state		= "",
		meet_state_wpn		= "",
		init_meet		= "",
		victim			= "",
		victim_wpn		= "",
		use			= "true",
		use_wpn			= "false",
		syndata			= "",
		precond			= "visibility",
		abuse			= "true"
	},
	["else"] = {
		meet_state		= "2|wait",
		meet_state_wpn		= "",
		init_meet		= "",
		victim			= "2|actor",
		victim_wpn		= "",
		use			= "true",
		use_wpn			= "false",
		syndata			= "",
		precond			= "visibility",
		abuse			= "true"
	}
}

------------

-- Вызывается на переключении на новую секцию. Производит вычитывание настроек из текущей секции.
function reset_meet(npc, scheme, st, section)
	local ini = st.ini
	local meet_section
	if scheme == nil or scheme == "nil" then
		section = st.section_logic
	end
	meet_section = ini:line_exist(section, "meet") and ini:r_string(section, "meet") or nil

	if meet_section == "default_meet" then
		if scheme == "kamp" then
			init_meet(npc, ini, nil, st.meet, scheme)
		else
			init_meet(npc, ini, nil, st.meet, nil)
		end
	else
		init_meet(npc, ini, meet_section, st.meet, scheme)
	end
end
-- Функция чтения настроек. В нее передается секция, откуда их нужно читать.
function init_meet(npc, ini, section, st, scheme)
	local function get_field_string(field, default)
		return (ini:line_exist(section, field) and ini:r_string(section, field)) or default
	end

	section = tostring(section)
	if section == "nil" then
		st.meet_section = "<nil>"
	else
		if section == st.meet_section then
			return
		end
		st.meet_section = section
	end

  -- Устанавливаем дефолты
	local def
	scheme = tostring(scheme)
	if scheme == "nil" or scheme == "kamp" then
		def = def_meet[scheme]
	else
		local npc_community = npc:character_community()
		if npc_community == "monolith" or
		   npc_community == "killer" or
		   npc_community == "zombied" then
			def = def_meet["enemy"]
		elseif npc_community == "military" or
		       npc_community == "bandit" then
			def = def_meet["depends"]
		else
			def = def_meet["else"]
		end
	end

	if section == "no_meet" then
		st.meet_state		= {}
		st.meet_state_wpn	= {}
		st.init_meet		= ""
		st.victim			= {}
		st.victim_wpn		= {}
		st.use				= xr_logic.parse_condlist("false")
		st.use_wpn			= xr_logic.parse_condlist("false")
		st.meet_dialog		= {}
		st.zone				= {}
		st.syndata			= {}
		st.precond			= "usability"
		st.abuse			= "false"
	elseif section == "nil" or not ini:section_exist(section) then
		-- Загружаем дефолты!
		st.meet_state		= parse_data(def.meet_state)
		st.meet_state_wpn	= parse_data(def.meet_state_wpn)
		st.init_meet		= def.init_meet
		st.victim			= parse_data(def.victim)
		st.victim_wpn		= parse_data(def.victim_wpn)
		st.use				= xr_logic.parse_condlist(def.use)
		st.use_wpn			= xr_logic.parse_condlist(def.use_wpn)
		st.meet_dialog		= {}
		st.zone				= {}
		st.syndata			= parse_syn_data(def.syndata)
		st.precond			= def.precond
		st.abuse			= def.abuse
	else
		st.meet_state		= parse_data(get_field_string("meet_state", def.meet_state))
		st.meet_state_wpn	= parse_data(get_field_string("meet_state_wpn", def.meet_state_wpn))
		st.init_meet		= get_field_string("init_meet", def.init_meet)
		st.victim			= parse_data(get_field_string("victim", def.victim))
		st.victim_wpn		= parse_data(get_field_string("victim_wpn", def.victim_wpn))
		st.use				= xr_logic.parse_condlist(get_field_string("use", def.use))
		st.use_wpn			= xr_logic.parse_condlist(get_field_string("use_wpn", def.use_wpn))
		st.meet_dialog		= xr_logic.parse_condlist(get_field_string("meet_dialog", ""))
		st.zone				= parse_zone_data(get_field_string("zone", ""))
		st.syndata			= parse_syn_data(get_field_string("synpairs", def.syndata))
		st.precond			= get_field_string("precond", def.precond)
		st.abuse			= get_field_string("abuse", def.abuse)
	end

  -- Проверяем включать ли обижание на заюзывание
  if st.abuse == "true" then
    xr_abuse.enable_abuse(npc)
  else
    xr_abuse.disable_abuse(npc)
  end

  -- флажок, что функция хотя бы раз вызывалась
  st.meet_set = true
end

function parse_data(s)
	local t = {}

    if s then
		for name in string_gmatch( s, "(%|*%d+%|[^%|]+)%p*" ) do
			local dat = {	dist = nil,
							state = nil,
							sound = nil}

			local t_pos = string_find( name, "|", 1, true )
			local s_pos = string_find( name, "@", 1, true )

			local dist = string_sub( name, 1, t_pos - 1 )
			local state
			local sound

			if s_pos then
				state	= string_sub( name, t_pos + 1,
											s_pos - 1 )
				sound	= string_sub( name, s_pos + 1)
			else
				state	= string_sub( name, t_pos + 1)
			end

			dat.dist = tonumber(dist)
			if state then
				dat.state = xr_logic.parse_condlist(state)
			end
			if sound then
				dat.sound = xr_logic.parse_condlist(sound)
			end
			t[#t+1] = dat
		end
	end
	return t
end

function parse_zone_data(s)
	local t = {}

    if s then
		for name in string_gmatch( s, "(%|*[^%|]+%|[^%|]+)%p*" ) do
			local dat = {	zone = nil,
							state = nil,
							sound = nil}

			local t_pos = string_find( name, "|", 1, true )
			local s_pos = string_find( name, "@", 1, true )

			local zone = string_sub( name, 1, t_pos - 1 )
			local state
			local sound

			if s_pos then
				state	= string_sub( name, t_pos + 1,
											s_pos - 1 )
				sound	= string_sub( name, s_pos + 1)
			else
				state	= string_sub( name, t_pos + 1)
			end

			dat.zone = zone
			if state then
				dat.state = xr_logic.parse_condlist(state)
			end
			if sound then
				dat.sound = xr_logic.parse_condlist(sound)
			end
			t[#t+1] = dat
		end
	end

    return t
end

function parse_syn_data(s)
	local t = {}
    if s then
		for name in string_gmatch( s, "(%|*[^%|]+%|*)%p*" ) do
			local dat = {	zone = nil,
							state = nil,
							sound = nil}

			local t_pos = string_find( name, "@", 1, true )
			local s_pos = string_find( name, "|", 1, true )

			local state = string_sub( name, 1, t_pos - 1 )
			local sound
			if s_pos then
				sound = string_sub( name, t_pos + 1, s_pos -1)
			else
				sound = string_sub( name, t_pos + 1)
			end

			dat.state = state
			dat.sound = sound
			t[#t+1] = dat
		end
	end

    return t
end

-- ДИАЛОГИ ПОКА НЕ ТРОГАЕМ!!!
--' Считывание доступных диалогов игрока.
function set_actor_dialogs(npc, ini, name, dialog_section)
	local function get_field_string(field)
		return (ini:line_exist(dialog_section, field) and ini:r_string(dialog_section, field)) or nil
	end
	if dialog_section == nil then return end

	local actor_dialogs_string = get_field_string("id")
	if actor_dialogs_string ~= nil then
		--' Создаем в массиве запись где будут храниться считанные диалоги.
		db.storage[npc:id()].actor_dialogs = string.parse_names(actor_dialogs_string)
	end

	local actor_disable = get_field_string("disable")
	if actor_disable ~= nil then
		--' Создаем в массиве запись где будут храниться считанные диалоги.
		db.storage[npc:id()].actor_disable = string.parse_names(actor_disable)
	end
end

function disable_scheme(npc, scheme)
	local st = db.storage[npc:id()]
	st.actor_dialogs = nil
	st.actor_disable = nil
end

--- Находится ли чувак в данный момент в состоянии мита
function is_meet(npc)
	local manager = npc:motivation_action_manager()
	if manager and manager:initialized() then
		if manager:current_action_id() == operator_contact then
			return true
		end
	end
	return false
end

-- Функция проверяет не мешает ли персонажу говорить с нами оружие
function cannot_talk_by_weapon(npc)
	local st = db.storage[npc:id()].meet
	if st then
		local act = Actor:active_item()
		if not act or not act:is_weapon() then return false end

    if st.use then
      local t = xr_logic.pick_section_from_condlist(npc, st.use)
      if t == "false" then
        return false
      end
    end
    if st.use_wpn then
      local t = xr_logic.pick_section_from_condlist(npc, st.use_wpn)
      if t == "false" then
        return true
      end
    end
  end
  return false
end

-- Возвращает угол между проекциями векторов vec1 и vec2 на горизонтальную плоскость
-- положительный угол - доворот vec1 до vec2 по часовой.
function horz_angle(vec1,vec2)
  local x=vec2.x*vec1.x+vec2.z*vec1.z
  local y=-vec2.z*vec1.x+vec2.x*vec1.z -- повернули систему координат
  return math.atan2(y,x) -- угол доворота от -pi до pi
end
