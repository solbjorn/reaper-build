--------------------------------------------------------------------------
-- States
--------------------------------------------------------------------------
local state_wait  = 0
local state_wave1 = 1
local state_wave2 = 2
local state_wave3 = 3
local state_wave4 = 4
local state_wave5 = 5
local state_wave6 = 6
local state_wave7 = 7
local state_wave8 = 8

--------------------------------------------------------------------------
-- Locals
--------------------------------------------------------------------------
local function obj_has_item(npc_info, item_name, def_val)
    local se_obj = npc_info.se_obj
    local t = true

    if def_val then
        t = def_val
    end

    if se_obj.online then
        local obj = level.object_by_id(se_obj.id)
        if obj then
            t = obj:object(item_name) ~= nil
        end
    end

    return t
end


--------------------------------------------------------------------------
-- General
--------------------------------------------------------------------------
local gulags = {pri_followers       = {comm = {"stalker"}},
                pri_wave            = {comm = true},
                pri_ambush7         = {comm = {"monolith"}},
                pri_corner          = {comm = {"monolith"}},
                pri_depot           = {comm = {"psy_dog", "pseudodog", "controller"}},
                pri_monolith        = {comm = {"monolith"}},
                pri_stadium         = {comm = {"monolith"}}}

-- Job -------------------------------------------------------------------
function load_job(sj, gname, type, squad, groups)
    local g = gulags[type]
    if g then
        g.job(sj, gname, type, squad, groups)
    end
end

-- State -----------------------------------------------------------------
function check_state_stub(gulag)
    return 0
end

function load_states(gname, type)
    local g = gulags[type]

    if g then
        return g.state or check_state_stub
    end

    return nil
end
        
-- Dynamic ltx -----------------------------------------------------------
function load_ltx(gname, type)
    local g = gulags[type]
    if g then
        return g.ltx
    end

    return nil
end

-- Check communities -----------------------------------------------------
local function checkCommon(npc_community, gulag_type, npc_rank, se_obj, stalker)
    local g = gulags[gulag_type]
    if g then
        if g.comm then
            if type(g.comm) == "function" then
                return g.comm(npc_community, gulag_type, npc_rank, se_obj, stalker)
            end
            if type(g.comm) == "boolean" then
                return g.comm == stalker
            end

            for i, v in pairs(g.comm) do
                if npc_community == v then
                    return true
                end
            end
            return false
        end
        return false
    end
    return false
end

function checkStalker(npc_community, gulag_type, npc_rank, se_obj)
    return checkCommon(npc_community, gulag_type, npc_rank, se_obj, true)
end

function checkMonster(npc_community, gulag_type, npc_rank, se_obj)
    return checkCommon(npc_community, gulag_type, npc_rank, se_obj, false)
end

--------------------------------------------------------------------------
-- Gulags
--------------------------------------------------------------------------

--------------------------------------------------------------------------
-- Followers (группа сталеров идущая с нами с начала уровня)
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function f_predicate(npc_info)
    return npc_info.profile_name == "pri_followers"
end

-- Jobs ------------------------------------------------------------------
gulags.pri_followers.job = function(sj, gname, type, squad, groups)
	local table_concat = table.concat
	local t
	local ltx = "#include \"misc\\gulag_pripyat.ltx\"\n"

	local followers = {"leader", "bomber", "nap1", "nap2", "nap3"}

	local states_str = {"wait", "wave1", "wave2", "wave3", "wave4", "wave5", "wave6", "wave7", "wave8"}

	local states = {state_wait, state_wave1, state_wave2, state_wave3, state_wave4, state_wave5, state_wave6, state_wave7, state_wave8}

	local restr = {"",                              "pri_followers_wave1_out_restr", "pri_followers_wave2_out_restr",
				   "pri_followers_wave3_out_restr", "pri_followers_wave4_out_restr", "pri_followers_wave5_out_restr",
				   "pri_followers_wave6_out_restr", "pri_followers_wave7_out_restr", "pri_followers_wave7_out_restr"}

	local prior = {{2, 2, 2, 2, 2, 2, 2, 2, 3}, -- leader
					{3, 3, 3, 3, 3, 3, 3, 3, 2}, -- bomber
					{1, 1, 1, 1, 1, 1, 1, 1, 1}, -- nap1
					{1, 1, 1, 1, 1, 1, 1, 1, 1}, -- nap2
					{1, 1, 1, 1, 1, 1, 1, 1, 1}  -- nap3
				}

	local pr, pd
	for i, v in pairs(followers) do
		pr = prior[i]
		for j = 1, 9 do
			t = { section = table_concat({"logic@pri_followers_", v, "_", states_str[j]}),
				idle = 0,
				prior = pr[j], state = { states[j] },
				squad = squad, group = groups[1],
				in_rest = "", out_rest = restr[j],
				position_threshold = 100,
				online = true,
				idle_after_death = 50,
				predicate = f_predicate --pd
			}
			sj[#sj+1] = t
		end
	end

	local res_t
	for i = 1, 3 do
		-- задаем стандартные этапы
		for j, v in pairs({1, 2, 4, 5, 6}) do
			--- NAP: WAVE<j> --------------------------------------------------------------------------------
			res_t = {
				"[logic@pri_followers_nap",i,"_wave",
				v,"]\nactive = walker@pri_followers_nap",i,"_wave",
				v,"_wait\non_hit = followers_hit\non_death = followers_death\n",

				"[walker@pri_followers_nap",i,"_wave",
				v,"_wait]\npath_walk = wave",v,"_stalker",
				i,"_syn_walk\npath_look = wave",v,"_stalker",
				i,"_syn_look\ndef_state_moving1 = assault\ndef_state_moving2 = assault\nteam = followers\non_signal = syn | walker@pri_followers_nap",i,"_wave",
				v,"\non_info = {+pri_wave",v,"_start} walker@pri_followers_nap",i,"_wave",
				v,"\ndanger = danger@ignore\nwounded = wounded@ignore\nsoundgroup = pri_followers_soundgroup\nmeet = no_meet\n",

				"[walker@pri_followers_nap",i,"_wave",
				v,"]\npath_walk = wave",v,"_stalker",
				i,"_walk\npath_look = wave",v,"_stalker",
				i,"_look\ndef_state_moving1 = assault\ndef_state_moving2 = assault\non_signal = arrived | {-pri_wave",v,"_start} %+pri_wave",
				v,"_start%\nwounded = wounded@ignore\nsoundgroup = pri_followers_soundgroup\nmeet = no_meet\n" } --meet@def
			ltx = ltx .. table_concat(res_t)
		end
        
		-- нестандартные этапы
		--- NAP: KAMP ----------------------------------------------------------------------------------
		res_t = {
			"[logic@pri_followers_nap",
			i,"_wait]\nactive = remark@pri_followers_nap",
			i,"_wait\non_hit = followers_hit\non_death = followers_death\n",

			"[remark@pri_followers_nap",
			i,"_wait]\npath_walk = wait_stalker",
			i,"_walk\nanim = guard\ntarget = logic@pri_followers_leader_wait\nmeet = no_meet\ndanger = danger@ignore\non_info = {+pri_followers_leader_phrase1_end} remark@pri_followers_nap",
			i,"_wait_na\n",

			"[remark@pri_followers_nap",
			i,"_wait_na]\npath_walk = wait_stalker",
			i,"_walk\nanim = guard_na\ntarget = logic@pri_followers_leader_wait\nmeet = no_meet\ndanger = danger@ignore\n",

			--- NAP: WAVE3 (БТР) --------------------------------------------------------------------------
			"[logic@pri_followers_nap",
			i,"_wave3]\nactive = walker@pri_followers_nap",
			i,"_wave3_wait\ncombat_ignore = combat_ignore\non_hit = followers_hit\non_death = followers_death\n",

			"[walker@pri_followers_nap",
			i,"_wave3_wait]\npath_walk = wave3_stalker",
			i,"_syn_walk\npath_look = wave3_stalker",
			i,"_syn_look\ndef_state_moving1 = assault\ndef_state_moving2 = assault\nteam = followers\non_signal = syn | walker@pri_followers_nap",
			i,"_wave3 %+pri_wave3_start%\non_info = {+pri_wave3_start} walker@pri_followers_nap",
			i,"_wave3\nwounded = wounded@ignore\nmeet = no_meet\nsoundgroup = pri_followers_soundgroup\ndanger = danger@ignore\ncombat_ignore_cond = {!fighting_actor}\n",

			"[walker@pri_followers_nap",
			i,"_wave3]\npath_walk = wave3_stalker",
			i,"_walk\npath_look = wave3_stalker",
			i,"_look\ndef_state_moving1 = assault\ndef_state_moving2 = assault\non_timer = ", 
			math.random(30, 40), "00 | remark@pri_followers_nap",
			i,"_wave3_fight\nwounded = wounded@ignore\nmeet = no_meet\nsoundgroup = pri_followers_soundgroup\ndanger = danger@ignore\ncombat_ignore_cond = {!fighting_actor}\n",

			"[remark@pri_followers_nap",
			i,"_wave3_fight]\nanim = threat_fire\ntarget = 807\non_timer = ", 
			math.random(47, 55), "00 | walker@pri_followers_nap",
			i,"_wave3\nwounded = wounded@ignore\nmeet = no_meet\ndanger = danger@ignore\ncombat_ignore_cond = {!fighting_actor}\n",

			--- NAP: WAVE7 (перед подземкой) ---------------------------------------------------------------
			"[logic@pri_followers_nap",
			i,"_wave7]\nactive = walker@pri_followers_nap",
			i,"_wave7_wait\non_hit = followers_hit\non_death = followers_death\n",

			"[walker@pri_followers_nap",
			i,"_wave7_wait]\npath_walk = wave7_stalker",
			i,"_syn_walk\npath_look = wave7_stalker",
			i,"_syn_look\ndef_state_moving1 = assault\ndef_state_moving2 = assault\nteam = followers\non_info = {+pri_wave7_leader_phrase_end} walker@pri_followers_nap",
			i,"_wave7\nwounded = wounded@ignore\nmeet = no_meet\nsoundgroup = pri_followers_soundgroup\ndanger = danger@ignore\n",

			"[walker@pri_followers_nap",
			i,"_wave7]\npath_walk = wave7_stalker",
			i,"_walk\npath_look = wave7_stalker",
			i,"_look\ndef_state_moving1 = assault\ndef_state_moving2 = assault\non_signal = arrived | {-pri_wave7_start} %+pri_wave7_start%\non_info = {-pri_wave7_sound_start =pri_follower_see_ambush} %+pri_wave7_sound_start%\nwounded = wounded@ignore\nmeet = no_meet\nsoundgroup = pri_followers_soundgroup\ndanger = danger@ignore\n",

			--- NAP: WAVE8 ------------------------------------------------------------------------------
			"[logic@pri_followers_nap",
			i,"_wave8]\nactive = walker@pri_followers_nap",
			i,"_wave8_wait\non_hit = followers_hit\non_death = followers_death\n",

			"[walker@pri_followers_nap",
			i,"_wave8_wait]\npath_walk = wave8_stalker",
			i,"_walk\npath_look = wave8_stalker",
			i,"_look\ndef_state_moving1 = assault\ndef_state_moving2 = assault\nwounded = wounded@ignore\nsoundgroup = pri_followers_soundgroup\nmeet = no_meet\n" } --meet@def
		ltx = ltx .. table_concat(res_t)
	end

	gulags.pri_followers.ltx = ltx
end

-- States ----------------------------------------------------------------
local pri_followers_switcher = {}
pri_followers_switcher[state_wait] = function(actor, delta_time)
    if has_alife_info("pri_followers_start") then
        return state_wave1
    end
    return state_wait
end
pri_followers_switcher[state_wave1] = function(actor, delta_time)
    if delta_time > 600 or -- 1 min
        (has_alife_info("pri_wave1_monolith1_dead") and
        has_alife_info("pri_wave1_monolith2_dead") and
        has_alife_info("pri_wave1_monolith3_dead"))
    then
        actor:give_info_portion("pri_wave1_end")
        return state_wave2
    end
    return state_wave1
end
pri_followers_switcher[state_wave2] = function(actor, delta_time)
    if delta_time > 600 or -- 1 min
        (has_alife_info("pri_wave2_monolith1_dead") and
        has_alife_info("pri_wave2_monolith2_dead") and
        has_alife_info("pri_wave2_monolith3_dead") and
        has_alife_info("pri_wave2_monolith4_dead"))
    then
        actor:give_info_portion("pri_wave2_end")
        actor:give_info_portion("pri_wave3_end")
        return state_wave4 --3
    end
    return state_wave2
end
pri_followers_switcher[state_wave3] = function(actor, delta_time)
    if has_alife_info("pri_wave3_btr_dead") then
        actor:give_info_portion("pri_wave3_end")
        return state_wave4
    end
    return state_wave3
end
pri_followers_switcher[state_wave4] = function(actor, delta_time)
    if delta_time > 600 or -- 3 min
        (has_alife_info("pri_wave4_monolith1_dead") and
        has_alife_info("pri_wave4_monolith2_dead") and
        has_alife_info("pri_wave4_monolith3_dead") and
        has_alife_info("pri_wave4_monolith4_dead") and
        has_alife_info("pri_wave4_monolith5_dead"))
    then
        actor:give_info_portion("pri_wave4_end")
        return state_wave5
    end
    return state_wave4
end
pri_followers_switcher[state_wave5] = function(actor, delta_time)
    if has_alife_info("pri_wave5_monolith1_dead") and
        has_alife_info("pri_wave5_monolith2_dead") and
        has_alife_info("pri_wave5_monolith3_dead") and
        has_alife_info("pri_wave5_monolith4_dead")
    then
        actor:give_info_portion("pri_wave5_end")
        return state_wave6
    end
    return state_wave5
end
pri_followers_switcher[state_wave6] = function(actor, delta_time)
    if has_alife_info("pri_wave6_monolith1_dead") and
        has_alife_info("pri_wave6_monolith2_dead")
    then
        actor:give_info_portion("pri_wave6_end")
        return state_wave7
    end
    return state_wave6
end
pri_followers_switcher[state_wave7] = function(actor, delta_time)
    if xr_gulag.getGulagPopulation("pri_wave7") < 2
    then
        actor:give_info_portion("pri_undeground_respawn_start")
        actor:give_info_portion("pri_wave7_end")
		actor:give_info_portion("pri_aes_mapspot")
        return state_wave8
    end
    return state_wave7
end
pri_followers_switcher[state_wave8] = function(actor, delta_time)
    return state_wave8
end

gulags.pri_followers.state = function(gulag)
    local state = gulag.state
    local actor = db_actor

    -- проверка не убежал ли актер далеко
    if has_alife_info("pri_followers_mission_accept") and not has_alife_info("pri_followers_actor_leave") then
        -- check min distance to actor
        local actor_leave = true
        local npc_id, npc = 0, 0
        -- проверка дистанции до каждого члена гулага
	    for npc_id, npc in pairs(gulag.Object) do
		    if npc ~= true and level.object_by_id(npc_id) ~= nil then
			    if npc:position():distance_to_sqr(actor:position()) <= 3600 then -- 60*60
			        actor_leave = false
			        break
			    end
		    end
	    end
		if actor_leave and actor:alive() then
			actor:give_info_portion("pri_followers_actor_leave")
		end
	end

    -- переключение состояния гулага через массив функций состояний
    return pri_followers_switcher[state](actor, game.get_game_time():diffSec(gulag.stateBegin))
end


--------------------------------------------------------------------------
-- Ambush7 (не используется)
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------

-- Jobs ------------------------------------------------------------------
gulags.pri_ambush7.job = function(sj, gname, type, squad, groups)
	local table_concat = table.concat
	local t
	local ltx = ""
	local res_t
	for i = 1, 7 do
		t = { section = table_concat({"logic@pri_ambush7_monolith",i,"_hide"}), 
			idle = 0,
			prior = 1, state = {0}, squad = squad, group = groups[1],
			in_rest = "", out_rest = "pri_ambush7_out_restr"
		}
		sj[#sj+1] = t
		t = { section = table_concat({"logic@pri_ambush7_monolith",i}),
			idle = 0,
			prior = 1, state = {1}, squad = squad, group = groups[1],
			in_rest = "", out_rest = "pri_ambush7_out_restr"
		}
		sj[#sj+1] = t

		res_t = {
			"[logic@pri_ambush7_monolith",
			i,"_hide]\nactive = walker@pri_ambush7_monolith",
			i,"_hide\ncombat_ignore = combat_ignore\n",

			"[walker@pri_ambush7_monolith",
			i,"_hide]\npath_walk = monolith",
			i,"_hide_walk\npath_look = monolith",
			i,"_hide_look\ncombat_ignore_cond  = always\nshow_spot = false\n",

			"[logic@pri_ambush7_monolith",
			i,"]\nactive = walker@pri_ambush7_monolith",
			i,"\n",

			"[walker@pri_ambush7_monolith",
			i,"]\npath_walk = monolith",
			i,"_walk\npath_look = monolith",
			i,"_look\n" } --,
		ltx = ltx .. table_concat(res_t)
	end

	gulags.pri_ambush7.ltx = ltx
end

-- States ----------------------------------------------------------------
gulags.pri_ambush7.state = function(gulag)
    if has_alife_info("pri_wave7_start") then
        return 1
    else
        return 0
    end
end


--------------------------------------------------------------------------
-- Wave (засады в первой половине Припяти: на крышах, в окнах, на земле)
--------------------------------------------------------------------------
-- Additional functions --------------------------------------------------
local function process_range(str, def_val_min, def_val_max)
    local v = {}
    if str then v = parse_nums(str) end
    local min = v[1] or def_val_min or 5
    local max = v[2] or def_val_max or 10
    
    if min > max then
        max = min --* 1.5
    end
    return math.random(min, max) --random_number(min, max)
end

local function process_num(str, def_val)
    if str ~= nil then
        return tonumber(str) or def_val
    end
    return def_val
end

-- Jobs ------------------------------------------------------------------
gulags.pri_wave.job = function(sj, gname, type, squad, groups)
	local t
    local i, ltx = 1, ""
    local ib_cond = "combat_ignore_cond = {=check_fighting(806)}\n"

    ltx = "[wounded]\n" ..
          "hp_state = 0|help_me@help\n" ..
          "hp_state_see = 0|wounded@help_see\n" ..
          "hp_victim = 0|nil\n" ..
          "hp_fight = 0|false\n" ..
          "hp_cover = 0|false\n" ..

          "[danger@ignore]\n" ..
          "ignore_types = corpse,sound\n" ..
          "ignore_distance = 0\n" ..

          "[danger@normal]\n" ..
          "ignore_types = corpse, sound\n" ..
          "ignore_distance = 0\n" ..
  
          "[danger@kamp]\n" ..
          "ignore_types = corpse\n" ..
          "ignore_distance = 0\n"  
    -- Снайперы в окнах.
    i = 1
    while level.patrol_path_exists(gname .. "_wsniper_" .. i .."_walk") do
        -- Необходимо вычитать количество работ из названия точки пути.
        local idstr = gname .. "_wsniper_" .. i
        local way_name = idstr .. "_walk"
        local ptr = patrol(way_name)
        local wp_prop = utils.parse_waypoint_data(way_name, ptr:flags(0), ptr:name(0))

        local stime = process_range(wp_prop.stime, 10000, 15000) -- sniper time
        local gtime = process_range(wp_prop.gtime, 15000, 20000) -- guard time
        local htime = process_range(wp_prop.htime,  6000,  8000) -- hide time

        local sdist = process_num(wp_prop.sdist, 50) -- sniper distance
        local gdist = process_num(wp_prop.gdist, 40) -- guard distance
        if gdist >= sdist then
            gdist = sdist + 5
        end

        local outr = wp_prop.outr or "" -- out restrictors
        local inr = wp_prop.inr or "" -- in restrictors

        local starti = wp_prop.starti -- start infoportion
        local deathi = wp_prop.deathi -- death infoportion

        -- добавляем должность
        t = { section = "logic@" .. idstr,
            idle = 0,
            prior = 1, state = {0}, squad = squad, group = groups[1],
            in_rest = inr, out_rest = outr
        }
        sj[#sj+1] = t

        -- добавляем описание должности в лтх.
        ltx = ltx.."[logic@" .. idstr .. "]\n" ..
                   "combat_ignore = combat_ignore\n"
        
        if starti then
            ltx = ltx.."active = camper@" .. idstr .. "_wait\n"

            if deathi then
                ltx = ltx.."on_death = death@" .. idstr .. "\n" ..

                           "[death@" .. idstr .. "]\n" ..                            
                           "on_info = %+" .. deathi .. "%\n"
            end

            ltx = ltx.."[camper@" .. idstr .. "_wait]\n" ..                            
                       "path_walk           = wsniper_" .. i .. "_wait_walk\n" ..
                       "path_look           = wsniper_" .. i .. "_wait_look\n" ..
                       "radius              = 4\n" ..
                       "no_retreat          = true\n" ..
                       "attack_sound        = false\n" ..
                       "show_spot           = false\n" ..
                       "on_info             = {+" .. starti .. "} camper@" .. idstr .. "\n" ..
                       "wounded             = wounded\n" ..
                       "danger              = danger@ignore\n" ..
                       "combat_ignore_cond  = always\n"
        else
            ltx = ltx.."active = camper@" .. idstr .. "\n"
        end

        ltx = ltx.."[camper@" .. idstr .. "]\n" ..                            
                   "path_walk                   = wsniper_" .. i .. "_walk\n" ..
                   "path_look                   = wsniper_" .. i .. "_look\n" ..
                   "def_state_moving            = sneak_run ;assault\n" ..
                   "def_state_campering         = threat\n" ..
                   "def_state_campering_fire    = threat_sniper_fire\n" ..
                   "sniper                      = true\n" ..
                   "radius                      = 0\n" ..
                   --"on_info                     = {=dist_to_enemy_le(" .. gdist .. ")} camper@" .. idstr .. "_guard\n" ..
                   --"on_actor_dist_le_nvis       = " .. gdist .. " | remark@" .. idstr .. "_hide\n" .. --camper@" .. idstr .. "_guard\n" ..
                   --"on_timer                    = " .. stime .. " | {=see_enemy} camper@" .. idstr .. "_hide, camper@" .. idstr .. "_guard\n" ..
                   "on_timer                    = " .. stime .. " | {!has_enemy} camper@" .. idstr .. "_guard, camper@" .. idstr .. "_hide\n" ..
                   "wounded                     = wounded\n" ..
                   "danger                      = danger@ignore\n" ..

                   "[camper@" .. idstr .. "_guard]\n" ..                            
                   "path_walk                   = wsniper_" .. i .. "_walk\n" ..
                   "path_look                   = wsniper_" .. i .. "_look\n" ..
                   "def_state_moving            = sneak_run ;assault\n" ..
                   "def_state_campering         = threat\n" ..
                   "def_state_campering_fire    = threat_fire\n" ..
                   "no_retreat                  = true\n" ..
                   "radius                      = 0\n" ..
                   --"on_info                     = {!dist_to_enemy_le(" .. sdist .. ")} camper@" .. idstr .. "\n" ..
                   --"on_actor_dist_ge_nvis       = " .. sdist .. " | remark@" .. idstr .. "_hide\n" .. --camper@" .. idstr .. "\n" ..
                   --"on_timer                    = " .. gtime .. " | {=has_enemy} camper@" .. idstr .. "_hide, camper@" .. idstr .. "\n" ..
                   "on_timer                    = " .. gtime .. " | {!has_enemy} camper@" .. idstr .. ", {!see_enemy} camper@" .. idstr .. "\n" ..
                   "on_info                     = {=has_enemy !see_enemy} camper@" .. idstr .. "\n" ..
                   "wounded                     = wounded\n" ..
                   "danger                      = danger@ignore\n" ..

                   "[camper@" .. idstr .. "_hide]\n" ..                            
                   "path_walk           = wsniper_" .. i .. "_walk\n" ..
                   "path_look           = wsniper_" .. i .. "_look\n" ..
                   "def_state_moving    = sneak_run\n" ..
                   "def_state_campering = hide_na\n" ..
                   "no_retreat          = true\n" ..
                   "radius              = 0\n" ..
                   "show_spot           = false\n" ..
                   --"on_timer            = " .. htime .. " | {=dist_to_actor_ge(" .. sdist .. ")} camper@" .. idstr .. ", camper@" .. idstr .. "_guard\n" ..
                   "on_timer            = " .. htime .. " | camper@" .. idstr .. "_guard\n" .. -- {=has_enemy} camper@" .. idstr .. ", 
                   "wounded             = wounded\n" ..
                   "danger              = danger@ignore\n" --..
                   --"combat_ignore_cond  = always\n"
        i = i + 1
    end

    -- Снайперы на крышах.
    i = 1
    while level.patrol_path_exists(gname .. "_rsniper_" .. i .."_walk") do
        -- Необходимо вычитать количество работ из названия точки пути.
        local idstr = gname .. "_rsniper_" .. i
        local way_name = idstr .. "_walk"
        local ptr = patrol(way_name)
        local wp_prop = utils.parse_waypoint_data(way_name, ptr:flags(0), ptr:name(0))

        local sdist = process_num(wp_prop.sdist, 50) -- sniper distance
        local gdist = process_num(wp_prop.gdist, 40) -- guard distance
        if gdist >= sdist then
            gdist = sdist + 5
        end

        local outr = wp_prop.outr or "" -- out restrictors
        local inr = wp_prop.inr or "" -- in restrictors

        local starti = wp_prop.starti -- start infoportion
        local deathi = wp_prop.deathi -- death infoportion

        -- добавляем должность
        t = { section = "logic@" .. idstr,
            idle = 0,
            prior = 1, state = {0}, squad = squad, group = groups[2],
            in_rest = inr, out_rest = outr
        }
        sj[#sj+1] = t

        -- добавляем описание должности в лтх.
        ltx = ltx.."[logic@" .. idstr .. "]\n" ..
                   "combat_ignore = combat_ignore\n"
        
        if starti then
            ltx = ltx.."active = camper@" .. idstr .. "_wait\n"

            if deathi then
                ltx = ltx.."on_death = death@" .. idstr .. "\n" ..

                           "[death@" .. idstr .. "]\n" ..                            
                           "on_info = %+" .. deathi .. "%\n"
            end

            ltx = ltx.."[camper@" .. idstr .. "_wait]\n" ..                            
                       "path_walk           = rsniper_" .. i .. "_wait_walk\n" ..
                       "path_look           = rsniper_" .. i .. "_wait_look\n" ..
                       "radius              = 4\n" ..
                       "no_retreat          = true\n" ..
                       "attack_sound        = false\n" ..
                       "show_spot           = false\n" ..
                       "on_info             = {+" .. starti .. "} camper@" .. idstr .. "\n" ..
                       "wounded             = wounded\n" ..
                       "danger              = danger@ignore\n" ..
                       "combat_ignore_cond  = always\n"
        else
            ltx = ltx.."active = camper@" .. idstr .. "\n"
        end

        ltx = ltx.."[camper@" .. idstr .. "]\n" ..                            
                   "path_walk                   = rsniper_" .. i .. "_walk\n" ..
                   "path_look                   = rsniper_" .. i .. "_look\n" ..
                   "def_state_moving            = assault\n" ..
                   "def_state_campering         = hide_na\n" ..
                   "def_state_campering_fire    = hide_sniper_fire\n" ..
                   "sniper                      = true\n" ..
                   "radius                      = 0\n" ..
                   --"on_info                     = {=dist_to_enemy_le(" .. gdist .. ")} camper@" .. idstr .. "_guard\n" ..
                   "on_actor_dist_le_nvis       = " .. gdist .. " | camper@" .. idstr .. "_guard\n" ..
                   "wounded                     = wounded\n" ..
                   "danger                      = danger@normal\n" ..

                   "[camper@" .. idstr .. "_guard]\n" ..                            
                   "path_walk                   = rsniper_" .. i .. "_walk\n" ..
                   "path_look                   = rsniper_" .. i .. "_look\n" ..
                   "def_state_moving            = assault\n" ..
                   "def_state_campering         = hide_na\n" ..
                   "def_state_campering_fire    = hide_fire\n" ..
                   "no_retreat                  = true\n" ..
                   "radius                      = 0\n" ..
                   --"on_info                     = {!dist_to_enemy_le(" .. sdist .. ")} camper@" .. idstr .. "\n" ..
                   "on_actor_dist_ge_nvis       = " .. sdist .. " | {!has_enemy} camper@" .. idstr .. ", {!see_enemy} camper@" .. idstr .. "\n" ..
                   "on_info                     = {=has_enemy !see_enemy} camper@" .. idstr .. "\n" ..
                   "wounded                     = wounded\n" ..
                   "danger                      = danger@normal\n"
        i = i + 1
    end

    -- Свободные волкеры в кемпах.
    i = 1
    while level.patrol_path_exists(gname .. "_free_" .. i .."_walk") do
        -- Необходимо вычитать количество работ из названия точки пути.
        local idstr = gname .. "_free_" .. i
        local way_name = idstr .. "_walk"
        local ptr = patrol(way_name)
        local wp_prop = utils.parse_waypoint_data(way_name, ptr:flags(0), ptr:name(0))

        local wtime = process_range(wp_prop.wtime, 40000,  80000) -- walker state time
        local ktime = process_range(wp_prop.ktime, 90000, 180000) -- kamp state time

        local kampi = process_num(wp_prop.kampi, 1) -- kamp index

        local outr = wp_prop.outr or "" -- out restrictors
        local inr = wp_prop.inr or "" -- in restrictors

        local starti = wp_prop.starti -- start infoportion
        local deathi = wp_prop.deathi -- death infoportion

        -- добавляем должность
        t = { section = "logic@" .. idstr,
            idle = 0,
            prior = 1, state = {0}, squad = squad, group = groups[2 + kampi],
            in_rest = inr, out_rest = outr
        }
        sj[#sj+1] = t

        -- добавляем описание должности в лтх.
        ltx = ltx.."[logic@" .. idstr .. "]\n" ..
                   "combat_ignore = combat_ignore\n"
        
        if starti then
            ltx = ltx.."active = camper@" .. idstr .. "_wait\n"

            if deathi then
                ltx = ltx.."on_death = death@" .. idstr .. "\n" ..

                           "[death@" .. idstr .. "]\n" ..                            
                           "on_info = %+" .. deathi .. "%\n"
            end

            ltx = ltx.."[camper@" .. idstr .. "_wait]\n" ..                            
                       "path_walk           = free_" .. i .. "_wait_walk\n" ..
                       "path_look           = free_" .. i .. "_wait_look\n" ..
                       "radius              = 4\n" ..
                       "no_retreat          = true\n" ..
                       "attack_sound        = false\n" ..
                       "show_spot           = false\n" ..
                       "on_info             = {+" .. starti .. "} walker@" .. idstr .. "\n" ..
                       "wounded             = wounded\n" ..
                       "danger              = danger@ignore\n" ..
                       "combat_ignore_cond  = always\n"
        else
            ltx = ltx.."active = walker@" .. idstr .. "\n"
        end

        ltx = ltx.."[walker@" .. idstr .. "]\n" ..                            
                   "path_walk                   = free_" .. i .. "_walk\n" ..
                   "path_look                   = free_" .. i .. "_look\n" ..
                   "def_state_moving1           = patrol\n" ..
                   "def_state_moving2           = assault\n" ..
                   "def_state_moving3           = assault\n" ..
                   "on_timer                    = " .. wtime .. " | kamp@" .. idstr .. "\n" ..
                   "wounded                     = wounded\n" ..
                   --"danger                      = danger@kamp\n" ..

                   "[kamp@" .. idstr .. "]\n" ..                            
                   "center_point        = kamp_" .. kampi .. "\n" ..
                   "def_state_moving    = patrol\n" ..
                   "on_timer            = " .. ktime .. " | walker@" .. idstr .. "\n" ..
                   "wounded             = wounded\n" ..
                   "danger              = danger@kamp\n"
        i = i + 1
    end

    gulags.pri_wave.ltx = ltx
end


--------------------------------------------------------------------------
-- Corners (сталкеры атакующие когда мы заходим в подземный переход)
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------

-- Jobs ------------------------------------------------------------------
gulags.pri_corner.job = function(sj, gname, type, squad, groups)
	local t
	local ltx = ""
	local res_t
	local table_concat = table.concat

	for i = 1, 3 do
		t = { section = table_concat({"logic@pri_corner_monolith", i }),
			idle = 0,
			prior = 1, state = {0}, squad = squad, group = groups[1],
			in_rest = "", out_rest = ""
		}
		sj[#sj+1] = t
		res_t = {
			"[logic@pri_corner_monolith", 
			i, "]\nactive = camper@pri_corner_monolith", 
			i, "_guard\ncombat_ignore = combat_ignore\n",

			"[camper@pri_corner_monolith", 
			i, "_guard]\npath_walk = guard_", 
			i, "_walk\npath_look = guard_", 
			i, "_look\nradius = 20\non_info = {+pri_corner_start} patrol@pri_corner_monolith_raid\ncombat_ignore_cond = always\n" }
		ltx = ltx .. table_concat(res_t)
	end

	gulags.pri_corner.ltx = ltx .. 
		"[patrol@pri_corner_monolith_raid]\npath_walk = raid_walk\npath_look = raid_look\non_signal = arrived | %+pri_corner_end%\n"
end


--------------------------------------------------------------------------
-- Depot (автовокзал)
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function z_predicate_c(npc_info)
    return npc_info.community == "controller"
end

function z_predicate_pd(npc_info)
    local c = npc_info.community
    return c == "psy_dog" or c == "pseudodog"
end

-- Jobs ------------------------------------------------------------------
gulags.pri_depot.job = function(sj, gname, type, squad, groups)
    local i = 0
    local ltx = ""
	local t

    local way_name = gname .."_controllers_home"
    local ptr = patrol(way_name)
    local wp_prop = utils.parse_waypoint_data(way_name, ptr:flags(0), ptr:name(0))
    local count = process_num(wp_prop.count, 3) -- controllers number
        
    for i = 1, count do
        t = { section = "logic@" .. gname .. "_controller", 
            idle = 0,
            prior = 1, state = {0},
            squad = squad, group = groups[1],
            in_rest = "", out_rest = gname .. "_base_restr",
            predicate = z_predicate_c
        }
        sj[#sj+1] = t
    end

    way_name = gname .."_psydogs_home"
    ptr = patrol(way_name)
    wp_prop = utils.parse_waypoint_data(way_name, ptr:flags(0), ptr:name(0))
    count = process_num(wp_prop.count, 9) -- psydogs number
        
    for i = 1, count do
        t = { section = "logic@" .. gname .. "_psydog", 
            idle = 0,
            prior = 1, state = {0},
            squad = squad, group = groups[2],
            in_rest = gname .. "_base_restr", out_rest = "",
            predicate = z_predicate_pd
        }
        sj[#sj+1] = t
    end

    ltx = "[logic@" .. gname .. "_controller]\n" ..
          "active     = mob_home@" .. gname .. "_controller\n" ..

          "[mob_home@" .. gname .. "_controller]\n" ..
          "path_home    = controllers_home\n" ..
          "aggressive_home\n" ..

          "[logic@" .. gname .. "_psydog]\n" ..
          "active     = mob_home@" .. gname .. "_psydog\n" ..

          "[mob_home@" .. gname .. "_psydog]\n" ..
          "path_home    = psydogs_home\n" ..
          "aggressive_home\n"

    gulags.pri_depot.ltx = ltx
end


--------------------------------------------------------------------------
-- Monolith (главная база монолита)
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function m_predicate_l(npc_info)
    return npc_info.story_id == 828
end

function m_predicate_r(npc_info)
    return npc_info.profile_name == "pri_monolith_regular"
end

function m_predicate_all(npc_info)
    return true
end

function m_predicate_s(npc_info)
    return npc_info.profile_name == "pri_monolith_specnaz"
end

function m_predicate_e(npc_info)
    return npc_info.profile_name == "pri_monolith_exo"
end

function m_predicate_s_sniper(npc_info)
	if npc_info.profile_name ~= "pri_monolith_specnaz" then return false end
	if npc_info.is_sniper_name == nil then npc_info.is_sniper_name = string.find(npc_info.name, "sniper") ~= nil end
	return npc_info.is_sniper_name
end

function m_predicate_e_rpg(npc_info)
    return npc_info.profile_name == "pri_monolith_exo" and obj_has_item(npc_info, "wpn_rpg7")
end

-- Jobs ------------------------------------------------------------------
gulags.pri_monolith.job = function(sj, gname, type, squad, groups)
	local table_concat = table.concat
	local prior, pred
	local state1_kamp, state1_restr
	local in_r = "" --"pri_snork_nest2_big_restr" --pri_snork_nest1_big_restr
	local res_t = {
		"[danger@monolith]\nignore_distance_sound = 150\n",

		-- кемп в гостиннице при атаке
		"[logic@pri_monolith_fight_in_hotel]\nactive = kamp@pri_monolith_fight_in_hotel\ncombat_ignore = combat_ignore\n",

		"[kamp@pri_monolith_fight_in_hotel]\ncenter_point = kamp6\ndef_state_moving = assault\ndanger = danger@monolith\ncombat_ignore_cond = {=pri_monolith_combat_ignore}\n",

		-- кемп в "Колосе" при атаке
		"[logic@pri_monolith_fight_in_kolos]\nactive = kamp@pri_monolith_fight_in_kolos\ncombat_ignore = combat_ignore\n",

		"[kamp@pri_monolith_fight_in_kolos]\ncenter_point = kamp4\ndef_state_moving = assault\ndanger = danger@monolith\ncombat_ignore_cond = {=pri_monolith_combat_ignore}\n",

		"[logic@pri_monolith_leader]\nactive = walker@pri_monolith_leader\ncombat_ignore = combat_ignore\non_death = death@pri_monolith_leader\n",

		"[death@pri_monolith_leader]\non_info = %+sar2_death_55%\n",

		"[walker@pri_monolith_leader]\npath_walk = leader_walk\npath_look = leader_look\ndanger = danger@monolith\ncombat_ignore_cond  = {=pri_monolith_combat_ignore}\n",

		"[logic@pri_monolith_leader_attack]\nactive = camper@pri_monolith_leader_attack\ncombat_ignore = combat_ignore\non_death = death@pri_monolith_leader\n",

		"[camper@pri_monolith_leader_attack]\npath_walk = leader_attack_walk\npath_look = leader_attack_look\ndanger = danger@monolith\ncombat_ignore_cond = {=pri_monolith_combat_ignore}\n",

		"[hit@altar_monolith]\non_info = %+pri_monolith_base_attack_altar_zone%\n" }

	local ltx = table_concat(res_t)

	-- leader
	local t = { section = "logic@pri_monolith_leader", 
		idle = 0,
		prior = 15, state = {0},
		squad = squad, group = groups[1],
		in_rest = in_r, out_rest = "pri_monolith_leader_restr",
		online = "{+pri_monolith_spawn2}",
		predicate = m_predicate_l
	}
	sj[#sj+1] = t

	t = { section = "logic@pri_monolith_leader_attack",
		idle = 0,
		prior = 15, state = {1},
		squad = squad, group = groups[1],
		in_rest = in_r, out_rest = "pri_monolith_leader_restr",
		online = "{+pri_monolith_spawn2}",
		predicate = m_predicate_l
	}
	sj[#sj+1] = t

	-- walkers (одиночные патрули вокруг базы)
	prior = {8, 7, 8, 12, 12, 7}
	state1_restr = {"", "_kolos_restr", "_base_restr", "", "", ""}
	local pred_pl = {m_predicate_s, m_predicate_s, m_predicate_s, m_predicate_s, m_predicate_s, m_predicate_all}
	for i, v in pairs({1, 3, 4, 5, 6, 8}) do
		t = { section = table_concat({"logic@pri_monolith_patrol", v}), 
			idle = 0,
			prior = prior[i], state = {0},
			squad = squad, group = groups[6],
			in_rest = in_r, out_rest = "",
			online = "{+pri_monolith_spawn1}",
			predicate = pred_pl[i]
		}
		sj[#sj+1] = t

		t = { section = table_concat({"logic@pri_monolith_patrol", v, "_attack"}),
			idle = 0,
			prior = prior[i], state = {1},
			squad = squad, group = groups[6],
			-- in_rest = "", out_rest = table_concat({gname, state1_restr[i]}),
			in_rest = "", out_rest = "pri_monolith"..state1_restr[i],
			online = "{+pri_monolith_spawn1}",
			predicate = m_predicate_s
		}
		sj[#sj+1] = t

		res_t = {
			"[logic@pri_monolith_patrol", 
			v, "]\nactive = walker@pri_monolith_patrol", 
			v, "\ncombat_ignore = combat_ignore\n",

			"[walker@pri_monolith_patrol", 
			v, "]\npath_walk = patrol", 
			v, "_walk\npath_look = patrol", 
			v, "_look\ndanger = danger@monolith\ncombat_ignore_cond = {=pri_monolith_combat_ignore}\n",

			"[logic@pri_monolith_patrol", 
			v, "_attack]\nactive = camper@pri_monolith_patrol", 
			v, "_attack\ncombat_ignore = combat_ignore\n",

			"[camper@pri_monolith_patrol", 
			v, "_attack]\npath_walk = patrol", 
			v, "_attack_walk\npath_look = patrol", 
			v, "_attack_look\ndanger = danger@monolith\ncombat_ignore_cond = {=pri_monolith_combat_ignore}\n" }
		ltx = ltx .. table_concat(res_t)
	end

	-- followers (парные патрули перед базой)
	prior = {8, 8, 8, 8}
	state1_kamp  = {"_fight_in_kolos", "_fight_in_hotel"}
	state1_restr = {"_kolos_restr",    ""}
	for i, v in pairs({7, 10}) do
		for j = 1, 2 do
			t = { section = table_concat({"logic@pri_monolith_group_patrol", i}), 
				idle = 0,
				prior = prior[i + 2 * (j - 1)], state = {0},
				squad = squad, group = groups[7],
				in_rest = in_r, out_rest = "",
				online = "{+pri_monolith_spawn1}",
				predicate = m_predicate_s
			}
			sj[#sj+1] = t

			t = { section = "logic@pri_monolith"..state1_kamp[i], 
				idle = 0,
				prior = prior[i + 2 * (j - 1)], state = {1},
				squad = squad, group = groups[7],
				-- in_rest = "", out_rest = table_concat({gname, state1_restr[i]}),
				in_rest = "", out_rest = "pri_monolith"..state1_restr[i],
				online = "{+pri_monolith_spawn1}",
				predicate = m_predicate_s
			}
			sj[#sj+1] = t
		end
		res_t = {
			"[logic@pri_monolith_group_patrol", 
			i, "]\nactive = patrol@pri_monolith_group_patrol", 
			i, "\ncombat_ignore = combat_ignore\n",
			
			"[patrol@pri_monolith_group_patrol", 
			i, "]\npath_walk = patrol", 
			v, "_walk\npath_look = patrol", 
			v, "_look\nformation = line\ndanger = danger@monolith\nsoundgroup = pri_monolith_group_patrol", 
			i, "_sg\ncombat_ignore_cond = {=pri_monolith_combat_ignore}\n" }
		ltx = ltx .. table_concat(res_t)
	end

	-- rpg, svd, machine-gun (гранатометчики и снайпер на центральном проходе на базу)
	local id = {11, 12, 14}
	pred = {m_predicate_s, m_predicate_s_sniper, m_predicate_s}
	local prior_arr = {14, 16, 14}
	for i, v in pairs({"rpg", "svd", "machine_gun"}) do
		t = { section = table_concat({"logic@pri_monolith_stalker_", v}), 
			idle = 0,
			prior = prior_arr[i], state = {0,1},
			squad = squad, group = groups[8],
			in_rest = in_r, out_rest = "",
			online = "{+pri_monolith_spawn1}",
			predicate = pred[i]
		}
		sj[#sj+1] = t

		res_t = {
			"[logic@pri_monolith_stalker_", 
			v, "]\nactive = camper@pri_monolith_stalker_", 
			v, "\ncombat_ignore = combat_ignore\n",

			"[camper@pri_monolith_stalker_", 
			v, "]\npath_walk = patrol", 
			id[i], "_walk\npath_look = patrol", 
			id[i], "_look\nsniper = true\nradius = 20\ndef_state_campering = threat\ndef_state_campering_fire = threat_fire\ndanger = danger@monolith\nsoundgroup = pri_monolith_rpg_svd_sg\ncombat_ignore_cond = {=pri_monolith_combat_ignore}\n" }
		ltx = ltx .. table_concat(res_t)
	end

	-- prayers (молящиеся вокруг алтаря)
	for i, v in pairs({14, 14, 14, 13, 8, 8}) do
		t = { section = table_concat({"logic@pri_monolith_prayer", i}),  
			idle = 0,
			prior = v, state = {0,1},
			squad = squad, group = groups[1],
			in_rest = in_r, out_rest = "pri_monolith_base_altar_restr",
			online = "{+pri_monolith_spawn2}",
			predicate = m_predicate_r
		}
		sj[#sj+1] = t

		res_t = {
			"[logic@pri_monolith_prayer", 
			i, "]\nactive = walker@pri_monolith_prayer", 
			i, "\ncombat_ignore = combat_ignore\non_hit = hit@altar_monolith\non_death = hit@altar_monolith\n",

			"[walker@pri_monolith_prayer", 
			i, "]\npath_walk = prayer", 
			i, "_walk\npath_look = prayer_look", 
			math.random(1, 2), 
			"\ndanger = danger@monolith\ncombat_ignore_cond = {-pri_monolith_base_attack_altar_zone}\n" }
		ltx = ltx .. table_concat(res_t)
	end

	-- kamps
	prior = {{11, 11, 11, 7}, {10, 10, 10, 7}, {11, 11, 11}, {9, 9, 9}, {13, 13, 7}}
	pred = {{m_predicate_s, m_predicate_s, m_predicate_all, m_predicate_all},
			{m_predicate_s, m_predicate_s, m_predicate_all, m_predicate_all},
			{m_predicate_e, m_predicate_e, m_predicate_e},
			{m_predicate_s, m_predicate_s, m_predicate_s},
			{m_predicate_e, m_predicate_all, m_predicate_all}}
	online_cond  = {"{+pri_monolith_spawn2}", "{+pri_monolith_spawn2}", "{+pri_monolith_spawn1}", "{+pri_monolith_spawn1}", "{+pri_monolith_spawn2}"}
	state1_restr = {"_base_restr", "_base_restr", "", "_kolos_restr", "_base_restr"}
	local pr, pd
	for i, v in pairs({4, 4, 3, 3, 3}) do
		pr = prior[i]
		pd = pred[i]
		for j = 1, v do
			t = { section = table_concat({"logic@pri_monolith_kamp", i, "_soldier"}), 
				idle = 0,
				prior = pr[j], state = {0},
				squad = squad, group = groups[i],
				in_rest = in_r, out_rest = "",
				online = online_cond[i],
				predicate = pd[j]
			}
			sj[#sj+1] = t

			t = { section = table_concat({"logic@pri_monolith_kamp", i, "_attack", j}),
				idle = 0,
				prior = pr[j], state = {1},
				squad = squad, group = groups[i],
				in_rest = "", out_rest = "pri_monolith"..state1_restr[i],
				online = online_cond[i],
				predicate = pd[j]
			}
			sj[#sj+1] = t

			res_t = {
				"[logic@pri_monolith_kamp", i, "_attack", 
				j, "]\nactive = camper@pri_monolith_kamp", i, "_attack", 
				j, "\ncombat_ignore = combat_ignore\n",

				"[camper@pri_monolith_kamp", i, "_attack", 
				j, "]\npath_walk = kamp", i, "_attack", 
				j, "_walk\npath_look = kamp", i, "_attack", 
				j, "_look\ndanger = danger@monolith\ncombat_ignore_cond = {=pri_monolith_combat_ignore}\n" }
			ltx = ltx .. table_concat(res_t)
        end
		res_t = {
			"[logic@pri_monolith_kamp", 
			i, "_soldier]\nactive = kamp@pri_monolith_kamp", 
			i, "_soldier\ncombat_ignore = combat_ignore\n",

			"[kamp@pri_monolith_kamp", 
			i, "_soldier]\ncenter_point = kamp", 
			i, "\ndanger = danger@monolith\ndef_state_moving = run\nsoundgroup = pri_monolith_kamp", 
			i, "\ncombat_ignore_cond = {=pri_monolith_combat_ignore}\n" }
		ltx = ltx .. table_concat(res_t)
    end

	-- snipers (снайперы на большом балконе главной базы)
	for i = 1, 2 do
		t = { section =  table_concat({"logic@pri_monolith_sniper", i}), 
			idle = 0,
			prior = 16, state = {0,1},
			squad = squad, group = groups[9],
			in_rest = in_r, out_rest = "",
			online = "{+pri_monolith_spawn1}",
			predicate = m_predicate_s_sniper
		}
		sj[#sj+1] = t

		res_t = {
			"[logic@pri_monolith_sniper", 
			i, "]\nactive= camper@pri_monolith_sniper", 
			i, "_wait\ncombat_ignore= combat_ignore\n",

			"[camper@pri_monolith_sniper", 
			i, "_wait]\npath_walk = balcony_sniper", 
			i, "_walk\npath_look = balcony_sniper", 
			i, "_look\ndef_state_moving = assault\ndef_state_campering = threat\ndef_state_campering_fire = threat_fire\nsniper = true\nradius = 0\non_info = {+pri_monolith_snipers_free} walker@pri_monolith_sniper", 
			i, "_free\ncombat_ignore_cond = {=pri_monolith_combat_ignore}\ndanger = danger@monolith\n",

			"[walker@pri_monolith_sniper", 
			i, "_free]\npath_walk = balcony_sniper", 
			i, "_free_walk\npath_look = balcony_sniper", 
			i, "_free_look\non_info = {-pri_monolith_snipers_free} camper@pri_monolith_sniper", 
			i, "_wait\ndanger = danger@monolith\ncombat_ignore_cond = {=pri_monolith_combat_ignore}\n" }
		ltx = ltx .. table_concat(res_t)
	end

	gulags.pri_monolith.ltx = ltx
end

-- States ----------------------------------------------------------------
gulags.pri_monolith.state = function(gulag)
    if gulag.state == 1 and game.get_game_time():diffSec(gulag.stateBegin) < 1800 then -- 3 minutes
        return 1 -- somebody attack base
    else
        local k, v = 0, 0
        for k,v in pairs(gulag.Object) do
            if v ~= true then
                local enemy = v:best_enemy()
                if enemy ~= nil then
                    local enemy_type = enemy:clsid()
                    if enemy_type == clsid_actor or enemy_type == clsid_script_stalker then
                        db_actor:give_info_portion("pri_monolith_base_attacked")
                        return 1
                    end
                end
            end
        end
        db_actor:disable_info_portion("pri_monolith_base_attacked")
    end

    return 0 -- normal state
end


--------------------------------------------------------------------------
-- Stadium (гранатометчики на стадионе)
--------------------------------------------------------------------------
-- Jobs ------------------------------------------------------------------
gulags.pri_stadium.job = function(sj, gname, type, squad, groups)
	local table_concat = table.concat
	local res_t, t
	local i, ltx = 1, ""
	local way_name =  table_concat({"pri_stadium_sniper_", i, "_walk"})
	-- Проверяем наличие снайперов в лагере.
	while level.patrol_path_exists(way_name) do
		-- Необходимо вычитать количество работ из названия точки пути.

		-- добавляем должность
		t = { section = table_concat({"logic@", way_name}),
			idle = 0,
			prior = 1, state = {0}, squad = squad, group = groups[1],
			in_rest = "", out_rest = "pri_stadium_snipers_restr",
			online = "{+pri_stadium_scene_start}",
			predicate = m_predicate_e_rpg
		}
		sj[#sj+1] = t

		-- добавляем описание должности в лтх.
		res_t = {
			"[logic@", way_name, "]\nactive = camper@", way_name, "\ncombat_ignore = combat_ignore\n",

			"[camper@", way_name, "]\npath_walk = sniper_", 
			i, "_walk\npath_look = sniper_look\ndef_state_campering = threat\ndef_state_campering_fire = threat_sniper_fire\nsniper = true\ncombat_ignore_cond = {=enemy_gulag(pri_stadium_lair)}\n" }
		ltx = ltx .. table_concat(res_t)
		i = i + 1
		way_name =  table_concat({"pri_stadium_sniper_", i, "_walk"})
	end

    gulags.pri_stadium.ltx = ltx
end
