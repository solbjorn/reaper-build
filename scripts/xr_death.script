----------------------------------------------------------------------------------------------------------------------
--Actions
----------------------------------------------------------------------------------------------------------------------
-- Обычное поведение

class "action_process_death"

function action_process_death:__init(obj, storage)
	self.object = obj
	self.st = storage
end

function action_process_death:death_callback(victim, who)
	local killer_id
	local actor = Actor
	if who ~= nil then
		killer_id = who:id()
		if killer_id == 0 and victim:best_enemy() == nil then
			killer_id = -1
			if victim:relation(actor) ~= game_object.enemy then
				local vic_smart_terrain_id = g_alife:object(victim:id()):smart_terrain_id()
				if vic_smart_terrain_id and vic_smart_terrain_id ~= 65535 then
					local smt_trn = g_alife:object(vic_smart_terrain_id)
					for id, npc_info in pairs( smt_trn.npc_info ) do
						local buddy = level.object_by_id(id)
						if buddy and buddy:alive() then
							if buddy:see(actor) or buddy:position():distance_to(actor:position()) < 5 then
								killer_id = 0
								break
							end
						end
					end
				end
			end
		end
	else
		killer_id = -1
	end
	db.storage[victim:id()].death.killer = killer_id

	if actor then
		if self.st.info then
			xr_logic.pick_section_from_condlist(self.object, self.st.info)
		end

		if self.st.info2 then
			xr_logic.pick_section_from_condlist(self.object, self.st.info2)
		end
	end
end

----------------------------------------------------------------------------------------------------------------------
-- binder
----------------------------------------------------------------------------------------------------------------------
function add_to_binder(npc, storage)
	storage.actions[ action_process_death(npc, storage) ] = true
end

function set_death(npc, ini, scheme, section)
	xr_logic.assign_storage_and_bind(npc, ini, scheme, section)
end

function reset_death(npc, scheme, st, section)
	local function get_field_string(field)
		return (ini:line_exist(section, field) and ini:r_string(section, field)) or nil
	end

	section = st.section_logic
	ini = st.ini
	if section and ini:section_exist(section) then
		section = get_field_string("on_death")
		if section and ini:section_exist(section) then
			local tmp = get_field_string("on_info")
			if tmp then
				st.death.info = xr_logic.parse_condlist(tmp)
			end
			tmp = get_field_string("on_info2")
			if tmp then
				st.death.info2 = xr_logic.parse_condlist(tmp)
			end
		end
	end
end
