--[[
  TAG фенечка 1.2 стр.240, 369-387
]]

local bind_restrictor_actor_update = bind_restrictor.actor_update
local game_get_game_time = game.get_game_time
local object_binder_update = object_binder.update
local string_sub = string.sub
local xr_sound_update_actor = xr_sound.update_actor

local cbs = {
	[callback.inventory_info]		= "info_callback",
	[callback.article_info]			= "article_callback",
	[callback.on_item_take]			= "on_item_take",
	[callback.on_item_drop]			= "on_item_drop",
	[callback.task_state]			= "task_callback",
	[callback.level_border_enter]		= "level_border_enter",
	[callback.level_border_exit]		= "level_border_exit",
	[callback.take_item_from_box]		= "take_item_from_box",

	[callback.hit]				= "hit_callback",
	[callback.death]			= "death_callback",
	[callback.on_key_press]			= "on_key_press",
	[callback.on_key_release]		= "on_key_release",
	[callback.on_mouse_wheel]		= "on_mouse_wheel",
	[callback.on_mouse_move]		= "on_mouse_move",
	[callback.on_belt]			= "on_item_belt",
	[callback.on_ruck]			= "on_item_ruck",
	[callback.on_slot]			= "on_item_slot",
	[callback.select_pda_contact]		= "select_pda_contact",
	[callback.on_attach_vehicle]		= "attach_vehicle",
	[callback.on_detach_vehicle]		= "detach_vehicle",
	[callback.entity_alive_before_hit]	= "before_hit_callback",

	[callback.use_object]			= "on_item_use",
	[callback.on_before_use_item]		= "on_before_use_item"
}

local cbs_sa = {
	hit_callback				= "actor_hit",
	death_callback				= "actor_death",
	on_key_press				= "key_press",
	on_key_release				= "key_release",
	on_mouse_wheel				= "mouse_wheel",
	on_mouse_move				= "mouse_move",
	on_item_belt				= "item_belt",
	on_item_ruck				= "item_ruck",
	on_item_slot				= "item_slot",
	select_pda_contact			= "select_pda_contact",
	hit_effector_callback			= "hit_effector",
	attach_vehicle				= "attach_vehicle",
	detach_vehicle				= "detach_vehicle"
}

local cbs_reap = {
	on_item_use				= "item_use",
	before_hit_callback			= "actor_before_hit",
	on_before_use_item			= "before_use_item"
}

function init_cbs_tbl(self)
	for fn, sa in pairs(cbs_sa) do
		self[fn] = sa_callbacks[sa]
	end
	cbs_sa = nil

	for fn, rp in pairs(cbs_reap) do
		self[fn] = reap[rp]
	end
	cbs_reap = nil

	local obj = self.object
	local set_cb = obj.set_callback

	for id, fn in pairs(cbs) do
		set_cb(obj, id, self[fn], self)
		cbs[id] = true
	end

	init_cbs_tbl = nil
end

function deinit_cbs_tbl(self)
	local obj = self.object
	local set_cb = obj.set_callback

	for id, fn in pairs(cbs) do
		set_cb(obj, id, nil)
	end

	cbs = nil
	deinit_cbs_tbl = nil
end

function init(npc)
	npc:bind_object(actor_binder(npc))
end

----------------------------------------------------------------------------------------------------------------------
class "actor_binder" (object_binder)
----------------------------------------------------------------------------------------------------------------------
function actor_binder:__init (obj) super(obj)
	_G.curr_level = level.name()
	_G.time_real_ms = time_global()
	_G.time_game_ct = game_get_game_time()
	_G.time_game_hours = game.hours()

	self.bCheckStart = false
	self.actor_detector = xr_detector.actor_detector()

	sa_callbacks.__init()
	reap_callback.__init(self)

	self.in_rad_zone = false
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:net_spawn(data)
	if object_binder.net_spawn(self, data) == false then
		return false
	end

	_G.time_real_ms = time_global()
	_G.time_game_ct = game_get_game_time()
	_G.time_game_hours = game.hours()

	self.bCheckStart = true

	db.add_obj(self.object)
	-- регистрация в схеме биорадара
	biodetector.add_obj(self.object)

	_G.Actor = self.object
	_G.AObj = get_actor_obj()
	_G.Inventory = inventory.CInventory()
	_G.hud = get_hud()
	_G.Arena = aem_manager.CArenaext()
	_G.Dream = dream.dream_mgr()

	level.show_indicators()

	if self.st.disable_input_time == nil then
		level.enable_input()
	end

	if self.actor_detector.init_time ~= -1 then
		self.actor_detector:actor_enter()
	end
	actor_stats.add_to_ranking(0)

	--' Загружаем настройки дропа
	death_manager.init_drop_settings()
	xr_box.init_drop_box()

	sa_callbacks.actor_net_spawn()
	reap.net_spawn(self)

  -- added by xStream for AMK miniSDK
  xrs_ai.actor_net_spawn(self)
  amk.on_game_load(obj)
	sak.out_teleport()
  sak.add_tail()
	spawn_level_changer.remove_old_teleport()
  braad_test.false_info()
  -- end of addition

  return true
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:net_destroy()
	_G.time_real_ms = nil
	_G.time_game_ct = nil
	_G.time_game_hours = nil

	actor_stats.remove_from_ranking(0)

	_G.Actor = nil
	_G.AObj = nil
	_G.Inventory = nil
	_G.Arena = nil
	_G.Dream = nil

	db.del_obj(self.object)
	-- отрегистрация в схеме биорадара
	biodetector.remove_obj(self.object)

    sr_light.clean_up ()

	deinit_cbs_tbl(self)

  if sr_psy_antenna.psy_antenna then
    sr_psy_antenna.psy_antenna:destroy()
    sr_psy_antenna.psy_antenna = false
  end

  xr_sound.stop_all_sound_object()

	reap_callback.net_destroy(self)

  object_binder.net_destroy(self)
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:reinit()
  object_binder.reinit(self)

	self.st = { }
	db.storage[0] = self.st
	self.st.pstor = nil

	init_cbs_tbl(self)
	actor_flags.alive = self.object:alive()
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:take_item_from_box(box, item)
	amk_offline_alife.take_item_from_box(box, item)
	reap_callback.take_item_from_box(box, item)

	local story_id = box:story_id()
	if story_id >= 5000 and story_id <= 10000 then
		Treasure:treasure_empty(box, story_id)
	end

	--AMK UTILS--
	amk.on_item_take_from_box(box,item)
	--AMK UTILS--

	local respawner = se_respawn.get_respawner_by_parent(story_id)
	if not respawner then return end

	--' Необходимо уменьшить счетчик в респавнере
	respawner:remove_spawned(item:id())

	local smt = db.strn_by_respawn[respawner:name()]
	local npc = smt and smt.gulag:get_nearest_online_obj(Actor:position())
	if npc then
		timer(xr_sound.set_sound_play, 100, true, npc, "reac_box")
		xr_gulag.setGulagEnemy(smt:name(), Actor)
	end
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:level_border_enter(npc, info_id)
  self.actor_detector:actor_enter()
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:level_border_exit(npc, info_id)
  self.actor_detector:actor_exit()
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:info_callback(npc, info_id)
	local ui_info = string_sub(info_id, 1, 3) == "ui_"
	if not ui_info then
		--' Сюжет
		level_tasks.proceed()
		-- Отметки на карте
		level_tasks.process_info_portion(info_id)
	end

	sa_callbacks.info(info_id, ui_info)
	reap.info(info_id, ui_info)
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:article_callback(npc, group, name, _type)
	if screen.precache_frame <= 1 then
		news_manager.send_encyclopedy(_type, group, name)
	end
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:on_item_take (obj)
	amk_offline_alife.on_item_take(obj)
	freeplay_stats:check_found_item(obj)

	level_tasks.proceed()

  --AMK UTILS--
  amk.on_item_take(obj)
	sak.check_used_item(obj)
	braad_test.checking_use_item(obj)
	xrs_ai.actor_item_take(obj)
  --AMK UTILS--

	spawn_zombi.on_item_take(obj)
	spawn_teleport.on_item_take(obj)
	new_spawn.on_item_take(obj)
	spawn_restrictor.on_item_take(obj)

	sa_callbacks.item_take(obj)
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:on_item_drop (obj)
	amk_offline_alife.on_item_drop(obj)
    level_tasks.proceed()

  --AMK UTILS--
  amk.on_item_drop(obj)
  --AMK UTILS--
  sak.check_droped_item(obj)

	sa_callbacks.item_drop(obj)
end
----------------------------------------------------------------------------------------------------------------------

function actor_binder:task_callback(_task, _objective, _state)
	random_task:task_callback(_task:get_id(), _objective:get_idx(), _state)
	if _objective:get_idx() == 0 then
		if _state == task.fail then
			reap_misc.task_mapspot_cleanup(_task:get_id(), _objective:get_idx())
			news_manager.send_task("fail", _task, _objective)
		elseif _state == task.completed then
			random_task:task_reward_storyline(_task)
			reap_misc.task_mapspot_cleanup(_task:get_id(), _objective:get_idx())
			news_manager.send_task("complete", _task, _objective)
		else
			news_manager.send_task("new", _task, _objective)
		end
	else
		if _task:get_objective(0):get_state() == task.in_progress then
			news_manager.send_task("update", _task, _objective)
		end
	end
end

----------------------------------------------------------------------------------------------------------------------

local start = true
local next_100 = 0
local next_200 = 0
local next_500 = 0

function actor_binder:update(delta)
	object_binder_update(self, delta)

	_G.time_real_ms = time_global()
	_G.time_game_ct = game_get_game_time()

	if start then
		sak_off_corpses.off_corpses()
		start = false
	end

	-- апдейт звуковой схемы актера
	xr_sound_update_actor()

-- ----------------------------------------------------- ARENA_EXTENSION_MOD--------------------------------------------------------
	Arena:update()
-- ----------------------------------------------------- ARENA_EXTENSION_MOD--------------------------------------------------------

	-- обновление рестрикторов, которые под логикой, срабатывает через интервалы времени
	bind_restrictor_actor_update(delta)

	if next_200 <= time_real_ms then
		-- апдейт схемы детектора
		self.actor_detector:update()

		-- Обновление отключения ввода с клавиатуры.
		if self.st.disable_input_time ~= nil and
			 game.get_game_time():diffSec(self.st.disable_input_time) >= self.st.disable_input_idle
		then
			level.enable_input()
			self.st.disable_input_time = nil
		end

		--' Вывод сообщения о большой радиации
		local rad_danger = "cs_radiation_danger"
		local custom_static = hud:GetCustomStatic(rad_danger)
		if self.object.radiation >= 0.7 then
			if custom_static == nil then
				custom_static = hud:AddCustomStatic(rad_danger, true)
				custom_static:wnd():SetTextST("st_radiation_danger")
			end
		else
			if custom_static ~= nil then
				hud:RemoveCustomStatic(rad_danger)
			end
		end
	end

  -- обновление пси-антенны
  if sr_psy_antenna.psy_antenna then
    sr_psy_antenna.psy_antenna:update(delta)
  end

	if next_200 <= time_real_ms then
		-- Апдейтим наш телепорт
		bind_mteleport.actor_update(delta)

		-- TAG Хлеб и колбаса портятся от радиации
		if self.object.radiation > 0.4 and self.in_rad_zone == false then
			if (self.object:object("bread") or self.object:object("kolbasa")) then
				local need_say = false
				self.object:iterate_inventory(
					function (dummy,item)
						if item:section()=="bread" and math.random() <= self.object.radiation then
							need_say = true
							amk.remove_item(item)
							amk.spawn_item_in_inv("bread_a")
						elseif item:section()=="kolbasa" and self.object.radiation>0.6 and math.random() <= (self.object.radiation - 0.2) then
							need_say = true
							amk.remove_item(item)
							amk.spawn_item_in_inv("kolbasa_a")
						end
					end
				)
				if need_say then
					amk.send_tip("st_rad_food", nil, nil, 5)
				end
			end

			self.in_rad_zone = true
		elseif self.in_rad_zone == true and self.object.radiation < 0.3 then
			self.in_rad_zone = false
		end

		next_200 = time_real_ms + 200
	end

	if next_500 <= time_real_ms then
		_G.time_game_hours = game.hours()

		freeplay_stats:check_actor_money()
		freeplay_stats:check_actor_rank()
	end

  if self.bCheckStart then
    if not has_alife_info("storyline_actor_start") and
       (level.name() == "l01_escape")
    then
      self.object:give_info_portion("storyline_actor_start")
    end

    if not has_alife_info("global_dialogs") then
      self.object:give_info_portion("global_dialogs")
    end

    self.bCheckStart = false
  end

  --AMK UTILS--
  amk.on_actor_upade(delta)
  --AMK UTILS--

	if next_100 <= time_real_ms then
		amk_offline_alife.actor_update(delta)
		arc_main.actor_update()

		next_100 = time_real_ms + 100
	end

	if next_500 <= time_real_ms then
		sak.nepis_umer()
		braad_test.dead_npc()

		next_500 = time_real_ms + 500
	end

	xrs_ai.actor_update(delta)
	biodetector.update(delta)

	sa_callbacks.actor_update(delta)
	reap.update(self)
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:save(packet)
	object_binder.save(self, packet)

	--' Сохраняем уровень сложности
	packet:w_u8(level.get_game_difficulty())

	--' Сохраняем данные об отключенном вводе
	if self.st.disable_input_time == nil then
		packet:w_bool(false)
	else
		packet:w_bool(true)
		packet:w_CTime(self.st.disable_input_time)
	end

	xr_logic.pstor_save_all(self.object, packet, self.st)

	sr_psy_antenna.save( packet )

	Treasure:save(packet)
	random_task:save(packet)

	freeplay_stats:save(packet)
	sa_callbacks.actor_save(packet)

	local flags = 0
	if self.in_rad_zone then
		flags = bit_or(flags, 1)
	end
	packet:w_u8(flags)
end
----------------------------------------------------------------------------------------------------------------------
local game_difficulty_by_num = {
	[0]	= "gd_novice",
	[1]	= "gd_stalker",
	[2]	= "gd_veteran",
	[3]	= "gd_master"
}

function actor_binder:load(reader)
	object_binder.load(self, reader)

	--' Загружаем уровень сложности
	console:execute("g_game_difficulty " .. game_difficulty_by_num[reader:r_u8()])
	game_difficulty_by_num = nil

	if reader:r_eof() then
		abort("SAVE FILE IS CORRUPT")
		return
	end

	local stored_input_time = reader:r_bool()
	if stored_input_time == true then
		self.st.disable_input_time = reader:r_CTime()
		self.st.disable_input_idle = xr_effects.punch_recovery_time
	end

	xr_logic.pstor_load_all(self.object, reader, self.st)

	sr_psy_antenna.load(reader)

	Treasure:load(reader)
	random_task:load(reader)

	freeplay_stats:load(reader)
	sa_callbacks.actor_load(reader)

	local flags = reader:r_u8()
	self.in_rad_zone = bit_and(flags, 1) ~= 0
end
