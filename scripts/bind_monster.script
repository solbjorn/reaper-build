-----------------------------------------------------------------------------------
-- Monster binding

-- TAG фенечка 1.1
-----------------------------------------------------------------------------------
local particles={}

local callback_hit = callback.hit
local callback_death = callback.death
local callback_use_object = callback.use_object
local callback_patrol_path_in_point = callback.patrol_path_in_point
local table_insert = table.insert

function bind(obj, aem)
	obj:bind_object(generic_object_binder(obj, aem))
end

------------------------------------------------------------------------------------
class "generic_object_binder" (object_binder)

function generic_object_binder:__init(obj, aem)
	super(obj)

	self.loaded = false
	self.particles = {}
	self.next_update_200 = 0
	self.next_update_1000 = 0
	self.death_recorded = false

	if obj:story_id() == 29 then -- учебная плоть блин
		self.anomaly_evade = function()
		end
	else
		self.prev_pos = vector():set(0, -100, 0)
	end

	self.aem = aem
end

function generic_object_binder:reload(section)
	object_binder.reload(self, section)
end

function generic_object_binder:reinit()
	object_binder.reinit(self)

	self.object:set_patrol_extrapolate_callback(self.extrapolate_callback, self)

	self.st = { }
	db.storage[self.object:id()] = self.st

	self.object:set_callback(callback_patrol_path_in_point, self.waypoint_callback, self)
	self.object:set_callback(callback_hit,					self.hit_callback,		self)
	self.object:set_callback(callback_death,				self.death_callback,	self)
	self.object:set_callback(callback_use_object, self.use_callback, self)
end

function generic_object_binder:update(delta)
	object_binder.update(self, delta)

	local obj_id = self.object:id()
	if particles[obj_id] and #particles[obj_id] > 0 then
		for kk,vv in pairs(particles[obj_id]) do
			table_insert(self.particles,amk_particle.amk_particle(vv))
			table.remove(particles[obj_id],kk)
		end
	end

	if #self.particles > 0 then
		for kk,vv in pairs(self.particles) do
			if vv:is_finished() then
				self.particles[kk]=nil
			else
				vv:update(delta)
				if vv.give_dmg and vv.target then
					if vv:get_pos():distance_to(vv.target:bone_position("bip01_spine"))<1 then
						local h = hit()
						h.impulse = 0
						h.draftsman = vv.target
						h.direction = vv.dir
						h:bone("bip01_spine") -- чтобы учитывалась броня
						h.power = math.random(10,50)/100
						h.type = hit.strike --chemical_burn
						vv.target:hit(h)
						h.power = math.random(10,50)/100
						h.type = hit.chemical_burn
						vv.target:hit(h)
						vv:stop()
					end
				end
			end
		end
	end

	if self.death_recorded then return end

	if self.object:alive() then
		self.object:set_tip_text("")
	else
		self.object:set_tip_text_default()
		self.death_recorded = true
	end

	if time_real_ms >= self.next_update_200 then
		self:anomaly_evade()
		self.next_update_200 = time_real_ms + 200
	end

	local eff = self.effector
	if eff and eff.update then
		eff:update()
	end

	if time_real_ms >= self.next_update_1000 then
		if self.object.health>0.03 then
			local dist = Actor:position():distance_to(self.object:position())
			if dist < 40 then
				local enemy = self.object:get_enemy()
				if enemy and enemy:id() == 0 and self.object:see(enemy) then
					amk.enemy_see_actor(self.object)
				end
			end
			if dist < 80 and Actor:see(self.object) then
				amk.actor_see_enemy(self.object)
			end
		end
		self.next_update_1000 = time_real_ms + 1000
	end

	local blowout = get_value("blowout", 0)
	if blowout==3 and (not self.control_override) and not string.find(self.object:out_restrictions(), "bar_arena_restrictor") then
		if not self.object:action() then
			-- Захватываем зверушку
			xr_logic.mob_capture(self.object,true)
			self.control_override=true
		end
	elseif self.control_override and blowout==3 then
		if not self.object:action() then
			local snds={sound.take_damage,sound.panic,sound.idle}
			local snd=snds[math.random(1,table.getn(snds))]
			action(self.object, anim(anim.lie_idle, 0), sound(snd), cond(cond.sound_end))
		end
	elseif self.control_override and blowout~=3 then
		-- отпускаем зверушку
		self.control_override=nil
		xr_logic.mob_release(self.object)
	elseif self.st.active_section ~= nil then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "update", delta)
	end
end

function generic_object_binder:anomaly_evade()
	local npc=self.object
	local pos = npc:position()

	if self.prev_pos:distance_to(pos)>20 then
		self.prev_pos=pos
		local list=amk_anoms.get_anomaly_list(npc,30)
		for i,o in ipairs(list) do
			amk_anoms.add_restriction(npc,o.id,o.name)
		end
	end
	if amk_anoms.have_pending_sync(npc) then
		amk_anoms.syncronize(npc)
	end
end

function generic_object_binder:extrapolate_callback()
	if not self.object or self.object:get_script() == false then
		return false
	end

	return patrol(self.object:patrol()):flags(self.object:get_current_point_index()):get() == 0
end

function generic_object_binder:waypoint_callback(obj, action_type, index)
	if self.st.active_section ~= nil then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "waypoint_callback", obj, action_type, index)
	end
end

function generic_object_binder:death_callback(victim, who)
	if not self.object then return end

	if reap.hit_by_actor(who) == 0 then
		xr_statistic.addKillCount(self.object)
		freeplay_stats:check_monster_killed_count(self.object)

		news_main.check_microquest(self.object)
	end

	if self.st.mob_death then
		xr_logic.issue_event(self.object, self.st.mob_death, "death_callback", victim, who)
	end

	if self.st.active_section then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "death_callback", victim, who)
	end

	smart_terrain.on_death( self.object:id() )

	if self.effector and self.effector.death then
		self.effector:death()
		self.effector = nil
	end

	if #self.particles > 0 then
		for kk,vv in pairs(self.particles) do
			vv:on_death()
		end
	end

	--AMK UTILS--
	amk.on_death(victim, who)
	--AMK UTILS--

	smart_monster_parts.death_spawn(victim)
end

function generic_object_binder:use_callback(obj, who)
	sa_callbacks.monster_use(obj, who)
end

function generic_object_binder:hit_callback(obj, amount, local_direction, who, bone_index)
	if self.st.active_section then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "hit_callback", obj, amount, local_direction, who, bone_index)
	end

	if self.st.hit then
		xr_logic.issue_event(self.object, self.st.hit, "hit_callback", obj, amount, local_direction, who, bone_index)
	end

  -- added by xStream for AMK miniSDK
	amk.on_monster_hit(obj, amount, local_direction, who, bone_index)
  -- end of addition

	local eff = self.effector
	if eff and eff.hit then
		eff:hit()
	end

	smart_monster_parts.main_check(obj, amount, local_direction, who, bone_index)
end

function generic_object_binder:net_spawn(sobject)
	if not object_binder.net_spawn(self, sobject) then
		return false
	end

	local obj = self.object

	if self.aem == true then
		obj:add_restrictions("bar_arena_restrictor", "")
	end

	db.add_obj(obj)
	-- регистрация в схеме биорадара
	biodetector.add_obj(obj)

	xr_gulag.setup_gulag_and_logic_on_spawn( obj, self.st, sobject, modules.stype_mobile, self.loaded )

	amk.on_net_spawn(obj)

	local particle_param = config:r_string_cache(obj:section(), "bones_particles")
	if particle_param and config:section_exist(particle_param) then
		local tmp=amk.parse_ini_section_to_array(config, particle_param)
		for k,v in pairs(tmp) do
			local t = amk.parse_ini_section_to_array(config, v)
			t.obj = obj
			if not t.stop_on_death or obj:alive() then
				play_particle(obj, t)
			end
		end
	end

	if obj:alive() then
		self.effector = reap_monsters.init_monster_effector(obj)
	end

	return true
end

function generic_object_binder:net_destroy()
	self.effector = nil

	if #self.particles > 0 then
		for kk,vv in pairs(self.particles) do
			if not vv:is_finished() then
				vv:stop()
				self.particles[kk]=nil
			end
		end
	end

	local obj = self.object
	obj:set_callback(callback_death, nil)
	obj:set_callback(callback_patrol_path_in_point, nil)
	obj:set_callback(callback_hit, nil)
	obj:set_callback(callback_use_object, nil)

	local obj_id = obj:id()
	local st = db.storage[obj_id]
	if st and st.active_scheme then
		xr_logic.issue_event(obj, st[st.active_scheme], "net_destroy")
	end

	db.del_obj(obj)
	-- отрегистрация в схеме биорадара
	biodetector.remove_obj(obj)

	object_binder.net_destroy(self)

	-- АМК. Очистка рестрикторов
	local sobj = server_object(obj_id)
	if sobj then
		local tbl=amk.read_monster_params(sobj)
		tbl.crvu32u16u2={}
		amk.write_monster_params(tbl,sobj)
	end
end

function generic_object_binder:net_save_relevant()
	return true
end

function generic_object_binder:save(packet)
	object_binder.save(self, packet)

	xr_logic.save_obj(self.object, packet)
end

function generic_object_binder:load(reader)
	self.loaded = true

	object_binder.load(self, reader)

	if reader:r_eof() then
		abort("bind_monster.script, generic_object_binder:load(): - SAVE FILE IS CORRUPT")
		return
	end

	xr_logic.load_obj(self.object, reader)
end

function play_particle(obj,params)
	local obj_id = obj:id()
	if not particles[obj_id] then
		particles[obj_id] = { }
	end
	table_insert(particles[obj_id], params)
end
