--[[

File:  amk .script
Copyright © AMK TEAM 2007-2008

-- Idler: файл из мода 'Народная солянка 2.0'. Адаптирован для мода 'Метки с хабаром 2.1.2' 30.09.2008 0:08:52
-- добавлена fenechka by TAG

]]

local string_explode = string.explode
local string_find = string.find
local string_gmatch = string.gmatch
local string_gsub = string.gsub
local string_trim = string.trim

----------------

local markers={}  --хранит маркеры на карте
local x_objs={}     --хранит ИДшники объектов
convert_npc={}

oau_watchdog=0
oau_reason=""

--показываем типс
function send_tip(news_text, header, timeout, showtime, sender, sound)
	if sound == "news" then
		sound = "pda_news"
	elseif sound == "task" then
		sound = "pda_objective"
	else
		sound = "pda_tip"
	end

	_G.send_tip(news_text, header, timeout, showtime, sender, sound)
end

function add_spot_on_map(obj_id,type,text)
  --возможные типы type смотри в ui\map_spots.xml
  if obj_id then
    if text==nil then text=" " end
    -- Ставим метку на серверный объект чтобы её не пришлось обновлять
    level.map_add_object_spot_ser(obj_id, type, text)
  end
end

function remove_spot_from_map(obj_id,type)
  if obj_id and level.map_has_object_spot(obj_id, type)~= 0 then
    level.map_remove_object_spot(obj_id, type)
  end
end

--[[---------------------------------------------------------------------------
 * Item use callback
--]]---------------------------------------------------------------------------

local item_use_acts
function init_item_use_acts()
	item_use_acts = {
		["energy_drink"]	= amk_mod.test_for_need_sleep_nrg,
		["matras"]		= amk_mod.test_for_need_sleep_matras,
		["treasure_item"]	= news_main.create_treasurebox,
		["vodka"]		= amk_alcohol.drink_vodka
	}
end

function item_use(obj)
	local fn = item_use_acts[obj:section()]
	if fn then
		fn(obj)
		return
	end

	spawn_level_changer.teleport_start(obj)
	tag_spb.refresh_zombie_team(obj)
end

--[[---------------------------------------------------------------------------
 * Legacy timer handlers
--]]---------------------------------------------------------------------------

function block_sleep_menu_handler()
	set_value("block_sleep_menu", 0)
end

function amk_freeplay_handler()
	if get_value("freeplay", 0) == 1 and level.name() == "l12_stancia_2" then
		xr_effects.game_credits()
	end
end

function healing_enemies_handler(id, com)
	local npc = level_object(id)
	if math.random(1,100) > 80 then
		npc:set_character_community(com)
		npc:set_relation(game_object.enemy, Actor)
	else
		xr_wounded.custom_change(npc)
	end
end

local legacy_acts = {
	["tag_trup_to_zombie"]		= "tag_spb.trup_to_zombie",
	["sms_new"]			= "braad_test.sms_new",
	["sms_new1"]			= "braad_test.sms_new1",
	["sms"]				= "wawka.smski_besu",
	["smska_borova"]		= "wawka.smska_borova",
	["smska_volka"]			= "wawka.smska_volka",
	["smska_shurupa"]		= "wawka.smska_shurupa",
	["smska_dana"]			= "wawka.smska_dana",
	["smska_saharova"]		= "wawka.smska_saharova",
	["smska_barmana"]		= "wawka.smska_barmana",
	["show_news"]			= "amk_mod.show_news",
	["gg_need_sleep"]		= "amk_mod.test_for_need_sleep",
	["block_sleep_menu"]		= "amk.block_sleep_menu_handler",
	["amk_freeplay"]		= "amk.amk_freeplay_handler",
	["blowout"]			= "amk_mod.Blowout_pp",
	["blowout_ss"]			= "amk_mod.blowout_scary_sounds",
	["blow_shift"]			= "amk_mod.Run_Blowout_pp",
	["collect_anomalies_info"]	= "amk_anoms.collect_info",
	["news_check"]			= "news_main.check_news",
	["healing_enemies"]		= "amk.healing_enemies_handler",
	["nano_health_start"]		= "skunk.nano_health_s"
}

--старт таймера в реальном времени
function start_timer(call, delay, ...)
	if not call or not delay then return false end

	call = legacy_acts[call] or call
	return timer(call, delay * 1000, true, ...)
end

--старт таймера в игровом времени
function g_start_timer(call, delay_d, delay_h, delay_m, ...)
	if not call or not delay_d or not delay_h or not delay_m then return false end

	local delay = ((delay_d * 60 * 24 + delay_h * 60 + delay_m) * 60) * 1000
	call = legacy_acts[call] or call

	return timer(call, delay, false, ...)
end

--------------------------------------------------------------------------------------------------------------------

--спавним объекты на карту
--для спавна неписей смотрим config\creatures\spawn_sections.ltx - там написаны имена секций для разных типов неписей
function spawn_item(spawn_item, pos, gv,lv)
  if gv==nil then gv=Actor:game_vertex_id() end
  if lv==nil then lv=Actor:level_vertex_id() end
  return AI:create(spawn_item, pos, lv, gv)
end

--для спавна патронов используем spawn_ammo_in_inv
function spawn_item_in_inv(spawn_item,npc)
  if npc==nil then
    npc=Actor
  end
  return AI:create(spawn_item,
      npc:position(),
      npc:level_vertex_id(),
      npc:game_vertex_id(),
      npc:id())
end

--используем для спавна патронов
function spawn_ammo_in_inv(spawn_item,number,npc)
  if npc==nil then
    npc=Actor
  end
  if number > 0 then
    return se_respawn.create_ammo(spawn_item,
        npc:position(),
        npc:level_vertex_id(),
        npc:game_vertex_id(),
        npc:id(),
        number)
  end
end

-- удаляем объект из игры
function remove_item(remove_item)
  if remove_item~=nil then
    AI:release(AI:object(remove_item:id()), true)
    return true
  end
  return false
end

-- выбрасываем объект из инвентаря, применимо к ГГ
function drop_item(npc,item)
  if item~=nil then
--      npc:mark_item_dropped(item)
    npc:drop_item(item)
  end
end

--убиваем непися
function make_suicide(npc)
  npc:kill(npc)
end

--узнаем отношение одного непися к другому
function get_npc_relation(obj,target)
  local rel = obj:relation(target)
  local relation
  if rel==game_object.neutral then
    relation="neutral"
  elseif rel==game_object.friend then
    relation="friend"
  elseif rel==game_object.enemy then
    relation="enemy"
  else
    return false
  end
  return relation
end

--задаем отношение одного непися к другому
function set_npc_relation(obj,target,relation)
  local rel
  if relation=="neutral" then
    rel=game_object.neutral
  elseif relation=="friend" then
    rel=game_object.friend
  elseif relation=="enemy" then
    rel=game_object.enemy
  else
    return false
  end
  obj:set_relation(rel,target)
  return true
end

-- узнаем группировку непися, применимо к ГГ, только ОНЛАЙН
function get_npc_community(npc)
  return npc:character_community()
end

-- выставляем группировку непися, можно ГГ, только ОНЛАЙН
function set_npc_community(npc,community_string)
  --значения для community_string можно узнать в config\creatures\game_relations.ltx
  return npc:set_character_community(community_string, 0, 0)
end

--удаляем предмет из инвентаря по имени
function remove_item_from_inventory_by_name(remove_item_name,npc)
  return remove_item_from_inventory(npc:object(remove_item_name),npc)
end

--удаляем предмет из инвентаря
function remove_item_from_inventory(remove_item,npc)
  if npc==nil then npc=Actor end
  if remove_item~=nil then
--      npc:mark_item_dropped(remove_item)
    AI:release(AI:object(remove_item:id()), true)
    return true
  end
  return false
end

--очищаем инвентарь непися, можно ГГ, использует следующую фунцию для удаления предмета
function clear_npc_inventory(npc)
    npc:iterate_inventory(__del_item, npc)
end
function __del_item(npc, item)
    local section = item:section()

    if section == "bolt" or section == "device_torch" then
        return false
    end
--    npc:mark_item_dropped(item)
    AI:release(AI:object(item:id()), true)
end
---------------------------

--записываем переменную
save_variable = set_value
--загружаем переменную
load_variable = get_value
--удаляем переменную
del_variable = del_value

--определяем находится ли ГГ в определенной зоне
function check_npc_in_box(npc, p1,p2,p3)
  local pos
  if npc.name then pos=npc:position() else pos=npc end
  if p3==nil then
    if is_point_inside_interval(pos.x,p1.x,p2.x) and
      is_point_inside_interval(pos.y,p1.y,p2.y) and
      is_point_inside_interval(pos.z,p1.z,p2.z) then
      return true
    else
      return false
    end
  else
    local v1,v2,r,proj1,proj2,dv1,dv2
    v1=sub(p2,p1)
    v2=sub(p3,p2)
    v1.y=0
    v2.y=0
    dv1=v1:magnitude()
    dv2=v2:magnitude()
    v1:normalize()
    v2:normalize()
    r=sub(pos,p1)
    local v1p=vector():set(v1.z,0,-v1.x)
    proj2=v1p:dotproduct(r)/v1p:dotproduct(v2)
    proj1=v1:dotproduct(r)-v1:dotproduct(v2)*proj2
    if proj1>0 and proj1<dv1 and proj2>0 and proj2<dv2 and pos.y>p1.y and pos.y<p3.y then
      return true
    else
      return false
    end
  end
end

function is_point_inside_interval(x,p1,p2)
  if p1>p2 then
    p1,p2 = p2,p1
  end

  if x>p1 and x<p2 then
    return true
  else
    return false
  end
end

function sub(v1,v2)
  local newvec = vector()
  newvec.x = v1.x-v2.x
  newvec.y = v1.y-v2.y
  newvec.z = v1.z-v2.z
  return newvec
end

---------------------------------------------
--callback section
---------------------------------------------

--колбэк на взятие предмета в инвентарь ГГ
function on_item_take(obj)
gps_habar.on_item_take(obj) -- Idler ++--
    escape_dialog.have_a_art()
	flamethrower.on_item()
skunk.nano_bronik_on_take(obj)

  remove_spot_from_map(obj:id(),"red_location")
	amk_mod.check_usable_item(obj)
end

--колбэк на взятие предмета в инвентарь ГГ из ящика
function on_item_take_from_box(obj, item)
remove_spot_from_map(obj:id(),"crlc_big")
skunk.nano_bronik_on_take(obj)
gps_habar.on_item_take_from_box(obj, item) --idler++--
end

--колбэк на потерю предмета из инвентаря ГГ
function on_item_drop(obj)
gps_habar.on_item_drop(obj) --idler++--
	amk_mod.check_beacon_drop(obj)

	flamethrower.on_item()
end

-- offline - online для применения различных изменений, серверный объект на входе
function convert(sobj)
	local obj = level_object(sobj.id)
	if obj then
		if sobj:is_stalker() then
			obj:stop_talk()
		end
		convert_npc[sobj.id] = true
		switch_offline(obj)
	end
end

local next_50 = 0
local next_100 = 0
local next_1000 = 0

--колбэк на апдейт ГГ (удобно для проверки условий, так как вызывается постоянно, нельзя перегружать, а то будут лаги)
function on_actor_upade(delta)
	if next_1000 <= time_real_ms then
		oau_watchdog=100
		braad_test.check_npc_dead()
		braad_test.check_ecolog_dead()
	end

	if next_100 <= time_real_ms then
		oau_watchdog=99
		amk_mod.blowout_phantoms()
	end

	oau_watchdog=97
	amk_mod.check_metka()
	oau_watchdog=96
	amk_mod.check_hud()

	if next_50 <= time_real_ms then
		oau_watchdog=94
		amk_mod.check_armor()
		oau_watchdog=93
		amk_mod.interactive_music()
		amk_mod.firebat_ammo()

		next_50 = time_real_ms + 50
	end

	if next_1000 <= time_real_ms then
		--!!! alcohol modification by Terrapack
		oau_watchdog=931
		amk_alcohol.check_alcohol()
		oau_watchdog=92
		amk_mod.on_blowout_hit_actor(true)
	end

	local obj
	for k,v in pairs(convert_npc) do
		if AI:object(k) then
			obj=level.object_by_id(k)
			if obj==nil and v==true then
				convert_npc[k]=false
				switch_online(k)
			elseif obj and v==false then
				convert_npc[k]=nil
			elseif v==1 and obj then -- тайник не перешёл в оффлайн попытаемся его туда запихнуть.
				AI:set_switch_online(k, false)
				AI:set_switch_offline(k, true)
			elseif v==1 then -- тайник в оффлайне. выталкиваем.
				convert_npc[k]=nil
				switch_online(k)
			end
		else
			convert_npc[k]=nil
		end
	end

	if next_1000 <= time_real_ms then
		oau_watchdog=89
		amk_offline_alife.update()
		oau_watchdog=86
		wawka.update()
		oau_watchdog=85
		gps_habar.update_gps_state() --idler++--

		next_1000 = time_real_ms + 1000
	end

	if next_100 <= time_real_ms then
		oau_watchdog=84
		skunk.nano_update()

		next_100 = time_real_ms + 100
	end

	oau_watchdog=0
	oau_reason=""
end

--колбэк на создание непися (точнее на его переход в онлайн)
function on_npc_spawn(npc)
	news_main.on_spawn(npc)
end

function on_net_spawn(obj, is_btr)
	amk_mod.build_btrs_table(obj, is_btr)
end

--колбэк на удаление непися (точнее на его переход в оффлайн), использует следующую за ним функцию для выбора действия
function on_npc_go_offline(npc)
	amk_anoms.unreg_in_anom_manager(npc)

	if game_is_running() then
		local sobj = AI:object(npc:id())
		if sobj then
			amk_offline_alife.process_trade(sobj)
		end
	end
end

-----------------------

--колбэк на юзание объекта
function on_use(victim, who)
  if Actor and who and who:id()==0 then
		amk_mod.check_usable_item(victim)
  end
end

--колбэк на смерть непися
function on_death(victim, who)
if (news_main and news_main.on_death) then
	news_main.on_death(victim, who)
end
	amk_anoms.unreg_in_anom_manager(victim)
	amk_mod.generate_recipe(victim,who)
	amk_mod.firebated(victim, 1, nil, who, 14)
	if reap.hit_by_actor(who) == 0 then
		amk_mod.calc_adrenaline("actor_hit_enemy", victim)
	end
	amk_mod.zomby_blow(victim)
end

function on_npc_hit(obj, amount, local_direction, who, bone_index)
	amk_mod.firebated(obj, amount, local_direction, who, bone_index)
	if amount > 0 and reap.hit_by_actor(who) == 0 then
		amk_mod.calc_adrenaline("actor_hit_enemy",obj,"npc")
	end
end

function on_monster_hit(obj, amount, local_direction, who, bone_index)
	amk_mod.firebated(obj, amount, local_direction, who, bone_index)
	if amount > 0 and reap.hit_by_actor(who) == 0 then
		amk_mod.calc_adrenaline("actor_hit_enemy",obj,"monster")
	end
end

-- проверка на видимость производится раз в секунду
function enemy_see_actor(obj,typ)
	amk_mod.calc_adrenaline("enemy_see_actor",obj,typ)
end
function actor_see_enemy(obj,typ)
	amk_mod.calc_adrenaline("actor_see_enemy",obj,typ)
end

-- непись стрелял в гг
function npc_shot_actor(obj)
	amk_mod.calc_adrenaline("enemy_hit_actor",obj,"npc")
end

--загружаем все переменные, которые нужно, вызывается загрузке игры, автоматически; вручную не вызывать
function on_game_load()
	amk_alcohol.init()
	amk_mod.first_run()

--user area
	amk_mod.test_sleep_pp()
	amk_mod.check_spawn()
-----------
	gps_habar.on_game_load() --idler++--
end

-- Эта функция вызывается самой первой. Онлайновые объекты недоступны! Actor недоступен!
function on_game_start()
	init_item_use_acts()
	amk_mod.on_game_start()
end

--------------------- user function section---------------

function readvu32u8(packet)
  local v={}
  local len=packet:r_s32()
  for i=1,len,1 do
		v[#v + 1] = packet:r_u8()
  end
  return v
end

function readvu8u8(packet)
  local v={}
  for i=1,8,1 do
		v[#v + 1] = packet:r_u8()
  end
  return v
end

function readvu32u16(packet)
  local v={}
  local len=packet:r_s32()
  for i=1,len,1 do
		v[#v + 1] = packet:r_u16()
  end
  return v
end

function writevu32u8(pk,v)
  local len=#v
  pk:w_s32(len)
  for i=1,len,1 do
    pk:w_u8(v[i])
  end
end

function writevu8u8(pk,v)
  for i=1,8,1 do
    pk:w_u8(v[i])
  end
end

function writevu32u16(pk,v)
  local len=#v
  pk:w_s32(len)
  for i=1,len,1 do
    pk:w_u16(v[i])
  end
end

function parse_object_packet(ret,stpk,updpk)
  ret.gvid=stpk:r_u16()
  ret.obf32u1=stpk:r_float()
  ret.obs32u2=stpk:r_s32()
  ret.lvid=stpk:r_s32()
  ret.oflags=stpk:r_s32()
  ret.custom=stpk:r_stringZ()
  ret.sid=stpk:r_s32()
  ret.obs32u3=stpk:r_s32()
  return ret
end

function fill_object_packet(ret,stpk,updpk)
  stpk:w_u16(ret.gvid)
  stpk:w_float(ret.obf32u1)
  stpk:w_s32(ret.obs32u2)
  stpk:w_s32(ret.lvid)
  stpk:w_s32(ret.oflags)
  stpk:w_stringZ(ret.custom)
  stpk:w_s32(ret.sid)
  stpk:w_s32(ret.obs32u3)
end

function parse_visual_packet(ret,stpk,updpk)
  ret.visual=stpk:r_stringZ()
  ret.vsu8u1=stpk:r_u8()
  return ret
end

function fill_visual_packet(ret,stpk,updpk)
  stpk:w_stringZ(ret.visual)
  stpk:w_u8(ret.vsu8u1)
end

function parse_dynamic_object_visual(ret,stpk,updpk)
  parse_object_packet(ret,stpk,updpk)
  parse_visual_packet(ret,stpk,updpk)
  return ret
end

function fill_dynamic_object_visual(ret,stpk,updpk)
  fill_object_packet(ret,stpk,updpk)
  fill_visual_packet(ret,stpk,updpk)
end

function parse_creature_packet(ret,stpk,updpk)
  parse_dynamic_object_visual(ret,stpk,updpk)
  ret.team=stpk:r_u8()
  ret.squad=stpk:r_u8()
  ret.group=stpk:r_u8()
  ret.health=stpk:r_float()
  ret.crvu32u16u1=readvu32u16(stpk)
  ret.crvu32u16u2=readvu32u16(stpk)
  ret.killerid=stpk:r_u16()
  ret.game_death_time=readvu8u8(stpk)

  ret.updhealth=updpk:r_float()
  ret.upds32u1=updpk:r_s32()
  ret.updu8u2=updpk:r_u8()
  ret.updpos={} -- или поставить вектор? ладно потом
  ret.updpos.x=updpk:r_float()
  ret.updpos.y=updpk:r_float()
  ret.updpos.z=updpk:r_float()
  ret.updmodel=updpk:r_float()
  ret.upddir={}
  ret.upddir.x=updpk:r_float()
  ret.upddir.y=updpk:r_float()
  ret.upddir.z=updpk:r_float()
  ret.updteam=updpk:r_u8()
  ret.updsquad=updpk:r_u8()
  ret.updgroup=updpk:r_u8()
  return ret
end

function fill_creature_packet(ret,stpk,updpk)
  fill_dynamic_object_visual(ret,stpk,updpk)
  stpk:w_u8(ret.team)
  stpk:w_u8(ret.squad)
  stpk:w_u8(ret.group)
  stpk:w_float(ret.health)
  writevu32u16(stpk,ret.crvu32u16u1)
  writevu32u16(stpk,ret.crvu32u16u2)
  stpk:w_u16(ret.killerid)
  writevu8u8(stpk,ret.game_death_time)

  updpk:w_float(ret.updhealth)
  updpk:w_s32(ret.upds32u1)
  updpk:w_u8(ret.updu8u2)
  updpk:w_float(ret.updpos.x)
  updpk:w_float(ret.updpos.y)
  updpk:w_float(ret.updpos.z)
  updpk:w_float(ret.updmodel)
  updpk:w_float(ret.upddir.x)
  updpk:w_float(ret.upddir.y)
  updpk:w_float(ret.upddir.z)
  updpk:w_u8(ret.updteam)
  updpk:w_u8(ret.updsquad)
  updpk:w_u8(ret.updgroup)
end

function parse_monster_packet(ret,stpk,updpk)
  parse_creature_packet(ret,stpk,updpk)
  ret.baseoutr=stpk:r_stringZ()
  ret.baseinr=stpk:r_stringZ()
  ret.smtrid=stpk:r_u16()
  ret.smtrtaskactive=stpk:r_u8()

  ret.updu16u1=updpk:r_u16()
  ret.updu16u2=updpk:r_u16()
  ret.upds32u3=updpk:r_s32()
  ret.upds32u4=updpk:r_s32()
  return ret
end

function fill_monster_packet(ret,stpk,updpk)
  fill_creature_packet(ret,stpk,updpk)
  stpk:w_stringZ(ret.baseoutr)
  stpk:w_stringZ(ret.baseinr)
  stpk:w_u16(ret.smtrid)
  stpk:w_u8(ret.smtrtaskactive)

  updpk:w_u16(ret.updu16u1)
  updpk:w_u16(ret.updu16u2)
  updpk:w_s32(ret.upds32u3)
  updpk:w_s32(ret.upds32u4)
end

function parse_trader_packet(ret,stpk,updpk)
  ret.money=stpk:r_s32()
  ret.profile=stpk:r_stringZ()
  ret.infammo=stpk:r_s32()
  ret.class=stpk:r_stringZ()
  ret.communityid=stpk:r_s32()
  ret.rank=stpk:r_s32()
  ret.reputation=stpk:r_s32()
  ret.charname=stpk:r_stringZ()
  return ret
end

function fill_trader_packet(ret,stpk,updpk)
  stpk:w_s32(ret.money)
  stpk:w_stringZ(ret.profile)
  stpk:w_s32(ret.infammo)
  stpk:w_stringZ(ret.class)
  stpk:w_s32(ret.communityid)
  stpk:w_s32(ret.rank)
  stpk:w_s32(ret.reputation)
  stpk:w_stringZ(ret.charname)
end

function parse_human_packet(ret,stpk,updpk)
  parse_trader_packet(ret,stpk,updpk)
  parse_monster_packet(ret,stpk,updpk)
  ret.huvu32u8u1=readvu32u8(stpk)
  ret.huvu32u8u2=readvu32u8(stpk)
  return ret
end

function fill_human_packet(ret,stpk,updpk)
  fill_trader_packet(ret,stpk,updpk)
  fill_monster_packet(ret,stpk,updpk)
  writevu32u8(stpk,ret.huvu32u8u1)
  writevu32u8(stpk,ret.huvu32u8u2)
end

function parse_skeleton_packet(ret,stpk,updpk)
  ret.skeleton=stpk:r_stringZ()
  ret.skeleton_flags=stpk:r_u8()
  ret.source_id=stpk:r_u16()

--  ret.updsku8u1=updpk:r_u8()
  return ret
end

function fill_skeleton_packet(ret,stpk,updpk)
  stpk:w_stringZ(ret.skeleton)
  stpk:w_u8(ret.skeleton_flags)
  stpk:w_u16(ret.source_id)

--  updpk:w_u8(ret.updsku8u1)
end

function parse_stalker_packet(ret,stpk,updpk,size)
  parse_human_packet(ret,stpk,updpk)
  parse_skeleton_packet(ret,stpk,updpk)
  ret.hellodlg=updpk:r_stringZ()
  ret.stunk1={}
  for i=stpk:r_tell(),size-1,1 do
    table.insert(ret.stunk1,stpk:r_u8())
  end
  return ret
end

function fill_stalker_packet(ret,stpk,updpk)
  fill_human_packet(ret,stpk,updpk)
  fill_skeleton_packet(ret,stpk,updpk)
  updpk:w_stringZ(ret.hellodlg)
  for i,v in ipairs(ret.stunk1) do
    stpk:w_u8(v)
  end
end

function parse_se_monster_packet(ret,stpk,updpk,size)
  parse_monster_packet(ret,stpk,updpk,size)
  parse_skeleton_packet(ret,stpk,updpk,size)
  ret.spec_obj_id=stpk:r_u16()
  ret.job_online=stpk:r_u8()
	if ret.job_online>3 then
		ret.state=true
		ret.job_online=ret.job_online-4
	else
		ret.state=false
	end
  if ret.job_online==3 then
    ret.job_online_condlist=stpk:r_stringZ()
  end
  ret.was_in_smtr=stpk:r_u8()
  ret.stunk1={}
  for i=stpk:r_tell(),size-1,1 do
    table.insert(ret.stunk1,stpk:r_u8())
  end
  return ret
end

function fill_se_monster_packet(ret,stpk,updpk)
  fill_monster_packet(ret,stpk,updpk)
  fill_skeleton_packet(ret,stpk,updpk)
  stpk:w_u16(ret.spec_obj_id)
	local st=0
	if ret.state then
		st=4
	end
  stpk:w_u8(ret.job_online+st)
  if ret.job_online==3 then
    stpk:w_stringZ(ret.job_online_condlist)
  end
  stpk:w_u8(ret.was_in_smtr)
  for i,v in ipairs(ret.stunk1) do
    stpk:w_u8(v)
  end
end

-- серверный объект на входе
function read_stalker_params(sobj)
  local stpk=net_packet()
  local uppk=net_packet()
  sobj:STATE_Write(stpk)
  sobj:UPDATE_Write(uppk)
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  stpk:r_seek(0)
  uppk:r_seek(0)
  local tbl=parse_stalker_packet({},stpk,uppk,size)
  return tbl
end

function read_monster_params(sobj)
  local stpk=net_packet()
  local uppk=net_packet()
  sobj:STATE_Write(stpk)
  sobj:UPDATE_Write(uppk)
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  stpk:r_seek(0)
  uppk:r_seek(0)
  local tbl=parse_se_monster_packet({},stpk,uppk,size)
  return tbl
end

-- таблица параметров и серверный объект на входе
function write_stalker_params(tbl,sobj,noconvert)
  local stpk=net_packet()
  local uppk=net_packet()
  fill_stalker_packet(tbl,stpk,uppk)
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  stpk:r_seek(0)
  uppk:r_seek(0)
  sobj:STATE_Read(stpk,size)
  sobj:UPDATE_Read(uppk)
  local npc=level.object_by_id(sobj.id)
  if npc and (not noconvert) then
    convert_npc[sobj.id]=true
		npc:stop_talk()
    switch_offline(npc)
  end
end

function write_monster_params(tbl,sobj)
  local stpk=net_packet()
  local uppk=net_packet()
  fill_se_monster_packet(tbl,stpk,uppk)
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  stpk:r_seek(0)
  uppk:r_seek(0)
  sobj:STATE_Read(stpk,size)
  sobj:UPDATE_Read(uppk)
end

function get_anomaly_data(sobj)
  local stpk=net_packet()
  local uppk=net_packet()
  sobj:STATE_Write(stpk)
  sobj:UPDATE_Write(uppk)
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  stpk:r_seek(0)
  uppk:r_seek(0)
  local t={}
	parse_object_packet(t,stpk,uppk,size)
  parse_shape_packet(t,stpk,uppk,size)

	t.restrictor_type = stpk:r_u8()

	t.max_power = stpk:r_float()
	t.owner_id = stpk:r_s32()
	t.enabled_time = stpk:r_s32()
	t.disabled_time = stpk:r_s32()
	t.start_time_shift = stpk:r_s32()

	t.offline_interactive_radius = stpk:r_float()
	t.artefact_spawn_count = stpk:r_u16()
	t.artefact_position_offset = stpk:r_s32()

	t.last_spawn_time_present = stpk:r_u8()

	if stpk:r_elapsed() ~= 0 then
--		abort("left=%d", stpk:r_elapsed())
	end
	return t
end

function set_anomaly_data(t,sobj)
  local stpk=net_packet()
  local uppk=net_packet()

  fill_object_packet(t,stpk,uppk)
  fill_shape_packet(t,stpk,uppk)

	stpk:w_u8(t.restrictor_type)

	stpk:w_float(t.max_power)
	stpk:w_s32(t.owner_id)
	stpk:w_s32(t.enabled_time)
	stpk:w_s32(t.disabled_time)
	stpk:w_s32(t.start_time_shift)

	stpk:w_float(t.offline_interactive_radius)
	stpk:w_u16(t.artefact_spawn_count)
	stpk:w_s32(t.artefact_position_offset)

	stpk:w_u8(t.last_spawn_time_present)

  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  stpk:r_seek(0)
  uppk:r_seek(0)
  sobj:STATE_Read(stpk,size)
  sobj:UPDATE_Read(uppk)
end

--для правильного парсинга запрещены комментарии!!!
function parse_custom_data(str)
	local t={}
	if str then
		for section, section_data in string_gmatch(str,"%s*%[([^%]]*)%]%s*([^%[%z]*)%s*") do
			section = trim(section)
			t[section]={}
			for line in string_gmatch(trim(section_data), "([^\n]*)\n*") do
				if string_find(line,"=")~=nil then
					for k, v in string_gmatch(line, "([^=]-)%s*=%s*(.*)") do
						k = trim(k)
						if k~=nil and k~='' and v~=nil then
							t[section][k]=trim(v)
						end
					end
				else
					for k, v in string_gmatch(line, "(.*)") do
						k = trim(k)
						if k~=nil and k~='' then
							t[section][k]="<<no_value>>"
						end
					end
				end
			end
		end
	end
	return t
end

function trim (s)
	return string_trim(s)
end

function gen_custom_data(tbl)
	local str=''
	for key, value in pairs(tbl) do
		str = str.."\n["..key.."]\n"
		for k, v in pairs(value) do
			if v~="<<no_value>>" then
				str=str..k.." = "..v.."\n"
			else
				str=str..k.."\n"
			end
		end
	end
	return str
end

function get_lc_data(obj)
	local packet = net_packet()
	obj:STATE_Write(packet)
	local t={}
	t.game_vertex_id = packet:r_u16()
	t.distance = packet:r_float()
	t.direct_control = packet:r_s32()
	t.level_vertex_id = packet:r_s32()
	t.object_flags = packet:r_s32()
	t.custom_data = packet:r_stringZ()
	t.story_id = packet:r_s32()
	t.spawn_story_id = packet:r_s32()

	parse_shape_packet(t,packet)

	t.restrictor_type = packet:r_u8()
	t.dest_game_vertex_id = packet:r_u16()
	t.dest_level_vertex_id = packet:r_s32()
	t.dest_position = packet:r_vec3()
	t.dest_direction = packet:r_vec3()
	t.dest_level_name = packet:r_stringZ()
	t.dest_graph_point = packet:r_stringZ()
	t.silent_mode = packet:r_u8()

	if packet:r_elapsed() ~= 0 then
		abort("left=%d", packet:r_elapsed())
	end
	return t
end

function set_lc_data(t,obj)
	local packet = net_packet()
	obj:STATE_Write(packet)
	packet:w_begin(t.game_vertex_id)
	packet:w_float(t.distance)
	packet:w_s32(t.direct_control)
	packet:w_s32(t.level_vertex_id)
	packet:w_s32(t.object_flags)
	packet:w_stringZ(t.custom_data)
	packet:w_s32(t.story_id)
	packet:w_s32(t.spawn_story_id)

	fill_shape_packet(t,packet)

	packet:w_u8(t.restrictor_type)
	packet:w_u16(t.dest_game_vertex_id)
	packet:w_s32(t.dest_level_vertex_id)
	packet:w_vec3(t.dest_position)
	packet:w_vec3(t.dest_direction)
	packet:w_stringZ(t.dest_level_name)
	packet:w_stringZ(t.dest_graph_point)
	packet:w_u8(t.silent_mode)

	packet:r_seek(0)
	obj:STATE_Read(packet, packet:w_tell())
end

function point_in_poly (pts, x,y)
	local cnt,k,j
	local ret = false
	cnt = #pts
	j = cnt
	for k = 1,cnt do
		if ((pts[k].y <=y) and (y < pts[j].y)) or ((pts[j].y <=y) and (y < pts[k].y)) then
			if (x < (pts[j].x - pts[k].x) * (y - pts[k].y) / (pts[j].y - pts[k].y) + pts[k].x) then
				ret = not ret
			end
			j = k
		end
	end
	return ret
end

function parse_object_physic_packet(ret,stpk,updpk)
	ret.physic_type=stpk:r_s32()
	ret.mass=stpk:r_float()
	ret.fixed_bones=stpk:r_stringZ()
  return ret
end

function fill_object_physic_packet(ret,stpk,updpk)
	stpk:w_s32(ret.physic_type)
	stpk:w_float(ret.mass)
	stpk:w_stringZ(ret.fixed_bones)
end

function get_breakable_data(sobj)
  local stpk=net_packet()
  local uppk=net_packet()
  sobj:STATE_Write(stpk)
  sobj:UPDATE_Write(uppk)
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  stpk:r_seek(0)
  uppk:r_seek(0)
  local t={}
	parse_object_packet(t,stpk,uppk,size)
  parse_visual_packet(t,stpk,uppk,size)
  parse_object_physic_packet(t,stpk,uppk,size)
  return t
end

function set_breakable_data(t,sobj)
  local stpk=net_packet()
  local uppk=net_packet()

  fill_object_packet(t,stpk,uppk)
  fill_visual_packet(t,stpk,uppk)
  fill_object_physic_packet(t,stpk,uppk)

  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  stpk:r_seek(0)
  uppk:r_seek(0)
  sobj:STATE_Read(stpk,size)
  sobj:UPDATE_Read(uppk)
end

function on_REspawn(obj,respawner)
	if obj and respawner then
		amk_mod.respawned(obj,respawner)
		if obj:is_monster() then
			if respawner.spawned_goes_online==true then amk_mod.switch_monster_online(obj)
			elseif respawner.spawned_goes_online==false then amk_mod.switch_monster_offline(obj)
			end
		end
	end
	if (obj) then
		if (news_main and news_main.on_spawn) then
			news_main.on_spawn(obj)
		end
	end
end

function get_spawner_data(sobj)
  local stpk=net_packet()
  local uppk=net_packet()
  sobj:STATE_Write(stpk)
  sobj:UPDATE_Write(uppk)
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  stpk:r_seek(0)
  uppk:r_seek(0)
  local t={}
	parse_object_packet(t,stpk,uppk,size)
  parse_shape_packet(t,stpk,uppk,size)

	t.restrictor_type = stpk:r_u8()
	t.spawned_obj_count = stpk:r_u8()
  return t
end

function set_spawner_data(t,sobj)
  local stpk=net_packet()
  local uppk=net_packet()

  fill_object_packet(t,stpk,uppk)
  fill_shape_packet(t,stpk,uppk)
	stpk:w_u8(t.restrictor_type)
	stpk:w_u8(t.spawned_obj_count)

  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  stpk:r_seek(0)
  uppk:r_seek(0)
  sobj:STATE_Read(stpk,size)
  sobj:UPDATE_Read(uppk)
end

function parse_shape_packet(t,stpk,uppk)
	local shape_count = stpk:r_u8()
	t.shapes={}
	for i=1,shape_count do
		local shape_type = stpk:r_u8()
		t.shapes[i]={}
		t.shapes[i].shtype=shape_type
		if shape_type == 0 then
			-- sphere
			t.shapes[i].center = stpk:r_vec3()
			t.shapes[i].radius = stpk:r_float()
		else
			-- box
			t.shapes[i].v1 = stpk:r_vec3()
			t.shapes[i].v2 = stpk:r_vec3()
			t.shapes[i].v3 = stpk:r_vec3()
			t.shapes[i].offset = stpk:r_vec3()
		end
	end
end

function fill_shape_packet(t,stpk,updpk)
	stpk:w_u8(#t.shapes)
	for i=1,#t.shapes do
		stpk:w_u8(t.shapes[i].shtype)
		if t.shapes[i].shtype == 0 then
			stpk:w_vec3(t.shapes[i].center)
			stpk:w_float(t.shapes[i].radius)
		else
			stpk:w_vec3(t.shapes[i].v1)
			stpk:w_vec3(t.shapes[i].v2)
			stpk:w_vec3(t.shapes[i].v3)
			stpk:w_vec3(t.shapes[i].offset)
		end
	end
end

function parse_ini_section_to_array(ini,section)
	return ini:key_value(section)
end

function str_explode(div,str,clear)
	return string_explode(str, div, clear)
end

function quotemeta(str)
	return (string_gsub(s, "[%^%$%(%)%%%.%[%]%*%+%-%?]", "%%%1"))
end

function add(v1,v2)
	local nv=vector()
	nv.x=v1.x+v2.x
	nv.y=v1.y+v2.y
	nv.z=v1.z+v2.z
	return nv
end

function get_restrictor_data(sobj)
  local stpk=net_packet()
  local uppk=net_packet()
  sobj:STATE_Write(stpk)
  sobj:UPDATE_Write(uppk)
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  stpk:r_seek(0)
  uppk:r_seek(0)
  local t={}
	parse_object_packet(t,stpk,uppk,size)
  parse_shape_packet(t,stpk,uppk,size)

	t.restrictor_type = stpk:r_u8()
  return t
end

function set_restrictor_data(t,sobj)
  local stpk=net_packet()
  local uppk=net_packet()

  fill_object_packet(t,stpk,uppk)
  fill_shape_packet(t,stpk,uppk)
	stpk:w_u8(t.restrictor_type)

  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  stpk:r_seek(0)
  uppk:r_seek(0)
  sobj:STATE_Read(stpk,size)
  sobj:UPDATE_Read(uppk)
end

function get_trader_data(sobj)
  local stpk=net_packet()
  local uppk=net_packet()
  sobj:STATE_Write(stpk)
  sobj:UPDATE_Write(uppk)
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  stpk:r_seek(0)
  uppk:r_seek(0)
  local t={}
	parse_object_packet(t,stpk,uppk,size)
  parse_visual_packet(t,stpk,uppk,size)
  parse_trader_packet(t,stpk,uppk,size)
  return t
end

function set_trader_data(t,sobj)
  local stpk=net_packet()
  local uppk=net_packet()

  fill_object_packet(t,stpk,uppk)
  fill_visual_packet(t,stpk,uppk)
  fill_trader_packet(t,stpk,uppk)

  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  stpk:r_seek(0)
  uppk:r_seek(0)
  sobj:STATE_Read(stpk,size)
  sobj:UPDATE_Read(uppk)
end

function get_invbox_data(sobj)
  local stpk=net_packet()
  local uppk=net_packet()
  sobj:STATE_Write(stpk)
  sobj:UPDATE_Write(uppk)
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  stpk:r_seek(0)
  uppk:r_seek(0)
  local t={}
	parse_object_packet(t,stpk,uppk,size)
  parse_visual_packet(t,stpk,uppk,size)
  return t
end

function set_invbox_data(t,sobj)
  local stpk=net_packet()
  local uppk=net_packet()

  fill_object_packet(t,stpk,uppk)
  fill_visual_packet(t,stpk,uppk)

  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  stpk:r_seek(0)
  uppk:r_seek(0)
  sobj:STATE_Read(stpk,size)
  sobj:UPDATE_Read(uppk)
end

function readvu8uN(packet,n)
  local v={}
  for i=1,n,1 do
		v[#v + 1] = packet:r_u8()
  end
  return v
end

function writevu8uN(pk,v)
  local len=#v
  --pk:w_u8(len)
  for i=1,len,1 do
    pk:w_u8(v[i])
  end
end

function parse_item_packet(ret,stpk,updpk)
	ret.condition=stpk:r_float()
	ret.updnum_items=updpk:r_u8()
  ret.updpos={} -- или поставить вектор? ладно потом
  ret.updpos.x=updpk:r_float()
  ret.updpos.y=updpk:r_float()
  ret.updpos.z=updpk:r_float()
	ret.updcse_alife_item__unk1_q8v4=readvu8uN(updpk,4)
	ret.updcse_alife_item__unk2_q8v3=readvu8uN(updpk,3)
	ret.updcse_alife_item__unk3_q8v3=readvu8uN(updpk,3)
  return ret
end

function fill_item_packet(ret,stpk,updpk)
	stpk:w_float(ret.condition)
	updpk:w_u8(ret.updnum_items)
  updpk:w_float(ret.updpos.x)
  updpk:w_float(ret.updpos.y)
  updpk:w_float(ret.updpos.z)
	readvu8uN(updpk,ret.updcse_alife_item__unk1_q8v4)
	readvu8uN(updpk,ret.updcse_alife_item__unk2_q8v3)
	readvu8uN(updpk,ret.updcse_alife_item__unk3_q8v3)
  return ret
end

function parse_item_ammo_packet(ret,stpk,updpk)
	ret.ammo_left=stpk:r_u16()
	ret.updammo_left=updpk:r_u16()
  return ret
end

function fill_item_ammo_packet(ret,stpk,updpk)
	stpk:w_u16(ret.ammo_left)
	updpk:w_u16(ret.updammo_left)
  return ret
end

function get_ammo_params(sobj)
  local stpk=net_packet()
  local uppk=net_packet()
  sobj:STATE_Write(stpk)
  sobj:UPDATE_Write(uppk)
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  stpk:r_seek(0)
  uppk:r_seek(0)
  local t={}
	parse_object_packet(t,stpk,uppk,size)
  parse_visual_packet(t,stpk,uppk,size)
  parse_item_packet(t,stpk,uppk,size)
  parse_item_ammo_packet(t,stpk,uppk,size)
  return t
end

function set_ammo_data(t,sobj)
  local stpk=net_packet()
  local uppk=net_packet()

  fill_object_packet(t,stpk,uppk)
  fill_visual_packet(t,stpk,uppk)
  fill_item_packet(t,stpk,uppk)
  fill_item_ammo_packet(t,stpk,uppk)

  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  stpk:r_seek(0)
  uppk:r_seek(0)
  sobj:STATE_Read(stpk,size)
  sobj:UPDATE_Read(uppk)
end

function cfg_get_string(ini,sect,name,def)
	if ini and ini:line_exist(sect,name) then
		return ini:r_string(sect,name)
	end
	return def
end

function get_destroyable_data(sobj)
  local stpk=net_packet()
  local uppk=net_packet()
  sobj:STATE_Write(stpk)
  sobj:UPDATE_Write(uppk)
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  stpk:r_seek(0)
  uppk:r_seek(0)
  local t={}
	parse_object_packet(t,stpk,uppk,size)
  parse_visual_packet(t,stpk,uppk,size)
  parse_skeleton_packet(t,stpk,uppk,size)
  parse_object_physic_packet(t,stpk,uppk,size)
  return t
end

function set_destroyable_data(t,sobj)
  local stpk=net_packet()
  local uppk=net_packet()

  fill_object_packet(t,stpk,uppk)
  fill_visual_packet(t,stpk,uppk)
  fill_skeleton_packet(t,stpk,uppk)
  fill_object_physic_packet(t,stpk,uppk)

  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  stpk:r_seek(0)
  uppk:r_seek(0)
  sobj:STATE_Read(stpk,size)
  sobj:UPDATE_Read(uppk)

end

--[[
copyright © xStream & Red75

MMMMMMM    MMMMM    MMMMMM  MMMMMMMMMMMMM  MMMMMMMMMMM     MMMMMMMMMMM    MMMMMM    MMMMMMM     MMMMMM
 MMMMMMM MMMMMM  MMMMMMMMMM MMMMMMMMMMMMMM MMMMMMMMMMMMMM  MMMMMMMMMMM   MMMMMMMM   MMMMMMMM   MMMMMMM
  MMMMMMMMMMMM  MMMMMMMMMMMM MMMMMMMMMMMMM  MMMMMMMMMMMMMM MMMMMMMMMMM   MMMMMMMM    MMMMMMMM MMMMMMMM
   MMMMMMMMM     MMMMMMMM MMM   MMMMMMM     MMMMMMMMMMMMMM MMMMMMM      MMMMMMMMMM   MMMMMMMMMMMMMMMMM
    MMMMMMM       MMMMMMM       MMMMMM      MMMMMMM  MMMMM MMMMMMM      MMMMMMMMMM   MMMMMMMMMMMMMMMMM
    MMMMMMMM       MMMMMMM      MMMMMM      MMMMMMM MMMM   MMMMMMMMMM  MMMM MMMMMMM  MMMMMMMMMMMMMMMMM
   MMMMMMMMMM        MMMMM      MMMMMM      MMMMMMMMMMM    MMMMMMM     MMMM  MMMMMM  MMMMMMMMMMMMMMMMM
  MMMMM  MMMMM    MMMMMMMM      MMMMMM      MMMMMMMMMMMMMM MMMMMMMMMMM MMMMMMMMMMMMM MMMMM MMMMM MMMMM
 MMMMM   MMMMMM    MMMMMM       MMMMMM      MMMMMMM MMMMM  MMMMMMMMMM MMMMMMM MMMMMM MMMM   MM   MMMM
]]
