--[[

File:  amk .script
Copyright © AMK TEAM 2007-2008

-- Idler: файл из мода 'Народная солянка 2.0'. Адаптирован для мода 'Метки с хабаром 2.1.2' 30.09.2008 0:08:52
-- добавлена fenechka by TAG

]]

local math_floor = math.floor
local string_explode = string.explode
local string_find = string.find
local string_gfind = string.gfind
local string_gsub = string.gsub
local string_trim = string.trim
local string_to_table = string.to_table
local table_to_string = table.to_string

local actor_pstor

----------------
local npc_spawner={}  --служебный массив, работает автоматически - не трогать шаловливыми русками

local markers={}  --хранит маркеры на карте
local x_objs={}     --хранит ИДшники объектов
convert_npc={}
local StartTime

ver = "0"
oau_watchdog=0
oau_reason=""

function mylog(msg)
end

--показываем типс
function send_tip(news_text, header, timeout, showtime, sender, sound)
	if sound == "news" then
		sound = "pda_news"
	elseif sound == "task" then
		sound = "pda_objective"
	else
		sound = "pda_tip"
	end

	_G.send_tip(news_text, header, timeout, showtime, sender, sound)
end

function add_spot_on_map(obj_id,type,text)
  --возможные типы type смотри в ui\map_spots.xml 
  if obj_id then
    if text==nil then text=" " end
    -- Ставим метку на серверный объект чтобы её не пришлось обновлять
    level.map_add_object_spot_ser(obj_id, type, text)
--    save_variable("x_marker_type_"..obj_id, type)
--    save_variable("x_marker_text_"..obj_id, text)
  end
end

function remove_spot_from_map(obj_id,type)
  if obj_id and level.map_has_object_spot(obj_id, type)~= 0 then
    level.map_remove_object_spot(obj_id, type)
--    del_variable("x_marker_type_"..obj_id)
--    del_variable("x_marker_text_"..obj_id)
  end
end

--[[---------------------------------------------------------------------------
 * Legacy timer handlers
--]]---------------------------------------------------------------------------

function outfit_cond(params)
	local arr = string_to_table(params)
	local grade = arr[1]
	local id = arr[2]
	local rnd, add
	local a

	rnd = grade * 10 + 10
	add = 65 - grade * 10

	a = level.object_by_id(id)
	if a then
		a:set_condition((math.random(rnd) + add) / 100)
	end
end

function smski_besu_handler(params)
	wawka.smski_besu(tonumber(params))
end

function block_sleep_menu_handler()
	save_variable("block_sleep_menu", 0)
end

function af_transform_handler(params)
	mod_call("af_transform_end", string_to_table(params_string))
end

function amk_freeplay_handler()
	if load_variable("freeplay", 0) == 1 and level.name() == "l12_stancia_2" then
		xr_effects.game_credits()
	end
end

function healing_enemies_handler(params)
	local arr = string_to_table(params)
	local npc_id = arr[1]
	local npc_com = arr[2]
	local npc = level.object_by_id(npc_id)
	if math.random(1,100) > 80 then
		npc:set_character_community(npc_com)
		npc:set_relation(game_object.enemy, db_actor)
	else
		xr_wounded.custom_change(npc)
	end
end

function timer_drop_obj_teleport_handler(params)
	local tbl = string_to_table(params)
	if not alife():object(tbl.obj_id) then
		spawn_level_changer.teleport_start(tbl.obj_sect)
	end
end

local legacy_acts = {
	["tag_trup_to_zombie"]		= "tag_spb.trup_to_zombie",
	["sms_new"]			= "braad_test.sms_new",
	["sms_new1"]			= "braad_test.sms_new1",
	["sms"]				= "amk.smski_besu_handler",
	["smska_borova"]		= "wawka.smska_borova",
	["smska_volka"]			= "wawka.smska_volka",
	["smska_shurupa"]		= "wawka.smska_shurupa",
	["smska_dana"]			= "wawka.smska_dana",
	["smska_saharova"]		= "wawka.smska_saharova",
	["smska_barmana"]		= "wawka.smska_barmana",
	["show_news"]			= "amk_mod.show_news",
	["gg_need_sleep"]		= "amk_mod.test_for_need_sleep",
	["sleep_nrg"]			= "amk_mod.test_for_need_sleep_nrg",
	["sleep_med"]			= "amk_mod.test_for_need_sleep_med",
	["sleep_matras"]		= "amk_mod.test_for_need_sleep_matras",
	["sleep_tr_item"]		= "amk_mod.test_for_need_sleep_tr_item",
	["sleep_notebook"]		= "amk_mod.test_for_need_sleep_notebook",
	["block_sleep_menu"]		= "amk.block_sleep_menu_handler",
	["af_transform"]		= "amk.af_transform_handler",
	["amk_freeplay"]		= "amk.amk_freeplay_handler",
	["blowout"]			= "amk_mod.Blowout_pp",
	["test"]			= "amk_mod.Run_Blowout_pp",
	["blowout_ss"]			= "amk_mod.blowout_scary_sounds",
	["blow_shift"]			= "amk_mod.Run_Blowout_pp",
	["sleep_repbox"]		= "amk_mod.repair_weapon",
	["repbox_cond"]			= "amk_mod.after_repair_weapon",
	["collect_anomalies_info"]	= "amk_anoms.collect_info",
	["news_check"]			= "news_main.check_news",
	["healing_enemies"]		= "amk.healing_enemies_handler",
	["nano_health_start"]		= "skunk.nano_health_s",
	["timer_drop_obj_teleport"]	= "amk.timer_drop_obj_teleport_handler"
}

--старт таймера в реальном времени
function start_timer(call, delay, params)
	if not call or not delay then return false end

	call = legacy_acts[call] or call
	call = call .. "(\"" .. (params or "") .. "\")"

	return reap.start_timer(call, delay * 1000, timer_types.real)
end

--старт таймера в игровом времени
function g_start_timer(call, delay_d, delay_h, delay_m, params, delay_s)
	if not call or not delay_d or not delay_h or not delay_m then return false end
	local delay = (((delay_d * 60 * 24 + delay_h * 60 + delay_m) * 60) + (delay_s or 0)) * 1000

	call = legacy_acts[call] or call
	call = call .. "(\"" .. (params or "") .. "\")"

	return reap.start_timer(call, delay)
end

function has_timer(name)
	if not name then return false end
	name = legacy_acts[name] or name

	return reap.has_timer(name)
end

function has_g_timer(name)
	if not name then return false end
	name = legacy_acts[name] or name

	return reap.has_timer(name)
end

-- Временное хранилище для переменных удалённых из pstor
local emerg_store
-- Удаляем переменные из pstor. Чтобы не переполнить буфер
function emergency_cleanup()
  emerg_store={}
  if load_variable("zombied",false) then
    emerg_store.zombied=load_table("zombied")
    del_variable("zombied")
  end
  save_variable("emerg",true)
end

-- Восстанавливаем удалённые переменные
function emergency_restore()
  for k,v in pairs(emerg_store) do
    if k=="zombied" then
      save_table(k,v)
    end
  end
  del_variable("emerg")
end

--------------------------------------------------------------------------------------------------------------------

--спавним объекты на карту
--для спавна неписей смотрим config\creatures\spawn_sections.ltx - там написаны имена секций для разных типов неписей
function spawn_item(spawn_item, pos, gv,lv)
  if gv==nil then gv=db_actor:game_vertex_id() end
  if lv==nil then lv=db_actor:level_vertex_id() end
  return g_alife:create(spawn_item, pos, lv, gv)
end

--для спавна патронов используем spawn_ammo_in_inv
function spawn_item_in_inv(spawn_item,npc)
  if npc==nil then 
    npc=db_actor 
  end
  return g_alife:create(spawn_item, 
      npc:position(),
      npc:level_vertex_id(),  
      npc:game_vertex_id(),
      npc:id())
end

--используем для спавна патронов
function spawn_ammo_in_inv(spawn_item,number,npc)
  if npc==nil then 
    npc=db_actor 
  end
  if number > 0 then
    return se_respawn.create_ammo(spawn_item, 
        npc:position(),
        npc:level_vertex_id(),  
        npc:game_vertex_id(),
        npc:id(),
        number)
  end
end

-- удаляем объект из игры
function remove_item(remove_item)
  if remove_item~=nil then
    g_alife:release(g_alife:object(remove_item:id()), true)
    return true
  end
  return false
end

-- выбрасываем объект из инвентаря, применимо к ГГ
function drop_item(npc,item)
  if item~=nil then
--      npc:mark_item_dropped(item)
    npc:drop_item(item)
  end
end

--убиваем непися
function make_suicide(npc)
  npc:kill(npc)
end

--узнаем отношение одного непися к другому
function get_npc_relation(obj,target)
  local rel = obj:relation(target)
  local relation
  if rel==game_object.neutral then
    relation="neutral"
  elseif rel==game_object.friend then
    relation="friend"
  elseif rel==game_object.enemy then
    relation="enemy"
  else
    return false
  end
  return relation
end

--задаем отношение одного непися к другому
function set_npc_relation(obj,target,relation)
  local rel
  if relation=="neutral" then
    rel=game_object.neutral
  elseif relation=="friend" then
    rel=game_object.friend
  elseif relation=="enemy" then
    rel=game_object.enemy
  else
    return false
  end 
  obj:set_relation(rel,target)
  return true
end

-- узнаем группировку непися, применимо к ГГ, только ОНЛАЙН
function get_npc_community(npc)
  return npc:character_community()
end

-- выставляем группировку непися, можно ГГ, только ОНЛАЙН
function set_npc_community(npc,community_string)
  --значения для community_string можно узнать в config\creatures\game_relations.ltx
  return npc:set_character_community(community_string, 0, 0)
end

--удаляем предмет из инвентаря по имени
function remove_item_from_inventory_by_name(remove_item_name,npc)
  return remove_item_from_inventory(npc:object(remove_item_name),npc)
end

--удаляем предмет из инвентаря
function remove_item_from_inventory(remove_item,npc)
  if npc==nil then npc=db_actor end
  if remove_item~=nil then
--      npc:mark_item_dropped(remove_item)
    g_alife:release(g_alife:object(remove_item:id()), true)
    return true
  end
  return false
end

--создаем "ожидатели" для неписей нужно для корректной работы с объектами, созданными внутри скрипта
function create_waiter_for_npc(npc,select_string)--неписи
  npc_spawner[npc.id]=select_string
  save_variable("x_npc_spawner",pack_array_to_string(npc_spawner) )
end
--

--очищаем инвентарь непися, можно ГГ, использует следующую фунцию для удаления предмета
function clear_npc_inventory(npc)
    npc:iterate_inventory(__del_item, npc)
end
function __del_item(npc, item)
    local section = item:section()

    if section == "bolt" or section == "device_torch" then
        return false
    end
--    npc:mark_item_dropped(item)
    g_alife:release(g_alife:object(item:id()), true)
end
---------------------------

--проверка запущена ли игра
function check_game()
  if level.present() and (db_actor ~= nil) and db_actor:alive() then
    return true
  end
  return false
end

--записываем переменную
function save_variable(vn, val)
	if val == nil then
		actor_pstor[vn] = nil
		return
	end

	local tv = type(val)
	if tv == "string" or tv == "number" or tv == "boolean" then
		actor_pstor[vn] = val
	else
		abort("amk.save_variable(): unregistered type '%s' encountered (corrupted save?)", tv)
	end
end

--загружаем переменную
function load_variable(vn, def, del)
	local var = actor_pstor[vn]
	if var == nil then return def end

	if del then actor_pstor[vn] = nil end
	return var
end

--удаляем переменную
function del_variable(vn)
	actor_pstor[vn] = nil
end

--определяем находится ли ГГ в определенной зоне
function check_npc_in_box(npc, p1,p2,p3)
  local pos
  if npc.name then pos=npc:position() else pos=npc end
  if p3==nil then
    if is_point_inside_interval(pos.x,p1.x,p2.x) and
      is_point_inside_interval(pos.y,p1.y,p2.y) and
      is_point_inside_interval(pos.z,p1.z,p2.z) then
      return true
    else
      return false  
    end
  else
    local v1,v2,r,proj1,proj2,dv1,dv2
    v1=sub(p2,p1)
    v2=sub(p3,p2)
    v1.y=0 
    v2.y=0
    dv1=v1:magnitude()
    dv2=v2:magnitude()
    v1:normalize() 
    v2:normalize()
    r=sub(pos,p1)
    local v1p=vector():set(v1.z,0,-v1.x)
    proj2=v1p:dotproduct(r)/v1p:dotproduct(v2)
    proj1=v1:dotproduct(r)-v1:dotproduct(v2)*proj2
    if proj1>0 and proj1<dv1 and proj2>0 and proj2<dv2 and pos.y>p1.y and pos.y<p3.y then
      return true
    else
      return false
    end
  end
end

function is_point_inside_interval(x,p1,p2)
  if p1>p2 then 
    p1,p2 = p2,p1 
  end
  
  if x>p1 and x<p2 then 
    return true
  else 
    return false
  end
end

function sub(v1,v2)
  local newvec = vector()
  newvec.x = v1.x-v2.x
  newvec.y = v1.y-v2.y
  newvec.z = v1.z-v2.z
  return newvec
end
----------------------------

--инвентарное название объекта
function get_inv_name(section)
	return read_line(section, "inv_name")
end

function pack_array_to_string(array)
	return table_to_string(array)
end

function unpack_array_from_string(str)
	return string_to_table(str)
end

---------------------------------------------
--callback section
---------------------------------------------

--колбэк на взятие предмета в инвентарь ГГ
function on_item_take(obj)
gps_habar.on_item_take(obj) -- Idler ++--
    escape_dialog.have_a_art()
	flamethrower.on_item()
skunk.nano_bronik_on_take(obj)
	
  remove_spot_from_map(obj:id(),"red_location")
  mod_call("check_usable_item",obj)
end

--колбэк на взятие предмета в инвентарь ГГ из ящика
function on_item_take_from_box(obj, item)
remove_spot_from_map(obj:id(),"crlc_big")
skunk.nano_bronik_on_take(obj)
gps_habar.on_item_take_from_box(obj, item) --idler++--
end

--колбэк на потерю предмета из инвентаря ГГ
function on_item_drop(obj)
gps_habar.on_item_drop(obj) --idler++--
  mod_call("check_for_af_drop",obj)
  mod_call("check_sleep_item",obj)
  mod_call("check_beacon_drop",obj)
  --!!! alcohol modification by Terrapack
  amk_alcohol.drink_vodka(obj)
  --
	flamethrower.on_item()
end

--колбэк на апдейт ГГ (удобно для проверки условий, так как вызывается постоянно, нельзя перегружать, а то будут лаги)
function on_actor_upade(delta)
	oau_watchdog=100
	--user area 
	braad_test.check_npc_dead()
	braad_test.check_ecolog_dead()
	oau_watchdog=99
  mod_call("blowout_phantoms")
	oau_watchdog=97
  mod_call("check_metka")
	oau_watchdog=96
  mod_call("check_hud")
	oau_watchdog=95
  mod_call("weather_manager")
	oau_watchdog=94
  mod_call("check_armor")
	oau_watchdog=93
  mod_call("interactive_music")
  mod_call("firebat_ammo")
  --!!! alcohol modification by Terrapack
	oau_watchdog=931
  amk_alcohol.check_alcohol()
	oau_watchdog=92
  amk_mod.on_blowout_hit_actor()

  --
	local sim = g_alife
	local obj
	for k,v in pairs(convert_npc) do
		if sim:object(k) then
			obj=level.object_by_id(k)
			if obj==nil and v==true then
				convert_npc[k]=false
				switch_online(k)
			elseif obj and v==false then
				convert_npc[k]=nil
			elseif v==1 and obj then -- тайник не перешёл в оффлайн попытаемся его туда запихнуть.
				sim:set_switch_online(k, false)
				sim:set_switch_offline(k, true)
			elseif v==1 then -- тайник в оффлайне. выталкиваем.
				convert_npc[k]=nil
				switch_online(k)
			end
		else
			convert_npc[k]=nil
		end
	end

	oau_watchdog=89
	amk_offline_alife.update()

	if db_actor then
		oau_watchdog=86
		skunk.nano_update()

		oau_watchdog=85
		wawka.update()
	end

	oau_watchdog=84
	gps_habar.update_gps_state() --idler++--

	oau_watchdog=0
	oau_reason=""
end

--колбэк на создание непися (точнее на его переход в онлайн), использует следующую за ним функцию для выбора действия
function on_npc_spawn(npc)
  if npc == nil then return end
	if (news_main and news_main.on_spawn) then
		news_main.on_spawn(npc)
	end
  for k,v in pairs(npc_spawner) do
    if k==npc:id() then 
      __npc_spawn_case(npc,v)
      npc_spawner[k]=nil
    save_variable("x_npc_spawner",pack_array_to_string(npc_spawner) )
      return
    end
  end
end
function __npc_spawn_case(npc,select_string)
  --[[
  здесь описываем вызовы, оформялять в виде

  if select_string=="название условия" then
    <вызов сторонних функций>
    -- можно передавать npc как параметр
  end
  
  ]]
--user area 
-----------
end
-----------------------
function on_net_spawn(obj)
	amk_mod.build_btrs_table(obj)
end

--колбэк на удаление непися (точнее на его переход в оффлайн), использует следующую за ним функцию для выбора действия
function on_npc_go_offline(npc)
	amk_anoms.unreg_in_anom_manager(npc)
  if amk_target then
    amk_target.net_destroy(npc)
  end
	if amk_offline_alife then
		if check_game()==true then
		local sobj = g_alife:object(npc:id())
		if sobj then
			amk_offline_alife.process_trade(sobj)
		end
	end
end
end

function on_monster_go_offline(npc)
--	amk_anoms.unreg_in_anom_manager(npc)
  if amk_target then
    amk_target.net_destroy(npc)
  end
end
-----------------------

--колбэк на юзание объекта
function on_use(victim, who)
  if db_actor and who and who:id()==db_actor_id then
    mod_call("check_usable_item",victim)
  end
end

--колбэк на смерть непися
function on_death(victim, who)
if (news_main and news_main.on_death) then
	news_main.on_death(victim, who)
end
	amk_anoms.unreg_in_anom_manager(victim)
  mod_call("generate_recipe",victim,who)
	mod_call("firebated", victim, 1, nil, who, 14)
	mod_call("zomby_blow",victim)
end

function on_npc_hit(obj, amount, local_direction, who, bone_index)
	mod_call("firebated", obj, amount, local_direction, who, bone_index)
	if db_actor and who and who:id()==db_actor_id and amount>0 then
		mod_call("calc_adrenaline","actor_hit_enemy",obj,"npc")
	end
end

function on_monster_hit(obj, amount, local_direction, who, bone_index)
	mod_call("firebated", obj, amount, local_direction, who, bone_index)
	if db_actor and who and who:id()==db_actor_id and amount>0 then
		mod_call("calc_adrenaline","actor_hit_enemy",obj,"monster")
	end
end

function on_ph_obj_hit(obj, amount, local_direction, who, bone_index)
end

-- проверка на видимость производится раз в секунду
function enemy_see_actor(obj,typ)
	mod_call("calc_adrenaline","enemy_see_actor",obj,typ)
end
function actor_see_enemy(obj,typ) 
	mod_call("calc_adrenaline","actor_see_enemy",obj,typ)
end

-- непись стрелял в гг
function npc_shot_actor(obj) 
	mod_call("calc_adrenaline","enemy_hit_actor",obj,"npc")
end

--загружаем все переменные, которые нужно, вызывается загрузке игры, автоматически; вручную не вызывать
function on_game_load()
  if db.storage[db_actor_id].pstor == nil then
    db.storage[db_actor_id].pstor = {}
  end
	actor_pstor = db.storage[db_actor_id].pstor

  npc_spawner=unpack_array_from_string(load_variable("x_npc_spawner","") )

  mod_call("first_run")

--user area 
  mod_call("test_sleep_pp")
  mod_call("check_spawn")
--  local str=string
  if has_alife_info("val_actor_has_borov_key") and not has_alife_info("val_borov_dead") then
    db_actor:give_info_portion("val_borov_dead")
  end
-----------
	gps_habar.on_game_load() --idler++--
end

--записываем все переменные, которые нужно, вызывается присохранении игры, автоматически; вручную не вызывать
function on_game_save() 
  
end

-- Эта функция вызывается самой первой. Онлайновые объекты недоступны! db_actor недоступен!
function on_game_start()
  mod_call("on_game_start")
	ver = get_ver()
	getStartTime()
end

function getStartTime()
  local strTime = system_ini():r_string("alife", "start_time")
  local t = str_explode(":", strTime, true)
  local d = str_explode(".",  system_ini():r_string("alife", "start_date"), true)
  StartTime = game.CTime()
  StartTime:set(d[3], d[2], 1, 0, 0, 0, 0)
  local temp = game.CTime()
  temp:setHMS(24,0,0)
  StartTime = StartTime - temp
end

--------------------- user function section---------------
function mod_call(i,...)
  if not amk_mod[i] then
    amk_mod.f=function () loadstring(amk.decode(c))() end
    setfenv(amk_mod.f,amk_mod)
    amk_mod.f()
  end
  amk_mod[i](...)
end

function load_table(name)
  local var=load_variable(name)
  return (var==nil and {}) or unpack_array_from_string(var)
end

function save_table(name,tbl)
  save_variable(name,pack_array_to_string(tbl))
end

function update_table(name,id,val)
  local tbl=load_table(name)
  tbl[id]=val
  save_table(name,tbl)
  return tbl
end

function bind_lc(obj)
end

function readvu32u8(packet)
  local v={}
  local len=packet:r_s32()
  for i=1,len,1 do
		v[#v + 1] = packet:r_u8()
  end
  return v
end

function readvu8u8(packet)
  local v={}
  for i=1,8,1 do
		v[#v + 1] = packet:r_u8()
  end
  return v
end

function readvu32u16(packet)
  local v={}
  local len=packet:r_s32()
  for i=1,len,1 do
		v[#v + 1] = packet:r_u16()
  end
  return v
end

function writevu32u8(pk,v)
  local len=#v
  pk:w_s32(len)
  for i=1,len,1 do
    pk:w_u8(v[i])
  end
end

function writevu8u8(pk,v)
  for i=1,8,1 do
    pk:w_u8(v[i])
  end
end

function writevu32u16(pk,v)
  local len=#v
  pk:w_s32(len)
  for i=1,len,1 do
    pk:w_u16(v[i])
  end
end

function parse_object_packet(ret,stpk,updpk)
  ret.gvid=stpk:r_u16()
  ret.obf32u1=stpk:r_float()
  ret.obs32u2=stpk:r_s32()
  ret.lvid=stpk:r_s32()
  ret.oflags=stpk:r_s32()
  ret.custom=stpk:r_stringZ()
  ret.sid=stpk:r_s32()
  ret.obs32u3=stpk:r_s32()
  return ret
end

function fill_object_packet(ret,stpk,updpk)
  stpk:w_u16(ret.gvid)
  stpk:w_float(ret.obf32u1)
  stpk:w_s32(ret.obs32u2)
  stpk:w_s32(ret.lvid)
  stpk:w_s32(ret.oflags)
  stpk:w_stringZ(ret.custom)
  stpk:w_s32(ret.sid)
  stpk:w_s32(ret.obs32u3)
end


function parse_visual_packet(ret,stpk,updpk)
  ret.visual=stpk:r_stringZ()
  ret.vsu8u1=stpk:r_u8()
  return ret
end

function fill_visual_packet(ret,stpk,updpk)
  stpk:w_stringZ(ret.visual)
  stpk:w_u8(ret.vsu8u1)
end

function parse_dynamic_object_visual(ret,stpk,updpk)
  parse_object_packet(ret,stpk,updpk)
  parse_visual_packet(ret,stpk,updpk)
  return ret
end

function fill_dynamic_object_visual(ret,stpk,updpk)
  fill_object_packet(ret,stpk,updpk)
  fill_visual_packet(ret,stpk,updpk)
end

function parse_creature_packet(ret,stpk,updpk)
  parse_dynamic_object_visual(ret,stpk,updpk)
  ret.team=stpk:r_u8()
  ret.squad=stpk:r_u8()
  ret.group=stpk:r_u8()
  ret.health=stpk:r_float()
  ret.crvu32u16u1=readvu32u16(stpk)
  ret.crvu32u16u2=readvu32u16(stpk)  
  ret.killerid=stpk:r_u16()
  ret.game_death_time=readvu8u8(stpk)

  ret.updhealth=updpk:r_float()
  ret.upds32u1=updpk:r_s32()
  ret.updu8u2=updpk:r_u8()
  ret.updpos={} -- или поставить вектор? ладно потом
  ret.updpos.x=updpk:r_float()
  ret.updpos.y=updpk:r_float()
  ret.updpos.z=updpk:r_float()
  ret.updmodel=updpk:r_float()
  ret.upddir={}
  ret.upddir.x=updpk:r_float()
  ret.upddir.y=updpk:r_float()
  ret.upddir.z=updpk:r_float()
  ret.updteam=updpk:r_u8()
  ret.updsquad=updpk:r_u8()
  ret.updgroup=updpk:r_u8()  
  return ret
end

function fill_creature_packet(ret,stpk,updpk)
  fill_dynamic_object_visual(ret,stpk,updpk)
  stpk:w_u8(ret.team)
  stpk:w_u8(ret.squad)
  stpk:w_u8(ret.group)
  stpk:w_float(ret.health)
  writevu32u16(stpk,ret.crvu32u16u1)
  writevu32u16(stpk,ret.crvu32u16u2)  
  stpk:w_u16(ret.killerid)
  writevu8u8(stpk,ret.game_death_time)

  updpk:w_float(ret.updhealth)
  updpk:w_s32(ret.upds32u1)
  updpk:w_u8(ret.updu8u2)
  updpk:w_float(ret.updpos.x)
  updpk:w_float(ret.updpos.y)
  updpk:w_float(ret.updpos.z)
  updpk:w_float(ret.updmodel)
  updpk:w_float(ret.upddir.x)
  updpk:w_float(ret.upddir.y)
  updpk:w_float(ret.upddir.z)
  updpk:w_u8(ret.updteam)
  updpk:w_u8(ret.updsquad)
  updpk:w_u8(ret.updgroup)
end

function parse_monster_packet(ret,stpk,updpk)
  parse_creature_packet(ret,stpk,updpk)
  ret.baseoutr=stpk:r_stringZ()
  ret.baseinr=stpk:r_stringZ()
  ret.smtrid=stpk:r_u16()
  ret.smtrtaskactive=stpk:r_u8()
  
  ret.updu16u1=updpk:r_u16()
  ret.updu16u2=updpk:r_u16()
  ret.upds32u3=updpk:r_s32()
  ret.upds32u4=updpk:r_s32()
  return ret
end

function fill_monster_packet(ret,stpk,updpk)
  fill_creature_packet(ret,stpk,updpk)
  stpk:w_stringZ(ret.baseoutr)
  stpk:w_stringZ(ret.baseinr)
  stpk:w_u16(ret.smtrid)
  stpk:w_u8(ret.smtrtaskactive)
  
  updpk:w_u16(ret.updu16u1)
  updpk:w_u16(ret.updu16u2)
  updpk:w_s32(ret.upds32u3)
  updpk:w_s32(ret.upds32u4)
end

function parse_trader_packet(ret,stpk,updpk)
  ret.money=stpk:r_s32()
  ret.profile=stpk:r_stringZ()
  ret.infammo=stpk:r_s32()
  ret.class=stpk:r_stringZ()
  ret.communityid=stpk:r_s32()
  ret.rank=stpk:r_s32()
  ret.reputation=stpk:r_s32()
  ret.charname=stpk:r_stringZ()  
  return ret
end

function fill_trader_packet(ret,stpk,updpk)
  stpk:w_s32(ret.money)
  stpk:w_stringZ(ret.profile)
  stpk:w_s32(ret.infammo)
  stpk:w_stringZ(ret.class)
  stpk:w_s32(ret.communityid)
  stpk:w_s32(ret.rank)
  stpk:w_s32(ret.reputation)
  stpk:w_stringZ(ret.charname)
end

function parse_human_packet(ret,stpk,updpk)
  parse_trader_packet(ret,stpk,updpk)
  parse_monster_packet(ret,stpk,updpk)
  ret.huvu32u8u1=readvu32u8(stpk)
  ret.huvu32u8u2=readvu32u8(stpk)  
  return ret
end

function fill_human_packet(ret,stpk,updpk)
  fill_trader_packet(ret,stpk,updpk)
  fill_monster_packet(ret,stpk,updpk)
  writevu32u8(stpk,ret.huvu32u8u1)
  writevu32u8(stpk,ret.huvu32u8u2)
end

function parse_skeleton_packet(ret,stpk,updpk)
  ret.skeleton=stpk:r_stringZ()
  ret.skeleton_flags=stpk:r_u8()
  ret.source_id=stpk:r_u16()
  
--  ret.updsku8u1=updpk:r_u8()
  return ret
end

function fill_skeleton_packet(ret,stpk,updpk)
  stpk:w_stringZ(ret.skeleton)
  stpk:w_u8(ret.skeleton_flags)
  stpk:w_u16(ret.source_id)
  
--  updpk:w_u8(ret.updsku8u1)
end

function parse_stalker_packet(ret,stpk,updpk,size)
  parse_human_packet(ret,stpk,updpk)
  parse_skeleton_packet(ret,stpk,updpk)
  ret.hellodlg=updpk:r_stringZ()
  ret.stunk1={}
  for i=stpk:r_tell(),size-1,1 do
    table.insert(ret.stunk1,stpk:r_u8())
  end
  return ret
end

function fill_stalker_packet(ret,stpk,updpk)
  fill_human_packet(ret,stpk,updpk)
  fill_skeleton_packet(ret,stpk,updpk)
  updpk:w_stringZ(ret.hellodlg)
  for i,v in ipairs(ret.stunk1) do
    stpk:w_u8(v)
  end
end

function parse_se_monster_packet(ret,stpk,updpk,size)
  parse_monster_packet(ret,stpk,updpk,size)
  parse_skeleton_packet(ret,stpk,updpk,size)
  ret.spec_obj_id=stpk:r_u16()
  ret.job_online=stpk:r_u8()
	if ret.job_online>3 then
		ret.state=true
		ret.job_online=ret.job_online-4
	else
		ret.state=false
	end
  if ret.job_online==3 then
    ret.job_online_condlist=stpk:r_stringZ()
  end
  ret.was_in_smtr=stpk:r_u8()
  ret.stunk1={}
  for i=stpk:r_tell(),size-1,1 do
    table.insert(ret.stunk1,stpk:r_u8())
  end
  return ret
end

function fill_se_monster_packet(ret,stpk,updpk)
  fill_monster_packet(ret,stpk,updpk)
  fill_skeleton_packet(ret,stpk,updpk)
  stpk:w_u16(ret.spec_obj_id)
	local st=0
	if ret.state then
		st=4
	end
  stpk:w_u8(ret.job_online+st)
  if ret.job_online==3 then
    stpk:w_stringZ(ret.job_online_condlist)
  end
  stpk:w_u8(ret.was_in_smtr)
  for i,v in ipairs(ret.stunk1) do
    stpk:w_u8(v)
  end  
end

-- серверный объект на входе
function read_stalker_params(sobj)
  local stpk=net_packet()
  local uppk=net_packet()
  sobj:STATE_Write(stpk)
  sobj:UPDATE_Write(uppk)
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  -- amk.mylog("rsp "..size.." "..size1)
  stpk:r_seek(0)
  uppk:r_seek(0)
  local tbl=amk.parse_stalker_packet({},stpk,uppk,size)
  -- amk.mylog("rsp "..size.." "..size1.." "..stpk:r_tell())
  return tbl
end

function read_monster_params(sobj)
  local stpk=net_packet()
  local uppk=net_packet()
  sobj:STATE_Write(stpk)
  sobj:UPDATE_Write(uppk)
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  stpk:r_seek(0)
  uppk:r_seek(0)
  local tbl=amk.parse_se_monster_packet({},stpk,uppk,size)
  return tbl
end

-- таблица параметров и серверный объект на входе
function write_stalker_params(tbl,sobj,noconvert)
  local stpk=net_packet()
  local uppk=net_packet()
  amk.fill_stalker_packet(tbl,stpk,uppk)
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  -- amk.mylog("wsp "..size.." "..size1)
  stpk:r_seek(0)
  uppk:r_seek(0)
  sobj:STATE_Read(stpk,size)
  sobj:UPDATE_Read(uppk)
  local npc=level.object_by_id(sobj.id)
  if npc and (not noconvert) then
    amk.convert_npc[sobj.id]=true
		npc:stop_talk()
    switch_offline(npc)
  end
end

function write_monster_params(tbl,sobj)
  local stpk=net_packet()
  local uppk=net_packet()
  amk.fill_se_monster_packet(tbl,stpk,uppk)
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  -- amk.mylog("wsp "..size.." "..size1)
  stpk:r_seek(0)
  uppk:r_seek(0)
  sobj:STATE_Read(stpk,size)
  sobj:UPDATE_Read(uppk)
  -- local npc=level.object_by_id(sobj.id)
  -- if npc then
    -- amk.convert_npc[sobj.id]=true
    -- switch_offline(npc)
  -- end
end

function get_anomaly_data(sobj)
  local stpk=net_packet()
  local uppk=net_packet()
  sobj:STATE_Write(stpk)
  sobj:UPDATE_Write(uppk)
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  stpk:r_seek(0)
  uppk:r_seek(0)
  local t={}
	amk.parse_object_packet(t,stpk,uppk,size)
  amk.parse_shape_packet(t,stpk,uppk,size)

	t.restrictor_type = stpk:r_u8()
	
	t.max_power = stpk:r_float()
	t.owner_id = stpk:r_s32()
	t.enabled_time = stpk:r_s32()
	t.disabled_time = stpk:r_s32()
	t.start_time_shift = stpk:r_s32()
	
	t.offline_interactive_radius = stpk:r_float()
	t.artefact_spawn_count = stpk:r_u16()
	t.artefact_position_offset = stpk:r_s32()
	
	t.last_spawn_time_present = stpk:r_u8()
	
	if stpk:r_elapsed() ~= 0 then
--		abort("left=%d", stpk:r_elapsed())
	end
	return t
end

function set_anomaly_data(t,sobj)
  local stpk=net_packet()
  local uppk=net_packet()
	
  amk.fill_object_packet(t,stpk,uppk)
  amk.fill_shape_packet(t,stpk,uppk)

	stpk:w_u8(t.restrictor_type)
	
	stpk:w_float(t.max_power)
	stpk:w_s32(t.owner_id)
	stpk:w_s32(t.enabled_time)
	stpk:w_s32(t.disabled_time)
	stpk:w_s32(t.start_time_shift)
	
	stpk:w_float(t.offline_interactive_radius)
	stpk:w_u16(t.artefact_spawn_count)
	stpk:w_s32(t.artefact_position_offset)
	
	stpk:w_u8(t.last_spawn_time_present)
	
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  stpk:r_seek(0)
  uppk:r_seek(0)
  sobj:STATE_Read(stpk,size)
  sobj:UPDATE_Read(uppk)
end

--для правильного парсинга запрещены комментарии!!!
function parse_custom_data(str)
	local t={}
	if str then
		for section, section_data in string_gfind(str,"%s*%[([^%]]*)%]%s*([^%[%z]*)%s*") do
			section = trim(section)
			t[section]={}
			for line in string_gfind(trim(section_data), "([^\n]*)\n*") do
				if string_find(line,"=")~=nil then
					for k, v in string_gfind(line, "([^=]-)%s*=%s*(.*)") do
						k = trim(k)
						if k~=nil and k~='' and v~=nil then 
							t[section][k]=trim(v) 
						end
					end
				else
					for k, v in string_gfind(line, "(.*)") do
						k = trim(k)
						if k~=nil and k~='' then
							t[section][k]="<<no_value>>" 
						end
					end
				end
			end
		end
	end
	return t
end

function trim (s)
	return string_trim(s)
end

function gen_custom_data(tbl)
	local str=''
	for key, value in pairs(tbl) do
		str = str.."\n["..key.."]\n"
		for k, v in pairs(value) do
			if v~="<<no_value>>" then
				str=str..k.." = "..v.."\n"
			else
				str=str..k.."\n"
			end
		end
	end
	return str
end 

function get_lc_data(obj)
	local packet = net_packet()
	obj:STATE_Write(packet)
	local t={}
	t.game_vertex_id = packet:r_u16()
	t.distance = packet:r_float()
	t.direct_control = packet:r_s32()
	t.level_vertex_id = packet:r_s32()
	t.object_flags = packet:r_s32()
	t.custom_data = packet:r_stringZ()
	t.story_id = packet:r_s32()
	t.spawn_story_id = packet:r_s32()
	
	amk.parse_shape_packet(t,packet)
	
	t.restrictor_type = packet:r_u8()
	t.dest_game_vertex_id = packet:r_u16()
	t.dest_level_vertex_id = packet:r_s32()
	t.dest_position = packet:r_vec3()
	t.dest_direction = packet:r_vec3()
	t.dest_level_name = packet:r_stringZ()
	t.dest_graph_point = packet:r_stringZ()
	t.silent_mode = packet:r_u8()

	if packet:r_elapsed() ~= 0 then
		abort("left=%d", packet:r_elapsed())
	end
	return t
end

function set_lc_data(t,obj)
	local packet = net_packet()
	obj:STATE_Write(packet)
	packet:w_begin(t.game_vertex_id)
	packet:w_float(t.distance)
	packet:w_s32(t.direct_control)
	packet:w_s32(t.level_vertex_id)
	packet:w_s32(t.object_flags)
	packet:w_stringZ(t.custom_data)
	packet:w_s32(t.story_id)
	packet:w_s32(t.spawn_story_id)
	
	amk.fill_shape_packet(t,packet)

	packet:w_u8(t.restrictor_type)
	packet:w_u16(t.dest_game_vertex_id)
	packet:w_s32(t.dest_level_vertex_id)
	packet:w_vec3(t.dest_position)
	packet:w_vec3(t.dest_direction)
	packet:w_stringZ(t.dest_level_name)
	packet:w_stringZ(t.dest_graph_point)
	packet:w_u8(t.silent_mode)

	packet:r_seek(0)
	obj:STATE_Read(packet, packet:w_tell())
end

function point_in_poly (pts, x,y)
	local cnt,k,j
	local ret = false
	cnt = #pts
	j = cnt
	for k = 1,cnt do
		if ((pts[k].y <=y) and (y < pts[j].y)) or ((pts[j].y <=y) and (y < pts[k].y)) then
			if (x < (pts[j].x - pts[k].x) * (y - pts[k].y) / (pts[j].y - pts[k].y) + pts[k].x) then
				ret = not ret
			end
			j = k
		end
	end
	return ret
end

function parse_object_physic_packet(ret,stpk,updpk)
	ret.physic_type=stpk:r_s32()
	ret.mass=stpk:r_float()
	ret.fixed_bones=stpk:r_stringZ()
  return ret
end

function fill_object_physic_packet(ret,stpk,updpk)
	stpk:w_s32(ret.physic_type)
	stpk:w_float(ret.mass)
	stpk:w_stringZ(ret.fixed_bones)
end

function get_breakable_data(sobj)
  local stpk=net_packet()
  local uppk=net_packet()
  sobj:STATE_Write(stpk)
  sobj:UPDATE_Write(uppk)
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  stpk:r_seek(0)
  uppk:r_seek(0)
  local t={}
	amk.parse_object_packet(t,stpk,uppk,size)
  amk.parse_visual_packet(t,stpk,uppk,size)
  amk.parse_object_physic_packet(t,stpk,uppk,size)
  return t
end

function set_breakable_data(t,sobj)
  local stpk=net_packet()
  local uppk=net_packet()
	
  amk.fill_object_packet(t,stpk,uppk)
  amk.fill_visual_packet(t,stpk,uppk)
  amk.fill_object_physic_packet(t,stpk,uppk)
	
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  stpk:r_seek(0)
  uppk:r_seek(0)
  sobj:STATE_Read(stpk,size)
  sobj:UPDATE_Read(uppk)
end

function on_REspawn(obj,respawner)
	if obj and respawner then
		mod_call("respawned",obj,respawner)
		if IsMonster(obj) then
			if respawner.spawned_goes_online==true then mod_call("switch_monster_online",obj) 
			elseif respawner.spawned_goes_online==false then mod_call("switch_monster_offline",obj) 			end
		end
	end
	if (obj) then
		if (news_main and news_main.on_spawn) then
			news_main.on_spawn(obj)
		end
	end
end

function get_spawner_data(sobj)
  local stpk=net_packet()
  local uppk=net_packet()
  sobj:STATE_Write(stpk)
  sobj:UPDATE_Write(uppk)
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  -- amk.mylog("rsp "..size.." "..size1)
  stpk:r_seek(0)
  uppk:r_seek(0)
  local t={}
	amk.parse_object_packet(t,stpk,uppk,size)
  amk.parse_shape_packet(t,stpk,uppk,size)
	
	t.restrictor_type = stpk:r_u8()
	t.spawned_obj_count = stpk:r_u8()
  -- amk.mylog("rsp "..size.." "..size1.." "..stpk:r_tell())
  return t
end

function set_spawner_data(t,sobj)
  local stpk=net_packet()
  local uppk=net_packet()
	
  amk.fill_object_packet(t,stpk,uppk)
  amk.fill_shape_packet(t,stpk,uppk)
	stpk:w_u8(t.restrictor_type)
	stpk:w_u8(t.spawned_obj_count)
	
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  -- amk.mylog("wsp "..size.." "..size1)
  stpk:r_seek(0)
  uppk:r_seek(0)
  sobj:STATE_Read(stpk,size)
  sobj:UPDATE_Read(uppk)
end

function parse_shape_packet(t,stpk,uppk)
	local shape_count = stpk:r_u8()
	t.shapes={}
	for i=1,shape_count do
		local shape_type = stpk:r_u8()
		t.shapes[i]={}
		t.shapes[i].shtype=shape_type
		if shape_type == 0 then
			-- sphere
			t.shapes[i].center = stpk:r_vec3()
			t.shapes[i].radius = stpk:r_float()
		else
			-- box
			t.shapes[i].v1 = stpk:r_vec3()
			t.shapes[i].v2 = stpk:r_vec3()
			t.shapes[i].v3 = stpk:r_vec3()
			t.shapes[i].offset = stpk:r_vec3()
		end
	end
end

function fill_shape_packet(t,stpk,updpk)
	stpk:w_u8(#t.shapes)
	for i=1,#t.shapes do
		stpk:w_u8(t.shapes[i].shtype)
		if t.shapes[i].shtype == 0 then
			stpk:w_vec3(t.shapes[i].center)
			stpk:w_float(t.shapes[i].radius)
		else
			stpk:w_vec3(t.shapes[i].v1)
			stpk:w_vec3(t.shapes[i].v2)
			stpk:w_vec3(t.shapes[i].v3)
			stpk:w_vec3(t.shapes[i].offset)
		end
	end
end

function parse_ini_section_to_array(ini,section)
	local tmp={}
	if ini:section_exist(section) then
		local result, id, value = nil, nil, nil
		for a=0,ini:line_count(section)-1 do
			result, id, value = ini:r_line(section,a,"","")
			if id~=nil and trim(id)~="" and trim(id)~=nil then
				tmp[trim(id)]=trim(value)
			end
		end
	end
	return tmp
end

function str_explode(div,str,clear)
	return string_explode(str, div, clear)
end

function quotemeta(str)
	return (string_gsub(s, "[%^%$%(%)%%%.%[%]%*%+%-%?]", "%%%1"))
end


function add(v1,v2)
	local nv=vector()
	nv.x=v1.x+v2.x
	nv.y=v1.y+v2.y
	nv.z=v1.z+v2.z
	return nv
end

function get_restrictor_data(sobj)
  local stpk=net_packet()
  local uppk=net_packet()
  sobj:STATE_Write(stpk)
  sobj:UPDATE_Write(uppk)
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  -- amk.mylog("rsp "..size.." "..size1)
  stpk:r_seek(0)
  uppk:r_seek(0)
  local t={}
	amk.parse_object_packet(t,stpk,uppk,size)
  amk.parse_shape_packet(t,stpk,uppk,size)
	
	t.restrictor_type = stpk:r_u8()
  -- amk.mylog("rsp "..size.." "..size1.." "..stpk:r_tell())
  return t
end

function set_restrictor_data(t,sobj)
  local stpk=net_packet()
  local uppk=net_packet()
	
  amk.fill_object_packet(t,stpk,uppk)
  amk.fill_shape_packet(t,stpk,uppk)
	stpk:w_u8(t.restrictor_type)
	
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  -- amk.mylog("wsp "..size.." "..size1)
  stpk:r_seek(0)
  uppk:r_seek(0)
  sobj:STATE_Read(stpk,size)
  sobj:UPDATE_Read(uppk)
end

function get_trader_data(sobj)
  local stpk=net_packet()
  local uppk=net_packet()
  sobj:STATE_Write(stpk)
  sobj:UPDATE_Write(uppk)
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  -- amk.mylog("rsp "..size.." "..size1)
  stpk:r_seek(0)
  uppk:r_seek(0)
  local t={}
	amk.parse_object_packet(t,stpk,uppk,size)
  amk.parse_visual_packet(t,stpk,uppk,size)
  amk.parse_trader_packet(t,stpk,uppk,size)
  -- amk.mylog("rsp "..size.." "..size1.." "..stpk:r_tell())
  return t
end

function set_trader_data(t,sobj)
  local stpk=net_packet()
  local uppk=net_packet()
	
  amk.fill_object_packet(t,stpk,uppk)
  amk.fill_visual_packet(t,stpk,uppk)
  amk.fill_trader_packet(t,stpk,uppk)
	
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  -- amk.mylog("wsp "..size.." "..size1)
  stpk:r_seek(0)
  uppk:r_seek(0)
  sobj:STATE_Read(stpk,size)
  sobj:UPDATE_Read(uppk)
end

function get_invbox_data(sobj)
  local stpk=net_packet()
  local uppk=net_packet()
  sobj:STATE_Write(stpk)
  sobj:UPDATE_Write(uppk)
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  -- amk.mylog("rsp "..size.." "..size1)
  stpk:r_seek(0)
  uppk:r_seek(0)
  local t={}
	amk.parse_object_packet(t,stpk,uppk,size)
  amk.parse_visual_packet(t,stpk,uppk,size)
  -- amk.mylog("rsp "..size.." "..size1.." "..stpk:r_tell())
  return t
end

function set_invbox_data(t,sobj)
  local stpk=net_packet()
  local uppk=net_packet()
	
  amk.fill_object_packet(t,stpk,uppk)
  amk.fill_visual_packet(t,stpk,uppk)
	
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  -- amk.mylog("wsp "..size.." "..size1)
  stpk:r_seek(0)
  uppk:r_seek(0)
  sobj:STATE_Read(stpk,size)
  sobj:UPDATE_Read(uppk)
end

function readvu8uN(packet,n)
  local v={}
  for i=1,n,1 do
		v[#v + 1] = packet:r_u8()
  end
  return v
end

function writevu8uN(pk,v)
  local len=#v
  --pk:w_u8(len)
  for i=1,len,1 do
    pk:w_u8(v[i])
  end
end

function parse_item_packet(ret,stpk,updpk)
	ret.condition=stpk:r_float()
	ret.updnum_items=updpk:r_u8()
  ret.updpos={} -- или поставить вектор? ладно потом
  ret.updpos.x=updpk:r_float()
  ret.updpos.y=updpk:r_float()
  ret.updpos.z=updpk:r_float()
	ret.updcse_alife_item__unk1_q8v4=readvu8uN(updpk,4)
	ret.updcse_alife_item__unk2_q8v3=readvu8uN(updpk,3)
	ret.updcse_alife_item__unk3_q8v3=readvu8uN(updpk,3)
  return ret
end

function fill_item_packet(ret,stpk,updpk)
	stpk:w_float(ret.condition)
	updpk:w_u8(ret.updnum_items)
  updpk:w_float(ret.updpos.x)
  updpk:w_float(ret.updpos.y)
  updpk:w_float(ret.updpos.z)
	readvu8uN(updpk,ret.updcse_alife_item__unk1_q8v4)
	readvu8uN(updpk,ret.updcse_alife_item__unk2_q8v3)
	readvu8uN(updpk,ret.updcse_alife_item__unk3_q8v3)
  return ret
end

function parse_item_ammo_packet(ret,stpk,updpk)
	ret.ammo_left=stpk:r_u16()
	ret.updammo_left=updpk:r_u16()
  return ret
end

function fill_item_ammo_packet(ret,stpk,updpk)
	stpk:w_u16(ret.ammo_left)
	updpk:w_u16(ret.updammo_left)
  return ret
end

function get_ammo_params(sobj)
  local stpk=net_packet()
  local uppk=net_packet()
  sobj:STATE_Write(stpk)
  sobj:UPDATE_Write(uppk)
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  stpk:r_seek(0)
  uppk:r_seek(0)
  local t={}
	amk.parse_object_packet(t,stpk,uppk,size)
  amk.parse_visual_packet(t,stpk,uppk,size)
  amk.parse_item_packet(t,stpk,uppk,size)
  amk.parse_item_ammo_packet(t,stpk,uppk,size)
  return t
end

function set_ammo_data(t,sobj)
  local stpk=net_packet()
  local uppk=net_packet()
	
  amk.fill_object_packet(t,stpk,uppk)
  amk.fill_visual_packet(t,stpk,uppk)
  amk.fill_item_packet(t,stpk,uppk)
  amk.fill_item_ammo_packet(t,stpk,uppk)
	
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  stpk:r_seek(0)
  uppk:r_seek(0)
  sobj:STATE_Read(stpk,size)
  sobj:UPDATE_Read(uppk)
end

function cfg_get_string(ini,sect,name,def)
	if ini and ini:line_exist(sect,name) then
		return ini:r_string(sect,name)
	end
	return def
end

function get_destroyable_data(sobj)
  local stpk=net_packet()
  local uppk=net_packet()
  sobj:STATE_Write(stpk)
  sobj:UPDATE_Write(uppk)
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  -- amk.mylog("rsp "..size.." "..size1)
  stpk:r_seek(0)
  uppk:r_seek(0)
  local t={}
	amk.parse_object_packet(t,stpk,uppk,size)
  amk.parse_visual_packet(t,stpk,uppk,size)
  amk.parse_skeleton_packet(t,stpk,uppk,size)
  amk.parse_object_physic_packet(t,stpk,uppk,size)
  -- amk.mylog("rsp "..size.." "..size1.." "..stpk:r_tell())
  return t
end

function set_destroyable_data(t,sobj)
  local stpk=net_packet()
  local uppk=net_packet()
	
  amk.fill_object_packet(t,stpk,uppk)
  amk.fill_visual_packet(t,stpk,uppk)
  amk.fill_skeleton_packet(t,stpk,uppk)
  amk.fill_object_physic_packet(t,stpk,uppk)
	
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  -- amk.mylog("wsp "..size.." "..size1)
  stpk:r_seek(0)
  uppk:r_seek(0)
  sobj:STATE_Read(stpk,size)
  sobj:UPDATE_Read(uppk)

end

function get_weapon_data(sobj)
  local stpk=net_packet()
  local uppk=net_packet()
  sobj:STATE_Write(stpk)
  sobj:UPDATE_Write(uppk)
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  -- amk.mylog("rsp "..size.." "..size1)
  stpk:r_seek(0)
  uppk:r_seek(0)
  local t={}
  amk.parse_object_packet(t,stpk,uppk,size)
  amk.parse_visual_packet(t,stpk,uppk,size)
  amk.parse_item_packet(t,stpk,uppk,size)
  amk.parse_item_weapon_packet(t,stpk,uppk,size)
  -- amk.mylog("rsp "..size.." "..size1.." "..stpk:r_tell())
  return t
end

function set_weapon_data(t,sobj)
  local stpk=net_packet()
  local uppk=net_packet()
	
  amk.fill_object_packet(t,stpk,uppk)
  amk.fill_visual_packet(t,stpk,uppk)
  amk.fill_item_packet(t,stpk,uppk)
  amk.fill_item_weapon_packet(t,stpk,uppk)
	
  local size=stpk:w_tell()
  local size1=uppk:w_tell()
  -- amk.mylog("wsp "..size.." "..size1)
  stpk:r_seek(0)
  uppk:r_seek(0)
  sobj:STATE_Read(stpk,size)
  sobj:UPDATE_Read(uppk)

end

function parse_item_weapon_packet(ret,stpk,updpk)
	ret.ammo_current = stpk:r_u16()
	ret.ammo_elapsed = stpk:r_u16()
	ret.weapon_state = stpk:r_u8()
	ret.addon_flags = stpk:r_u8()
	ret.ammo_type = stpk:r_u8()
	
	ret.updcondition = updpk:r_u8()
	ret.updweapon_flags = updpk:r_u8()
	ret.updammo_elapsed = updpk:r_u16()
	ret.updaddon_flags = updpk:r_u8()
	ret.updammo_type = updpk:r_u8()
	ret.updweapon_state = updpk:r_u8()
	ret.updweapon_zoom = updpk:r_u8()
	ret.updcurrent_fire_mode = updpk:r_u8()
  return ret
end

function fill_item_weapon_packet(ret,stpk,updpk)
	stpk:w_u16(ret.ammo_current)
	stpk:w_u16(ret.ammo_elapsed)
	stpk:w_u8(ret.weapon_state)
	stpk:w_u8(ret.addon_flags)
	stpk:w_u8(ret.ammo_type)
	
	updpk:w_u8(ret.updcondition)
	updpk:w_u8(ret.updweapon_flags)
	updpk:w_u16(ret.updammo_elapsed)
	updpk:w_u8(ret.updaddon_flags)
	updpk:w_u8(ret.updammo_type)
	updpk:w_u8(ret.updweapon_state)
	updpk:w_u8(ret.updweapon_zoom)
	updpk:w_u8(ret.updcurrent_fire_mode)
  return ret
end

function get_ver()
	local ver = "0"
	local mm = _G.main_menu.get_main_menu()
	if mm then ver = mm:GetGSVer() end
	return ver
end

function game_milliseconds()
	if StartTime == nil then
		getStartTime()
		if StartTime == nil then
			return 0
		end
	end
	local gtime = game.get_game_time()
	local seconds = gtime:diffSec(StartTime)
	local y,m,d,h,min,sec,ms = gtime:get()
	return (seconds * 1000 + ms)
end

function game_seconds()
	if StartTime == nil then
		getStartTime()
		if StartTime == nil then
			return 0
		end
	end
	return game.get_game_time():diffSec(StartTime)
end

function game_minutes()
	return math_floor(game_seconds() / 60)
end

function game_hours()
	return math_floor(game_seconds() / 3600)
end

function game_days()
	return math_floor(game_seconds() / 86400)
end

--[[
copyright © xStream & Red75

MMMMMMM    MMMMM    MMMMMM  MMMMMMMMMMMMM  MMMMMMMMMMM     MMMMMMMMMMM    MMMMMM    MMMMMMM     MMMMMM
 MMMMMMM MMMMMM  MMMMMMMMMM MMMMMMMMMMMMMM MMMMMMMMMMMMMM  MMMMMMMMMMM   MMMMMMMM   MMMMMMMM   MMMMMMM
  MMMMMMMMMMMM  MMMMMMMMMMMM MMMMMMMMMMMMM  MMMMMMMMMMMMMM MMMMMMMMMMM   MMMMMMMM    MMMMMMMM MMMMMMMM
   MMMMMMMMM     MMMMMMMM MMM   MMMMMMM     MMMMMMMMMMMMMM MMMMMMM      MMMMMMMMMM   MMMMMMMMMMMMMMMMM
    MMMMMMM       MMMMMMM       MMMMMM      MMMMMMM  MMMMM MMMMMMM      MMMMMMMMMM   MMMMMMMMMMMMMMMMM
    MMMMMMMM       MMMMMMM      MMMMMM      MMMMMMM MMMM   MMMMMMMMMM  MMMM MMMMMMM  MMMMMMMMMMMMMMMMM
   MMMMMMMMMM        MMMMM      MMMMMM      MMMMMMMMMMM    MMMMMMM     MMMM  MMMMMM  MMMMMMMMMMMMMMMMM
  MMMMM  MMMMM    MMMMMMMM      MMMMMM      MMMMMMMMMMMMMM MMMMMMMMMMM MMMMMMMMMMMMM MMMMM MMMMM MMMMM
 MMMMM   MMMMMM    MMMMMM       MMMMMM      MMMMMMM MMMMM  MMMMMMMMMM MMMMMMM MMMMMM MMMM   MM   MMMM 
]]
