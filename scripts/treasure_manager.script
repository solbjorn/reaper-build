--[[

File:  treasure_manager.script
author:  wtcat
modified: AMK TEAM 
Version:  3.0.0.1

--]]

-- solid_list основан на Linspiro Addon v1.1


local rare_list = {

 novice_section = {
 "wpn_beretta",
 "wpn_toz34",
 "ammo_vog-25p",
 "ammo_m209",
 "ammo_9x39_pab9",
 "ammo_9x39_ap",
 "ammo_9x39_sp5",
 "af_ameba_mica",
 "af_soul",
 "af_cristall",
 "af_gold_fish",
 "af_night_star",
 "af_electra_moonlight"
 },

 experienced_section = {
 "ammo_7.62x54_7h1",
 "ammo_7.62x54_ap",
 "ammo_7.62x54_7h14",
 "ammo_7.62x54r",
 "ammo_338_lapua",
 "ammo_16cal_skart",
 "ammo_5.7x28_ap",
 "ammo_7.62x39_ap",
 "ammo_44mag_jhp",
 "ammo_50ae_thv",
 "ammo_7.62x25_ps",
 "ammo_arbolt",
 "ammo_7.62x51"
 },

 veteran_section = {
 "af_spirit_1",        
 "af_cry_1",
 "af_babka_1",
 "af_pudd_1",
 "af_dik_1",
 "af_kol_1",
 "af_armor_1",
 "wpn_l85",
 "wpn_lr300",
 "wpn_groza"
 },

master_section = {
 "wpn_vintorez",
 "wpn_svu",
 "wpn_svd",
 "af_simbion",        
 "wpn_g36",
 "af_spirit_2",         
 "af_cry_2",
 "af_babka_2",
 "af_pudd_2",
 "af_dik_2",
 "af_kol_2",
 "af_armor_2"  
 }
}

local solid_list = {
 novice_section = {
 --Артефакты--
 "af_drops",
 "af_ameba_slime",
 "af_rusty_thorn",
 "af_electra_sparkler",
 "af_blood",
 "af_vyvert",
 "af_medusa",
 --Аммуниция--
 "grenade_rgd5",
 "ammo_16cal_buck",     
 "ammo_9x19_fmj",
 "ammo_9x19_pbp",
 "ammo_9x18_pmm",
 "ammo_12x70_buck",
 --Оружие--
 "wpn_addon_silencer",
 "wpn_mp5",
 "wpn_bm16",
 "wpn_fort",
 "wpn_pb",
 "wpn_pm",
 --Прочее--
 "bread",
 "ammo_arbolt",
 "ammo_7.62x51",
 "ammo_338_lapua",
 "ammo_357sw_jhp",
 "ammo_357sw_jfp"
 },

experienced_section = {
--Артефакты--
 "af_cristall_flower",
 "af_gravi",
 "af_mincer_meat",
 "af_electra_flash",
 "af_rusty_kristall",
 "af_ameba_slug",
 "af_fireball",
 --Аммуниция--
 "grenade_rgd5",
 "grenade_gd-05",
 "grenade_f1",     
 "ammo_5.7x28_ap",
 "ammo_7.62x39_ap",
 "ammo_5.45x39_fmj",
 "ammo_11.43x23_fmj",
 "ammo_5.56x45_ss190",
 --Пушки--
 "wpn_addon_scope",
 "wpn_mp5",
 "wpn_ak74u",
 "wpn_ak74u_m1",
 "wpn_walther",
 --Прочее--
 "ammo_7.62x51",
 "ammo_338_lapua",
 "wpn_addon_scope_susat",
 "wpn_9mm_nato_silencer",
 "wpn_addon_sil_9_p",
 "wpn_addon_grenade_launcher",
 "wpn_addon_grenade_launcher_m203"
 },

 veteran_section = {
 --Артефакты--
 "af_night_star",
 "af_gold_fish",
 "af_soul",
 "af_electra_moonlight",
 "af_rusty_sea-urchin",
 "af_ameba_mica",
 "af_cristall",
 --Аммуниция--
 "grenade_f1",
 "ammo_vog-25",     
 "ammo_m209",
 "ammo_5.45x39_ap",
 "ammo_11.43x23_hydro",
 "ammo_9x39_pab9",
 "ammo_5.56x45_ss190",
 "ammo_12x76_zhekan",
 --Пушки--
 "wpn_m1891_30",
 "wpn_m1891_30_scope",
 "wpn_p90",
 "wpn_ak47",
 "wpn_tt33_sk1",
 "wpn_ppsh41_sk2",
 "wpn_bm16_full",
 --Прочее--
 "wpn_apb_sk1",
 "wpn_aps_sk1",
 "ammo_338_lapua",
 "ammo_arbolt"
 },

 master_section = {
 --Артефакты--
 "af_dummy_glassbeads",
 "af_dummy_pellicle",
 "af_dummy_battery",
 "af_dummy_dummy",
 "af_dummy_spring",
 "af_fuzz_kolobok",
 --Аммуниция--
 "ammo_m209",
 "ammo_vog-25p",     
 "ammo_9x39_ap",
 "ammo_12x76_dart",
 "ammo_7.62x54_7h14",
 "ammo_9x39_sp5",
 "ammo_5.56x45_ap",
 "ammo_7.62x54_7h1",
 --Пушки--
 "wpn_addon_grenade_launcher_m203",
 "wpn_colt1911",
 "wpn_spas12",
 "wpn_l85",
 "wpn_lr300",
 "wpn_groza",
 "wpn_groza_m1",
 --Прочее--
 "wpn_benelli_short",
 "wpn_toz34_short",
 "ammo_357sw_jhp",
 "ammo_357sw_jfp"
 }
}

local treasure_manager = nil
local math_random = math.random
local n_rank

function parse_spawns(line)
	if line == nil then
		return {}
	end

	--' если default-ов больше, чем значений в ini, то забить недостающие последним значением из ini
	local t = se_respawn.parse_names(line)
	local n = #t
		
	local ret_table = {}
	local k = 1

	while k <= n do
		local spawn = {}
		spawn.section = t[k]
		-- Проверяем что это не последняя запись
		if t[k+1] ~= nil then
			local p = tonumber(t[k+1])
			-- проверяем что вторым числом задана вероятность, а не другая секция спавну
			if p then
				-- забиваем число
				spawn.prob = p
				k = k + 2
			else
				-- забиваем дефолт 1
				spawn.prob = 1
				k = k + 1
			end
		else
			spawn.prob = 1
			k = k + 1
		end
		ret_table[#ret_table+1] = spawn
	end
	return ret_table
end


class "CTreasure"
function CTreasure:__init()
	--' На конструкторе вычитываем LTX и создаем заготовки квестов.
	local self_ini = ini_file("misc\\treasure_manager.ltx")

	--' Итерируемся по всем настройкам фраз
	if not self_ini:section_exist("list") then
		abort("There is no section [list] in treasure_manager.ltx")
	end
	local n = self_ini:line_count("list")
	local result, id, value

	--' начальная установка
	self.treasure_info = {}

	for i=0,n-1 do
		result, id, value	= self_ini:r_line("list",i,"","")

		result = {}

		if not self_ini:section_exist(id) then -- let's do common tests only once
			abort("treasure_manager.ltx: missing [%s] section", id)
			return
		end

		if  not self_ini:line_exist(id, "target") or
			  not self_ini:line_exist(id, "name") or
			  not self_ini:line_exist(id, "description") or 
			  not self_ini:line_exist(id, "items") then
			abort("treasure_manager.ltx: section [%s] is missing target, name, description and/or items", id)
			return
		end
		result.target = self_ini:r_float(id, "target")
		result.name = self_ini:r_string(id, "name")
		result.description = self_ini:r_string(id, "description")
		result.items = parse_spawns(self_ini:r_string(id, "items"))

		value = (self_ini:line_exist(id, "community") and self_ini:r_string(id, "community")) or "stalker, bandit, dolg, freedom"
		local community = parse_names(value)
		result.community = {}
		for k,v in pairs(community) do
			result.community[v] = true
		end


		if result.items == nil then
			abort("treasure_manager: can't find 'items' in %s", id)
			return
		end

		value = (self_ini:line_exist(id, "condlist") and self_ini:r_string(id, "condlist")) or ""
		result.condlist = xr_logic.parse_condlist_q(value)
		--' Отметим тайник как новый
		result.active = false
		result.done = false

		self.treasure_info[id] = result
	end

	--' Вспомогательные таблицы для облегчения поиска
	self.treasure_by_target = {}
	for k,v in pairs(self.treasure_info) do
		self.treasure_by_target[v.target] = k
	end
end

function CTreasure:offline_give_treasure(npc)
	local res, boxlist = amk_offline_alife.give_treasure(npc)
	if res then 
		if boxlist and #boxlist > 0 then
			for iter, box_story_id in pairs(boxlist) do
				local k = self.treasure_by_target[box_story_id]
				if k ~= nil then 
					self.treasure_info[k].active = true
					self.treasure_info[k].done = true
				end
			end
		end
		return true
	end
	return false
end

--' Юзание инициатора (возможность выдать тайник)
function CTreasure:use(npc)
	--' Проверим, не вызывались ли мы уже для этого объекта. 
	local se_obj = alife():object(npc:id())
	if se_obj.treasure_processed == true then
		return
	end
	se_obj.treasure_processed = true

	--lootmoney start
	if (npc and db_actor) then
		lootmoney.lootmoney(npc)
	end
	--lootmoney end
	if self:offline_give_treasure(npc) then return end
	local rarets 
	
	if npc ~= nil then
	  n_rank = npc:character_rank()
	 else 
      n_rank = 0
	end
	
	-- если выбран редкий тип тайников, то снизим овероятность его выпадения
	if amk.load_variable("option_treasure", 0) == 2 then 
	  rarets = 97
	else 
      rarets = 90
  end
  if amk.is_debug then
    rarets=0
  end
	
	if math_random(100) < rarets then 
	  return
	end

	--' Нужно рандомно выбрать один из тайников.
	local avail = {}
	local tr_sum = 0

	for k,v in pairs(self.treasure_info) do
		if v.done == false and v.active == false and v.community[npc:character_community()] == true then
			local treasure_prob = xr_logic.pick_section_from_condlist(db_actor, npc, v.condlist)

			if treasure_prob == "" or treasure_prob == nil then
				treasure_prob = 0
			end

			if tonumber(treasure_prob) > 0 and
			v.community[npc:character_community()] == true and
			v.active == false
			then
				if tonumber(treasure_prob) == 100 then
					self:give_treasure(k)
					return
				else
					avail[#avail+1] = {k = k, prob = treasure_prob}
					tr_sum = tr_sum + treasure_prob
				end
			end
		end
	end

	if tr_sum == 0 or
		math_random(100) < 65
	then
		return
	end

	local tr_w = math_random(tr_sum)
	for k,v in pairs(avail) do
		tr_w = tr_w - v.prob
		if tr_w <= 0 then
			--' Выдать тайник
			self:give_treasure(v.k)
			break
		end
	end
end
--' Сохранение
function CTreasure:check(hide)
	--' Проверка тайников
	for k,v in pairs(self.treasure_info) do
		--' Выдать тайник
		if not v.active and not v.done then
			self:give_treasure(k, hide)
		end
	end
end
--' Выдача тайника
function CTreasure:give_treasure(k, hide)
	local v = self.treasure_info[k]
	local obj = g_alife:story_object(v.target)
	if obj ~= nil then
		--' Пометить на карте		
		local text = "%c[255,238,155,23]"..game.translate_string(v.name).."\\n"..
				"%c[default]"..game.translate_string(v.description)

        -- проверка, какой тип тайника выбран
		-- если тайник не классический и не именной, то заменим содержимое
		if amk.load_variable("option_treasure", 0) ~= 0 and self:named_treasure(v) == false then
		   v.items = self:give_item_list()
		end  
		
		--' Сгенерить вещи
		local pos, lvid, gvid, pid
		local left, box_size
		pos = obj.position
		lvid = obj.m_level_vertex_id
		gvid = obj.m_game_vertex_id
		pid = obj.id
		for kk,vv in pairs(v.items) do
			if ammo_section[vv.section] == true then
				left, box_size = vv.prob, system_ini():r_u32(vv.section, "box_size")
				while left > box_size do
					g_alife:create_ammo(vv.section, pos, lvid, gvid, pid, box_size)
					left = left - box_size
				end
				if left > 0 then
					g_alife:create_ammo(vv.section, pos, lvid, gvid, pid, left)
				end
			else
				for i=1,vv.prob do
					g_alife:create(vv.section, pos, lvid, gvid, pid)
				end
			end
		end

		if not hide then
			news_manager.send_treasure(v.name)
			level.map_add_object_spot_ser(obj.id, "treasure", text)
		end

		--' Пометим тайник как выданный
		self.treasure_info[k].active = true
		self.treasure_info[k].done = true
    -- Отправим тайник в оффлайн
    if g_alife ~= nil and obj.online then
       g_alife:set_switch_online  (obj.id, false)
       g_alife:set_switch_offline (obj.id, true)
       amk.convert_npc[obj.id]=1 -- ставим в очередь на вывод в онлайн
    end
	else
		abort("TREASURE %s, target doesnt exist", k)
	end
end
--' Снимаем отметку с тайника
function CTreasure:treasure_empty(box, box_story_id)
	if tonumber(level.map_has_object_spot(box:id(), "treasure")) > 0 then
		local k = self.treasure_by_target[box_story_id]

		if k == nil or self.treasure_info[k] == nil then 
			return
		end

		if self.treasure_info[k].active ~= false then
			xr_statistic_freeplay.get_freeplay_statistic():check_found_secrets_count()
			actor_stats.add_points("artefacts", "st_pda_secrets", 1, 1)
			amk_offline_alife.empty_treasure(box:id())
		end

		self.treasure_info[k].active = false

		-- если тайник не именной, то переведен его в онлайн для следующей выдачи
		if self:named_treasure(self.treasure_info[k]) == false then
			self.treasure_info[k].done = false
		end

		level.map_remove_object_spot(box:id(), "treasure")
	end
end
--' Сохранение
function CTreasure:save(p)
	local tmp = 65535
	p:w_u16(tmp)
	amk_offline_alife.save(p)

	--' Сохраняем размер таблицы
	local size = 0
	for k,v in pairs(self.treasure_info) do
		size = size + 1
	end
	p:w_u16(size)
	for k,v in pairs(self.treasure_info) do
		p:w_u16(v.target)
		p:w_bool(v.active)
		p:w_bool(v.done)
	end
end
--' Загрузка
function CTreasure:load(p)
	local t = p:r_u16()
	if t == 65535 then
		amk_offline_alife.load(p)
		t = p:r_u16()
	end

	for i = 1,t do
		local k = self.treasure_by_target[p:r_u16()]
		self.treasure_info[k].active = p:r_bool()
		self.treasure_info[k].done = p:r_bool()
	end
end

function CTreasure:give_item_list()

 local rank = 1
 local tabla = {}
 -- сколько наименований предметов будет в тайнике
 local i = math_random(1, 2)
 local iper = xr_statistic_freeplay.get_freeplay_statistic():get_found_secrets_ranks()
 if iper < math_random(100) then i=i-1 end
 if i == 0 then
   return xr_statistic_freeplay.get_freeplay_statistic().give_crap_item()
 end

-- считаем настройку пользователя 
 local opt = amk.load_variable("option_treasure", 0)
 
  --~ -- определим ранг непися
   if n_rank == nil then n_rank = math_random(1, 9)*100 end
   if n_rank <= 300 then
     rank = 1
	elseif n_rank <=600 then
     rank = 2
    elseif n_rank <= 900 then
     rank = 3
    else 
     rank = 4
    end	 
 --~ else
   --~ rank = 1
 --~ end


 for j = 1, i, 1 do
   local cnt = 0
   local spawn = {}
  -- определим, из какой секции брать предметы, и какие именно  
   if  opt == 1 then
		if rank == 1 then
			spawn.section = solid_list.novice_section[math_random(#solid_list.novice_section)]
		elseif rank == 2 then
			spawn.section = solid_list.experienced_section[math_random(#solid_list.experienced_section)]
		elseif rank == 3 then
			spawn.section = solid_list.veteran_section[math_random(#solid_list.veteran_section)]
		else
			spawn.section = solid_list.master_section[math_random(#solid_list.master_section)]
		end
   else
		if rank == 1 then
			spawn.section = rare_list.novice_section[math_random(#rare_list.novice_section)]
		elseif rank == 2 then
			spawn.section = rare_list.experienced_section[math_random(#rare_list.experienced_section)]
		elseif rank == 3 then
			spawn.section = rare_list.veteran_section[math_random(#rare_list.veteran_section)]
		else
			spawn.section = rare_list.master_section[math_random(#rare_list.master_section)]
		end
   end	 
  
  -- установка кол-ва предметов в зависимости от секции  
   if ammo_section[spawn.section] == true then
      local ini = system_ini()
      local num_in_box = ini:r_u32(spawn.section, "box_size")
      local h = math_random(1, 5)
	  -- патроны выдаем не штуками, а пачками
	  cnt = math_random(1, h) * num_in_box
   else
      local s = tostring(spawn.section)
	  if string.find(s, "outfit") ~= nil or string.find(s, "wpn") ~= nil then
	     cnt = 1
	  elseif string.find(s, "addon") ~= nil or string.find(s, "af") ~= nil or string.find(s, "mutant") ~= nil then
         cnt = math_random(1,2)
      else 
	     cnt = math_random(1,5)
	  end   
   end
  
  -- сохраняем инфу о текущем предмете
  spawn.prob = cnt
  tabla[#tabla + 1] = spawn
 end
 return tabla
end

-- проверка, является ли тайник именным. Если да, то его наполнение не меняется
local named_treasures = {
	["agr_secret_0000_name"]	= true, --Тайник Серого
	["bar_secret_0011_name"]	= true, --Тайник Арни
	["esc_secret_0013_name"]	= true, --Тайник Ворпала
	["gar_secret_0002_name"]	= true, --Вещи Гризли
	["gar_secret_0011_name"]	= true, --Склад группы Стрелка
	["gar_secret_0021_name"]	= true, --Рюкзак Дохляка
	["pri_secret_0003_name"]	= true, --Хабар Клыка
	["pri_secret_0004_name"]	= true, --Запасы лидера Свободы
	["rad_secret_0000_name"]	= true, --Клад Угрюмого
	["rad_secret_0004_name"]	= true, --Запас группы отчаянных
	["ros_secret_0015_name"]	= true, --Тайник Счастливчика
	["ros_secret_0018_name"]	= true, --Ящик с медикаментами
	["val_secret_0028_name"]	= true, --Тайник Борова
	["x18_secret_0000_name"]	= true, --Тайник Копченого
	["yan_secret_0011_name"]	= true, --Тайник учёного
	["agr_krysyk_secret_name"]	= true,
	["val_krysyk_secret_name"]	= true,
	["mil_borov_secret_name"]	= true,
	["esc_secret_0010_name"]	= true  --Тайник с пивом
}

function CTreasure:named_treasure(v)
	return named_treasures[v.name] or false
end

function get_treasure_manager()
	if treasure_manager == nil then
		treasure_manager = CTreasure()
	end
	return treasure_manager
end

function take_item_from_box(box, box_story_id)
	get_treasure_manager():treasure_empty(box, box_story_id)
end

function save(p)
	get_treasure_manager():save(p)
end
function load(p)
	get_treasure_manager():load(p)
end
function clear_treasure_manager()
	treasure_manager = nil
end

function CTreasure:dialog(npc)
	if npc ~= nil then
	  n_rank = npc:character_rank()
	 else 
      n_rank = 0
	end
	local avail = {}
	local tr_sum = 0
	for k,v in pairs(self.treasure_info) do
		if v.done == false and v.active == false and v.community[npc:character_community()] == true then
			local treasure_prob = xr_logic.pick_section_from_condlist(db_actor, npc, v.condlist)
			if treasure_prob == "" or treasure_prob == nil then
				treasure_prob = 0
			end
			if tonumber(treasure_prob) > 0 and
			v.community[npc:character_community()] == true and
			v.active == false
			then
				if tonumber(treasure_prob) == 100 then
					self:give_treasure(k)
				else
					avail[#avail + 1] = {k = k, prob = treasure_prob}
					tr_sum = tr_sum + treasure_prob
				end
			end
		end
	end
	if tr_sum == 0 then
		return
	end
	local tr_w = math_random(tr_sum)
	for k,v in pairs(avail) do
		tr_w = tr_w - v.prob
		if tr_w <= 0 then
			self:give_treasure(v.k)
			break
		end
	end
end
