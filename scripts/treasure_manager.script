--[[

File:  treasure_manager.script
author:  wtcat
modified: AMK TEAM
Version:  3.0.0.1

--]]

local rare_list, solid_list

function init_random_treasures()
	local ltx = ini_file("misc\\random_rewards.ltx")
	local iter

	for _, sect in ipairs({ "rare", "solid" }) do
		sect = sect .. "_list"
		this[sect] = linspiro.read_random(sect, ltx)
	end

	init_random_treasures = nil
end

-- проверка, является ли тайник именным. Если да, то его наполнение не меняется
local named_treasures = {
	["agr_secret_0000_name"]	= true, --Тайник Серого
	["bar_secret_0011_name"]	= true, --Тайник Арни
	["esc_secret_0013_name"]	= true, --Тайник Ворпала
	["gar_secret_0002_name"]	= true, --Вещи Гризли
	["gar_secret_0011_name"]	= true, --Склад группы Стрелка
	["gar_secret_0021_name"]	= true, --Рюкзак Дохляка
	["pri_secret_0003_name"]	= true, --Хабар Клыка
	["pri_secret_0004_name"]	= true, --Запасы лидера Свободы
	["rad_secret_0000_name"]	= true, --Клад Угрюмого
	["rad_secret_0004_name"]	= true, --Запас группы отчаянных
	["ros_secret_0015_name"]	= true, --Тайник Счастливчика
	["ros_secret_0018_name"]	= true, --Ящик с медикаментами
	["val_secret_0028_name"]	= true, --Тайник Борова
	["x18_secret_0000_name"]	= true, --Тайник Копченого
	["yan_secret_0011_name"]	= true, --Тайник учёного
	["agr_krysyk_secret_name"]	= true,
	["val_krysyk_secret_name"]	= true,
	["mil_borov_secret_name"]	= true,
	["esc_secret_0010_name"]	= true  --Тайник с пивом
}
local def_comms = table.tohash({ "stalker", "bandit", "dolg", "freedom", "green" })

local math_random = math.random
local xr_logic_parse_condlist = xr_logic.parse_condlist
local xr_logic_pick_section_from_condlist = xr_logic.pick_section_from_condlist

local n_rank

function parse_items(line)
	if line == nil then
		return {}
	end

	--' если default-ов больше, чем значений в ini, то забить недостающие последним значением из ini
	local t = string.parse_names(line)
	local n = #t

	local ret_table = {}
	local k = 1

	while k <= n do
		local spawn = {}
		spawn.section = t[k]
		-- Проверяем что это не последняя запись
		if t[k+1] ~= nil then
			local p = tonumber(t[k+1])
			-- проверяем что вторым числом задана вероятность, а не другая секция спавну
			if p then
				-- забиваем число
				spawn.prob = p
				k = k + 2
			else
				-- забиваем дефолт 1
				spawn.prob = 1
				k = k + 1
			end
		else
			spawn.prob = 1
			k = k + 1
		end
		ret_table[#ret_table+1] = spawn
	end
	return ret_table
end

class "CTreasure"
function CTreasure:__init()
	--' На конструкторе вычитываем LTX и создаем заготовки квестов.
	local self_ini = ini_file("misc\\treasure_manager.ltx")

	--' Итерируемся по всем настройкам фраз
	if not self_ini:section_exist("list") then
		abort("There is no section [list] in treasure_manager.ltx")
		return
	end

	--' начальная установка
	self.treasure_info = {}
	--' Вспомогательные таблицы для облегчения поиска
	self.treasure_by_target = {}

	self_ini:iterate_lines("list", function(result, id, value)
		if not self_ini:section_exist(id) then
			abort("treasure_manager.ltx: missing [%s] section", id)
			return
		end

		result = {
			target	= self_ini:r_float(id, "target"),
			name	= self_ini:r_string(id, "name"),
			named	= named_treasures[result] or false,

			--' Отметим тайник как новый
			active	= false,
			done	= false
		}

		self.treasure_info[id] = result
		self.treasure_by_target[result.target] = id
	end)

	named_treasures = nil

	self.ini = self_ini
	self.used_npc = {}
end

function CTreasure:offline_give_treasure(npc)
	local res, boxlist = amk_offline_alife.give_treasure(npc)
	if res then
		if boxlist and #boxlist > 0 then
			for iter, box_story_id in pairs(boxlist) do
				local k = self.treasure_by_target[box_story_id]
				if k ~= nil then
					self.treasure_info[k].active = true
				end
			end
		end
		return true
	end
	return false
end

--' Юзание инициатора (возможность выдать тайник)
function CTreasure:use(npc)
	local npc_id = npc:id()
	if self.used_npc[npc_id] then return end
	self.used_npc[npc_id] = true

	--' Проверим, не вызывались ли мы уже для этого объекта.
	local se_obj = server_object(npc_id)
	if se_obj.treasure_processed == true then return end
	se_obj.treasure_processed = true

	if npc:character_community() == "zombied" then return end

	--lootmoney start
	if (npc and Actor) then
		lootmoney.lootmoney(npc)
	end
	--lootmoney end
	if self:offline_give_treasure(npc) then return end
	local rarets

	-- если выбран редкий тип тайников, то снизим овероятность его выпадения
	if amk.load_variable("option_treasure", 0) == 2 then
	  rarets = 97
	else
      rarets = 90
  end

	if math_random(100) < rarets or math_random(100) < 65 then return end
	self:pick_one(npc)
end

function CTreasure:pick_one(npc)
	n_rank = npc:character_rank()

	--' Нужно рандомно выбрать один из тайников.
	local avail = {}
	local tr_sum = 0
	local treasure_prob, value

	for k,v in pairs(self.treasure_info) do
		if not (v.active or v.done) then
			if not v.community then
				value = self.ini:r_string_ex(k, "community")
				if value then
					v.community = string.parse_names(value, true)
				else
					v.community = def_comms
				end
			end

			if v.community[npc:character_community()] == true then
				if not v.condlist then
					value = self.ini:r_string_ex(k, "condlist", "")
					v.condlist = xr_logic_parse_condlist(value)
				end

				treasure_prob = xr_logic_pick_section_from_condlist(npc, v.condlist)
				treasure_prob = tonumber(treasure_prob) or 0
				if treasure_prob > 0 then
					if treasure_prob == 100 then
						self:give_treasure(k)
						return
					else
						avail[#avail + 1] = {k = k, prob = treasure_prob}
						tr_sum = tr_sum + treasure_prob
					end
				end
			end
		end
	end

	if tr_sum == 0 then return end
	table.sort(avail, function(a, b)
		return a.k < b.k
	end)

	local tr_w = math_random(tr_sum)
	for _,v in ipairs(avail) do
		tr_w = tr_w - v.prob
		if tr_w <= 0 then
			--' Выдать тайник
			self:give_treasure(v.k)
			break
		end
	end
end

--' Сохранение
function CTreasure:check(hide)
	--' Проверка тайников
	for k,v in pairs(self.treasure_info) do
		--' Выдать тайник
		if not v.active and not v.done then
			self:give_treasure(k, hide)
		end
	end
end
--' Выдача тайника
function CTreasure:give_treasure(k, hide)
	local v = self.treasure_info[k]
	local obj = story_object(v.target)
	if obj ~= nil then
        -- проверка, какой тип тайника выбран
		-- если тайник не классический и не именной, то заменим содержимое
		if amk.load_variable("option_treasure", 0) ~= 0 and v.named == false then
			v.items = self:give_item_list()
		else
			v.items = parse_items(self.ini:r_string(k, "items"))
		end

		--' Сгенерить вещи
		local pos, lvid, gvid, pid = obj.position, obj.m_level_vertex_id, obj.m_game_vertex_id, obj.id
		for kk,vv in pairs(v.items) do
			if ammo_section[vv.section] == true then
				se_respawn.create_ammo(vv.section, pos, lvid, gvid, pid, vv.prob)
			else
				for i=1,vv.prob do
					create(vv.section, pos, lvid, gvid, pid)
				end
			end
		end

		if not hide and has_map_spot(obj.id, "treasure") == 0 then
			--' Пометить на карте
			local text = "%c[255,238,155,23]" .. translate(v.name) .. "\\n" ..
				     "%c[default]" .. translate(self.ini:r_string(k, "description"))

			news_manager.send_treasure(v.name, object_level_name(obj))
			map_spot(pid, "treasure", text)
		end

		--' Пометим тайник как выданный
		v.active = true
		-- Отправим тайник в оффлайн
		if obj.online then
			AI:set_switch_online(obj.id, false)
			AI:set_switch_offline(obj.id, true)
			amk.convert_npc[obj.id] = 1 -- ставим в очередь на вывод в онлайн
		end
	else
		abort("TREASURE %s, target doesnt exist", k)
	end
end
--' Снимаем отметку с тайника
function CTreasure:treasure_empty(box, box_story_id)
	if not (tonumber(has_map_spot(box:id(), "treasure")) > 0) then return end

	local k = self.treasure_by_target[box_story_id]
	local v = k and self.treasure_info[k]
	if not v then return end

	if v.active then
		freeplay_stats:check_found_secrets_count()
		actor_stats.add_points("treasures", v.name, 1, 1)
		Actor:set_character_rank(Actor:character_rank() + 1)
		amk_offline_alife.empty_treasure(box:id())

		-- если тайник не именной, то переведен его в онлайн для следующей выдачи
		v.active = false
		v.done = v.named
	end

	del_map_spot(box:id(), "treasure")
end
--' Сохранение
function CTreasure:save(p)
	amk_offline_alife.save(p)

	--' Сохраняем размер таблицы
	local tmp = {}
	for k,v in pairs(self.treasure_info) do
		-- пишем состояние только активных тайников
		if v.active or v.done then
			tmp[#tmp + 1] = v.target
		end
	end
	p:w_u16( #tmp )
	for i = 1, #tmp do
		p:w_u16(tmp[i])
	end
end
--' Загрузка
function CTreasure:load(p)
	amk_offline_alife.load(p)

	local cnt = p:r_u16()
	local sid, k, b
	for i = 1, cnt do
		sid = p:r_u16()
		k = self.treasure_by_target[sid]
		b = has_map_spot(id_by_sid(sid), "treasure") ~= 0
		self.treasure_info[k].active = b
		self.treasure_info[k].done = not b
	end
end

function CTreasure:give_item_list()
 local rank = 1
 local tabla = {}
 -- сколько наименований предметов будет в тайнике
 local i = math_random(1, 2)
	local iper = freeplay_stats:get_found_secrets_ranks()
 if iper < math_random(100) then i=i-1 end
 if i == 0 then
		return freeplay_stats:give_crap_item()
 end

-- считаем настройку пользователя
 local opt = amk.load_variable("option_treasure", 0)

  --~ -- определим ранг непися
   if n_rank == nil then n_rank = math_random(1, 9)*100 end
   if n_rank <= 300 then
     rank = 1
	elseif n_rank <=600 then
     rank = 2
    elseif n_rank <= 900 then
     rank = 3
    else
     rank = 4
    end

	if not solid_list then init_random_treasures() end

 for j = 1, i, 1 do
   local cnt = 0
   local spawn = {}
  -- определим, из какой секции брать предметы, и какие именно
   if  opt == 1 then
		if rank == 1 then
			spawn.section = solid_list.novice_section[math_random(#solid_list.novice_section)]
		elseif rank == 2 then
			spawn.section = solid_list.experienced_section[math_random(#solid_list.experienced_section)]
		elseif rank == 3 then
			spawn.section = solid_list.veteran_section[math_random(#solid_list.veteran_section)]
		else
			spawn.section = solid_list.master_section[math_random(#solid_list.master_section)]
		end
   else
		if rank == 1 then
			spawn.section = rare_list.novice_section[math_random(#rare_list.novice_section)]
		elseif rank == 2 then
			spawn.section = rare_list.experienced_section[math_random(#rare_list.experienced_section)]
		elseif rank == 3 then
			spawn.section = rare_list.veteran_section[math_random(#rare_list.veteran_section)]
		else
			spawn.section = rare_list.master_section[math_random(#rare_list.master_section)]
		end
   end

  -- установка кол-ва предметов в зависимости от секции
   if ammo_section[spawn.section] == true then
			local num_in_box = config:r_u32_cache(spawn.section, "box_size")
      local h = math_random(1, 5)
	  -- патроны выдаем не штуками, а пачками
	  cnt = math_random(1, h) * num_in_box
   else
      local s = tostring(spawn.section)
	  if string.find(s, "outfit") ~= nil or string.find(s, "wpn") ~= nil then
	     cnt = 1
	  elseif string.find(s, "addon") ~= nil or string.find(s, "af") ~= nil or string.find(s, "mutant") ~= nil then
         cnt = math_random(1,2)
      else
	     cnt = math_random(1,5)
	  end
   end

  -- сохраняем инфу о текущем предмете
  spawn.prob = cnt
  tabla[#tabla + 1] = spawn
 end
 return tabla
end
