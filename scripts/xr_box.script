local math_ceil = math.ceil
local math_random = math.random

--' Ключем является группировка ящика. Значением является таблица, содержашая имена секций предметов.
local item_by_community = {}

--' Множители и минимаксы для выпадения вещей в зависимости от уровня
local count_by_level = {}

function init_drop_box()
	local drop_ini = ini_file("misc\\ph_box_generic.ltx")
	local string_gmatch = string.gmatch

	local community_list = {
		"def_box",
		"small_box_generic",
		"small_box_ussr",
		"small_box_nato",
		"small_box_army",
		"small_box_science",
		"big_box_generic",
		"big_box_dungeons",
		"big_box_arsenal"
	}

	--' Множители и минимаксы для выпадения вещей в зависимости от уровня
	local sect = level.name()
	if not drop_ini:section_exist(sect) then sect = "default" end

	local mul_by_level = drop_ini:key_value(sect, true)

	local t, _min, _max
	for i = 0, 3 do
		sect = "item_count_" .. i
		drop_ini:iterate_lines(sect, function(result, id, value)
			if not mul_by_level[id] or mul_by_level[id] == 0 then return end

			--' Нужно распарсить value в два значения
			t = {}
			for v in string_gmatch(value, "[%d%.%-]+") do
				t[#t+1] = tonumber(v) or 0
			end

			if #t == 0 then
				abort("Error on [drop_ini] declaration. Section [%s], line [%s]", sect, tostring(id))
				return
			end

			_min = t[1]
			_max = t[2] or _min
			if _max < _min then _max = _min end
			if _max == 0 then return end

			if not count_by_level[id] then count_by_level[id] = { } end
			count_by_level[id][i] = {
				["min"]	= _min * mul_by_level[id],
				["max"]	= _max * mul_by_level[id]
			}
		end)
	end

	local vvv
	for k,v in pairs(community_list) do
		--' Необходимо заполнить таблицу
		item_by_community[v] = {}
		drop_ini:iterate_lines(v, function(result, id, value)
			if not mul_by_level[id] or mul_by_level[id] == 0 then return end

			if not count_by_level[id] then
				abort("Error on [drop_ini] declaration. Item [%s] is configured for community [%s], but has no probability for any difficulty", id, k)
				return
			end

			vvv = tonumber(value)
			if vvv > 0 then
				item_by_community[v][id] = 1000 * vvv
			end
		end)
	end
end

class "ph_item_box"

function ph_item_box:__init(obj)
	self.obj = obj
end

function ph_item_box:spawn_items()
	local ini = self.obj:spawn_ini()
	local community = ( ini and ini:r_string_ex("drop_box", "community", "def_box") ) or "def_box"
	local items = r_items(ini, "drop_box", "items")
	if items ~= nil then
		for k,v in pairs(items) do
			create_obligatory_items(self.obj, v.section, v.count)
		end
		return
	end

	--' Доспавниваем необходимое количество итемов:
	--' Необходимо составить список объектов которые могут быть заспавнены для персонажа
	local spawn_items = item_by_community[community] or item_by_community["def_box"]

	local diff = level.get_game_difficulty()
	local count, number
	for k,v in pairs(spawn_items) do
		if v > 0 then
			--' По каждому объекту необходимо получить количество
			count = count_by_level[k][diff]
			number = math_ceil(math_random(count["min"], count["max"]))
			--' Необходимо заспавнить нужное количество.
			if number > 0 then
				create_items(self.obj, k, number, v)
			end
		end
	end
end

-- фикс проваливания вещей сквозь геометрию
function del_flag(obj)
	if not obj then return end

	local data = obj:get_netpk()
	data.object_flags = bit_and(data.object_flags, bit_not(object_flags.UsedAI_Locations))
	obj:set_netpk(data, true)

	return obj
end

--' Функция спавнит необходимое число предметов
function create_items(obj, section, number, rnd)
	local pos, lvid, gvid
	local x,y,z
	if ammo_section[section] == true then
		if math_random(1000) <= rnd then
			local left, box_size = number, config:r_u32_cache(section, "box_size")
			lvid = obj:level_vertex_id()
			gvid = obj:game_vertex_id()
			x = math_random(-30,30)/100
			z = math_random(-30,30)/100
			y = math_random(30,50)/100
			pos = obj:position():add(vector():set(x,y,z))
			while left > box_size do
				del_flag(AI:create_ammo(section, pos, lvid, gvid, 65535, box_size))
				left = left - box_size
			end
			if left > 0 then
				del_flag(AI:create_ammo(section, pos, lvid, gvid, 65535, left))
			end
		end
	else
		pos = obj:position()
		lvid = obj:level_vertex_id()
		gvid = obj:game_vertex_id()
		for i=1,number do
			--' Проверяем вероятность появить каждый объект в отдельности
			if math_random(1000) <= rnd then
				x = math_random(-30,30)/100
				z = math_random(-30,30)/100
				y = math_random(30,50)/100
				del_flag(AI:create(section, pos:add(vector():set(x,y,z)), lvid, gvid))
			end
		end
	end
end

function r_items( spawn_ini, section, line)
	if spawn_ini and spawn_ini:line_exist(section, line) then
		--' если default-ов больше, чем значений в ini, то забить недостающие последним значением из ini
		local t = spawn_ini:r_list( section, line )
		local n = #t

		local ret_table = {}
		local k = 1
		while k <= n do
			local item = {}
			item.section = t[k]
			-- Проверяем что это не последняя запись
			if t[k+1] ~= nil then
				local p = tonumber(t[k+1])
				-- проверяем что вторым числом задана вероятность, а не другая секция спавну
				if p then
					-- забиваем число
					item.count = p
					k = k + 2
				else
					-- забиваем дефолт 1
					item.count = 1
					k = k + 1
				end
			else
				item.count	 = 1
				k = k + 1
			end
			ret_table[#ret_table+1] = item
		end
		return ret_table
	end
	return nil
end

function create_obligatory_items(obj, item, count)
	local lvid = obj:level_vertex_id()
	local gvid = obj:game_vertex_id()
	local pos = obj:position()
	local x,y,z
	for i = 1,count do
		x = math_random(-30,30)/100
		z = math_random(-30,30)/100
		y = math_random(30,50)/100
		del_flag(AI:create(item, pos:add(vector():set(x,y,z)), lvid, gvid))
	end
end
