--' Ключем является группировка персонажа. Значением является таблица, содержашая имена секций предметов.
local item_by_community = {}

--' Множители и минимаксы для выпадения вещей в зависимости от уровня
local mul_by_level = {}
local count_by_level = {}

local ready = nil

local string_gfind = string.gfind

function full_init()
	local n, result, id, value
	local death_ini = ini_file("misc\\ph_box_generic.ltx")
	local community_list = { "def_box", "small_box_generic", "small_box_ussr", "small_box_nato", "small_box_army", "small_box_science", "big_box_generic", "big_box_dungeons", "big_box_arsenal"}

	for k,v in pairs(community_list) do
		--' Необходимо заполнить таблицу
		item_by_community[v] = {}
		if death_ini:section_exist(v) then
			n = death_ini:line_count(v)
			-- local id, value = "", ""
			for i=0,n-1 do
				result, id, value	= death_ini:r_line(v,i,"","")
				item_by_community[v][id] = 1000*tonumber(value)
			end
		end
	end

	--' Множители и минимаксы для выпадения вещей в зависимости от уровня
	local level_name = level.name()
	
	if not death_ini:section_exist(level_name) then
		level_name = "default"
	end

	n = death_ini:line_count(level_name)
	for i=0,n-1 do
		result, id, value	= death_ini:r_line(level_name,i,"","")
		mul_by_level[id] = tonumber(value)
	end        

	local item_count_section = "item_count_" .. level.get_game_difficulty()
	n = death_ini:line_count(item_count_section)
	for i=0,n-1 do
		result, id, value	= death_ini:r_line(item_count_section,i,"","")
		--' Нужно распарсить value в два значения
		local t = parse_nums(value)
		if t[1] == nil then
			abort("Error on [death_ini] declaration. Section [%s], line [%s]", item_count_section, tostring(id))
		end
		local min = t[1]
		local max = t[2]
		if max == nil then
			max = min
		end
		
		if mul_by_level[id] == nil then
			mul_by_level[id] = 0
		end

		min = tonumber(min) * mul_by_level[id]
		max = tonumber(max) * mul_by_level[id]

		count_by_level[id] = {min = min, max = max}
	end        
end

local math_random = math.random

class "ph_item_box"

function ph_item_box:__init(obj)
	self.obj = obj
	if not ready then
		full_init()
		ready = true
	end
end

function ph_item_box:spawn_items()
	local spawn_items = {}
	local obj = self.obj
	local ini = obj:spawn_ini()
	local community = utils.cfg_get_string(ini, "drop_box", "community", obj, false, "", "def_box")
	local items = r_items(ini, "drop_box", "items")
	if items ~= nil then
		for k,v in pairs(items) do
			create_obligatory_items(obj, v.section, v.count)
		end
	else
		--' Доспавниваем необходимое количество итемов:
		--' Необходимо составить список объектов которые могут быть заспавнены для персонажа
		spawn_items = item_by_community[community]
		--' Если комьюнити задана не верно, то ставим дефолт и срем в лог.
		if spawn_items == nil then 
			spawn_items = {}
			spawn_items = item_by_community["def_box"]
		end

		for k,v in pairs(spawn_items) do
			if v > 0 then
				--' По каждому объекту необходимо получить количество
				local number = math.ceil(math_random(count_by_level[k].min, count_by_level[k].max))
				--' Необходимо заспавнить нужное количество.
				if number > 0 then
					create_items(obj, k, number, v)
				end
			end
		end
	end
end

function get_data(obj)
	local packet = net_packet()
	local t = {}

	obj:STATE_Write(packet)
	t.game_vertex_id = packet:r_u16()
	t.distance = packet:r_float()
	t.direct_control = packet:r_s32()
	t.level_vertex_id = packet:r_s32()
	t.object_flags = packet:r_s32()

	t.elapsed = packet:r_elapsed()
	t.left = {}
	for i = 1, t.elapsed do
		t.left[i] = packet:r_u8()
	end

	return t
end

function set_data(t, obj)
	local packet = net_packet()

	packet:w_begin(t.game_vertex_id)
	packet:w_float(t.distance)
	packet:w_s32(t.direct_control)
	packet:w_s32(t.level_vertex_id)
	packet:w_s32(t.object_flags)

	for i = 1, t.elapsed do
		packet:w_u8(t.left[i])
	end

	local size = packet:w_tell()
	packet:r_seek(0)
	obj:STATE_Read(packet, size)
end

function del_flag(obj)
	if obj == nil then return nil end
	local data = get_data(obj)
	data.object_flags = bit_and(data.object_flags, bit_not(object_flags.UsedAI_Locations))
	set_data(data, obj)

	return obj
end

--' Функция спавнит необходимое число предметов
function create_items(obj, section, number, rnd)
	local pos, lvid, gvid
	local x,y,z
	if ammo_section[section] == true then
		if math_random(1000) <= rnd then
			local left, box_size = number, system_ini():r_u32(section, "box_size")
			lvid = obj:level_vertex_id()
			gvid = obj:game_vertex_id()
			x = math_random(-30,30)/100
			z = math_random(-30,30)/100
			y = math_random(30,50)/100
			pos = obj:position():add(vector():set(x,y,z))
			while left > box_size do
				del_flag(g_alife:create_ammo(section, pos, lvid, gvid, 65535, box_size))
				left = left - box_size
			end
			if left > 0 then
				del_flag(g_alife:create_ammo(section, pos, lvid, gvid, 65535, left))
			end
		end
	else
		pos = obj:position()
		lvid = obj:level_vertex_id()
		gvid = obj:game_vertex_id()
		for i=1,number do
			--' Проверяем вероятность появить каждый объект в отдельности
			if math_random(1000) <= rnd then
				x = math_random(-30,30)/100
				z = math_random(-30,30)/100
				y = math_random(30,50)/100
				del_flag(g_alife:create(section, pos:add(vector():set(x,y,z)), lvid, gvid))
			end
		end
	end
end

function parse_names( s )
	local t = {}
	for name in string_gfind( s, "([%w_%-.\\]+)%p*" ) do
		t[#t+1] = name
	end
	return t
end

function r_items( spawn_ini, section, line)
	if spawn_ini and spawn_ini:line_exist(section, line) then
		--' если default-ов больше, чем значений в ini, то забить недостающие последним значением из ini
		local t = parse_names( spawn_ini:r_string( section, line ) )
		local n = #t
		
		local ret_table = {}
		local k = 1
		while k <= n do
			local item = {}
			item.section = t[k]
			-- Проверяем что это не последняя запись
			if t[k+1] ~= nil then
				local p = tonumber(t[k+1])
				-- проверяем что вторым числом задана вероятность, а не другая секция спавну
				if p then
					-- забиваем число
					item.count = p
					k = k + 2
				else
					-- забиваем дефолт 1
					item.count = 1
					k = k + 1
				end
			else
				item.count	 = 1
				k = k + 1
			end
			ret_table[#ret_table+1] = item
		end
		return ret_table
	end
	return nil
end

function create_obligatory_items(obj, item, count)
	local lvid = obj:level_vertex_id()
	local gvid = obj:game_vertex_id()
	local pos = obj:position()
	local x,y,z
	for i = 1,count do
		x = math_random(-30,30)/100
		z = math_random(-30,30)/100
		y = math_random(30,50)/100
		del_flag(g_alife:create(item, pos:add(vector():set(x,y,z)), lvid, gvid))
	end
end
