--[[-----------------------------------------------------------------------------------------------
 File         : sa_inventory_items_mgr.script
 Description  : Различные нововведения по работе с предметами инвентаря
 Copyright    : Shadows Addon
 Author       : Ray Twitty aka Shadows
 Date         : 13.02.2014
 Last edit    : 18.02.2019
---------------------------------------------------------------------------------------------------
 * Описание нововведений
 - ограничение количества артефактов на поясе
 - управление ячейками инвентаря
 - статистика добытых артефактов
 - перепаковщик неполных пачек патронов (рюкзак и пояс)
--]]-----------------------------------------------------------------------------------------------
--[[-----------------------------------------------------------------------------------------------
 * CONSTANTS
--]]-----------------------------------------------------------------------------------------------
local max_belt_af = config:r_u32("inventory", "max_belt_af")
local af_imm_limit = { 98, 82, 66, 50 }
--[[-----------------------------------------------------------------------------------------------
 * Limit artefacts number on belt
--]]-----------------------------------------------------------------------------------------------
local curr_imms = { 0, 0, 0, 0, 0, 0, 0, 0, 0 }
local curr_belt_af = 0
---------------------------------------------------------------------------------------------------
function update_artefacts_lock_to_belt(obj)
	if not obj:is_artefact() then
		return
	end
	curr_belt_af = curr_belt_af + 1
	local byte = 580
	for i = 1, #curr_imms do
		curr_imms[i] = curr_imms[i] + (1 - obj:get_go_float(byte)) * 100
		byte = byte + 4
	end
	Actor:iterate_inventory(
		function(dummy, obj)
			if obj:is_artefact() and Actor:is_in_ruck(obj) then
				update_artefacts_belt_lock(obj)
			end
		end
	)
end
---------------------------------------------------------------------------------------------------
function update_artefacts_lock_from_belt(obj)
	if not obj:is_artefact() then
		return
	end
	curr_belt_af = curr_belt_af - 1
	local byte = 580
	for i = 1, #curr_imms do
		curr_imms[i] = curr_imms[i] - (1 - obj:get_go_float(byte)) * 100
		byte = byte + 4
	end
	Actor:iterate_inventory(
		function(dummy, obj)
			if obj:is_artefact() and Actor:is_in_ruck(obj) then
				update_artefacts_belt_lock(obj)
			end
		end
	)
end
---------------------------------------------------------------------------------------------------
function update_artefacts_belt_lock(obj)
	if not obj:is_artefact() then
		return
	end
	if curr_belt_af == max_belt_af then
		set_inventory_item_flag(obj, inventory_item_flags.belt, false)
		return
	end
	local ceil = af_imm_limit[level.get_game_difficulty() + 1] + 0.5
	local byte = 580
	for i = 1, #curr_imms do
		if curr_imms[i] ~= 0 and curr_imms[i] + (1 - obj:get_go_float(byte)) * 100 > ceil then
			set_inventory_item_flag(obj, inventory_item_flags.belt, false)
			return
		end
		byte = byte + 4
	end
	set_inventory_item_flag(obj, inventory_item_flags.belt, true)
end
--[[-----------------------------------------------------------------------------------------------
 * Control inventory cells
--]]-----------------------------------------------------------------------------------------------
function set_items_tradability_flags(cond)
	Actor:iterate_inventory(
		function(dummy, obj)
			update_item_tradability_flags(obj, cond)
		end
	)
end
---------------------------------------------------------------------------------------------------
function update_item_tradability_flags(obj, cond)
	if not cond then
		set_inventory_item_flag(obj, inventory_item_flags.always_tradable, false)
		set_inventory_item_flag(obj, inventory_item_flags.always_untradable, false)
		set_inventory_item_flag(obj, inventory_item_flags.ungroupable, false)
		set_inventory_item_flag(obj, inventory_item_flags.highlighting, false)
	elseif cond ~= true and not is_item_tradable(obj, cond) then
		set_inventory_item_flag(obj, inventory_item_flags.always_tradable, false)
		set_inventory_item_flag(obj, inventory_item_flags.always_untradable, true)
		set_inventory_item_flag(obj, inventory_item_flags.ungroupable, true)
	else
		set_inventory_item_flag(obj, inventory_item_flags.always_tradable, false)
		set_inventory_item_flag(obj, inventory_item_flags.always_untradable, false)
		if Actor:is_on_belt(obj) or (Actor:is_in_slot(obj) and not obj:is_grenade()) then
			set_inventory_item_flag(obj, inventory_item_flags.ungroupable, true)
			set_inventory_item_flag(obj, inventory_item_flags.highlighting, true)
			set_item_tradability_highlight_color(obj, tradability_highlight_colors.green)
		else
			set_inventory_item_flag(obj, inventory_item_flags.ungroupable, false)
			set_inventory_item_flag(obj, inventory_item_flags.highlighting, false)
		end
	end
end
---------------------------------------------------------------------------------------------------
function is_item_tradable(obj, cond)
	if quest_section[obj:section()] then
		return false
	end
	if obj:is_weapon() then
		return obj:condition() >= cond.weapon
	end
	if obj:is_outfit() then
		return obj:condition() >= cond.outfit
	end
	if obj:is_monster_part() then
		return obj:condition() >= cond.part
	end
	return true
end
--[[-----------------------------------------------------------------------------------------------
 * Artefacts statistic
--]]-----------------------------------------------------------------------------------------------
function artefacts_statistic(obj)
	if obj:is_artefact() then
		local se_obj = AI:object(obj:id())
		if not se_obj.already_taken then
			actor_stats.add_points("artefacts", get_inventory_item_data(obj, "inv_name"), 1, 1)
			Actor:set_character_rank(Actor:character_rank() + 1)
			se_obj.already_taken = true
		end
	end
end
--[[-----------------------------------------------------------------------------------------------
 * Repack ammo
--]]-----------------------------------------------------------------------------------------------
local ammo_sections = {}
local need_to_repack = false
---------------------------------------------------------------------------------------------------
function check_ammo(obj)
	if obj:is_ammo() then
		local section = obj:section()
		local box_size = config:r_u32_cache(section, "box_size")
		if box_size > 1 and get_ammo_data(obj, "box_size") < box_size then
			ammo_sections[section] = {}
			ammo_sections[section].box_size = box_size
			if get_item_place(obj) == item_place.ruck then
				ammo_sections[section].ruck = true
			else
				ammo_sections[section].belt = true
			end
			need_to_repack = true
		end
	end
end
---------------------------------------------------------------------------------------------------
function repack_ammo()
	if need_to_repack and not Actor:is_talking() then
		local repack = function(section, box_size, place)
			local ammo = {}
			local total_size = 0
			Actor:iterate_inventory(
				function(dummy, obj)
					if obj:section() == section and get_item_place(obj) == place then
						local current_size = get_ammo_data(obj, "box_size")
						if current_size ~= box_size then
							ammo[#ammo + 1] = obj
							total_size = total_size + current_size
						end
					end
				end
			)
			for i, v in ipairs(ammo) do
				if total_size == 0 then
					AI:release(AI:object(v:id()), true)
				elseif total_size >= box_size then
					set_ammo_data(v, "box_size", box_size)
					total_size = total_size - box_size
				else
					set_ammo_data(v, "box_size", total_size)
					total_size = 0
				end
			end
		end
		for k, v in pairs(ammo_sections) do
			if v.ruck then
				repack(k, v.box_size, item_place.ruck)
			end
			if v.belt then
				repack(k, v.box_size, item_place.belt)
			end
		end
		ammo_sections = { }
		need_to_repack = false
	end
end
