--[[-----------------------------------------------------------------------------------------------
 File         : sa_inventory_items_mgr.script
 Description  : Различные нововведения по работе с предметами инвентаря
 Copyright    : Shadows Addon
 Author       : Ray Twitty aka Shadows
 Date         : 13.02.2014
 Last edit    : 18.02.2019
---------------------------------------------------------------------------------------------------
 * Описание нововведений
 - ограничение количества артефактов на поясе
 - управление ячейками инвентаря
 - статистика добытых артефактов
 - перепаковщик неполных пачек патронов (рюкзак и пояс)
--]]-----------------------------------------------------------------------------------------------
--[[-----------------------------------------------------------------------------------------------
 * CONSTANTS
--]]-----------------------------------------------------------------------------------------------
local imm_names = {
	"burn_immunity", "shock_immunity", "strike_immunity", "wound_immunity", "radiation_immunity",
	"telepatic_immunity", "chemical_burn_immunity", "explosion_immunity", "fire_wound_immunity"
}
local max_belt_af = config:r_u32("inventory", "max_belt_af")
local af_imm_limit = { 98, 82, 66, 50 }
--[[-----------------------------------------------------------------------------------------------
 * Limit artefacts number on belt
--]]-----------------------------------------------------------------------------------------------
local curr_imms = { 0, 0, 0, 0, 0, 0, 0, 0, 0 }
local curr_belt_af = 0
---------------------------------------------------------------------------------------------------
function set_inventory_item_flag(obj, mask, value)
	local flags = obj:get_inventory_item_flags()
	flags:set(mask, value)
	obj:set_inventory_item_flags(flags)
end
---------------------------------------------------------------------------------------------------
function update_artefacts_lock_to_belt(obj)
	if not obj:is_artefact() then
		return
	end
	curr_belt_af = curr_belt_af + 1
	local imm = obj.immunities
	for i = 1, #imm_names do
		curr_imms[i] = curr_imms[i] + (1 - imm[imm_names[i]]) * 100
	end
	Actor:iterate_inventory(
		function(dummy, obj)
			if obj:is_artefact() and Actor:is_in_ruck(obj) then
				update_artefacts_belt_lock(obj)
			end
		end
	)
end
---------------------------------------------------------------------------------------------------
function update_artefacts_lock_from_belt(obj)
	if not obj:is_artefact() then
		return
	end
	curr_belt_af = curr_belt_af - 1
	local imm = obj.immunities
	for i = 1, #imm_names do
		curr_imms[i] = curr_imms[i] - (1 - imm[imm_names[i]]) * 100
	end
	Actor:iterate_inventory(
		function(dummy, obj)
			if obj:is_artefact() and Actor:is_in_ruck(obj) then
				update_artefacts_belt_lock(obj)
			end
		end
	)
end
---------------------------------------------------------------------------------------------------
function update_artefacts_belt_lock(obj)
	if not obj:is_artefact() then
		return
	end
	if curr_belt_af == max_belt_af then
		set_inventory_item_flag(obj, global_flags.Fbelt, false)
		return
	end
	local _ceil = af_imm_limit[level.get_game_difficulty() + 1] + 0.5
	local imm = obj.immunities
	for i = 1, #imm_names do
		if curr_imms[i] ~= 0 and curr_imms[i] + (1 - imm[imm_names[i]]) * 100 > _ceil then
			set_inventory_item_flag(obj, global_flags.Fbelt, false)
			return
		end
	end
	set_inventory_item_flag(obj, global_flags.Fbelt, not obj:is_capsule())
end
--[[-----------------------------------------------------------------------------------------------
 * Control inventory cells
--]]-----------------------------------------------------------------------------------------------
function set_items_tradability_flags(cond)
	Actor:iterate_inventory(
		function(dummy, obj)
			update_item_tradability_flags(obj, cond)
		end
	)
end
---------------------------------------------------------------------------------------------------
function update_item_tradability_flags(obj, cond)
	if not cond then
		set_inventory_item_flag(obj, global_flags.FIAlwaysUntradable, false)
		set_inventory_item_flag(obj, global_flags.FIUngroupable, false)
	elseif cond ~= true and not is_item_tradable(obj, cond) then
		set_inventory_item_flag(obj, global_flags.FIAlwaysUntradable, true)
		set_inventory_item_flag(obj, global_flags.FIUngroupable, true)
	else
		set_inventory_item_flag(obj, global_flags.FIAlwaysUntradable, false)
		if Actor:is_on_belt(obj) or (Actor:is_in_slot(obj) and not obj:is_grenade()) then
			set_inventory_item_flag(obj, global_flags.FIUngroupable, true)
		else
			set_inventory_item_flag(obj, global_flags.FIUngroupable, false)
		end
	end
end
---------------------------------------------------------------------------------------------------
function is_item_tradable(obj, cond)
	if quest_section[obj:section()] then
		return false
	end
	if obj:is_weapon() then
		return obj:condition() >= cond.weapon
	end
	if obj:is_outfit() then
		return obj:condition() >= cond.outfit
	end
	if obj:is_monster_part() then
		return obj:condition() >= cond.part
	end
	return true
end
--[[-----------------------------------------------------------------------------------------------
 * Artefacts statistic
--]]-----------------------------------------------------------------------------------------------
function artefacts_statistic(obj)
	if obj:is_artefact() and not obj:is_capsule() then
		local se_obj = AI:object(obj:id())
		if not se_obj.already_taken then
			actor_stats.add_points("artefacts", obj:get_inventory_item().inv_name, 1, 1)
			Actor:set_character_rank(Actor:character_rank() + 1)
			se_obj.already_taken = true
		end
	end
end
--[[-----------------------------------------------------------------------------------------------
 * Repack ammo
--]]-----------------------------------------------------------------------------------------------
local ammo_sections = {}
local need_to_repack = false
---------------------------------------------------------------------------------------------------
function get_item_place(obj, npc)
	if not npc then
		npc = Actor
	end
	if npc:is_in_slot(obj) then
		return item_place.slot
	elseif npc:is_on_belt(obj) then
		return item_place.belt
	elseif npc:is_in_ruck(obj) then
		return item_place.ruck
	end
	return item_place.undefined
end
---------------------------------------------------------------------------------------------------
function check_ammo(obj)
	if obj:is_ammo() then
		local section = obj:section()
		local box_size = obj:get_ammo_box_size()
		if box_size > 1 and obj:get_current_ammo() < box_size then
			ammo_sections[section] = {}
			ammo_sections[section].box_size = box_size
			if get_item_place(obj) == item_place.ruck then
				ammo_sections[section].ruck = true
			else
				ammo_sections[section].belt = true
			end
			need_to_repack = true
		end
	end
end
---------------------------------------------------------------------------------------------------
function repack_ammo()
	if need_to_repack and not Actor:is_talking() then
		local repack = function(section, box_size, place)
			local ammo = {}
			local total_size = 0
			Actor:iterate_inventory(
				function(dummy, obj)
					if obj:section() == section and get_item_place(obj) == place then
						local current_size = obj:get_current_ammo()
						if current_size ~= box_size then
							ammo[#ammo + 1] = obj
							total_size = total_size + current_size
						end
					end
				end
			)
			for i, v in ipairs(ammo) do
				if total_size == 0 then
					release(v)
				elseif total_size >= box_size then
					v:set_ammo_box_curr(box_size)
					total_size = total_size - box_size
				else
					v:set_ammo_box_curr(total_size)
					total_size = 0
				end
			end
		end
		for k, v in pairs(ammo_sections) do
			if v.ruck then
				repack(k, v.box_size, item_place.ruck)
			end
			if v.belt then
				repack(k, v.box_size, item_place.belt)
			end
		end
		ammo_sections = { }
		need_to_repack = false
	end
end
