local math_random = math.random
local xr_logic_pick_section_from_condlist = xr_logic.pick_section_from_condlist

-- game hours
local DEF_RESUPPLY_TIME = 50
local DEF_RESUPPLY_RND = 20

local trade_manager_tbl = {}

local generic_ltx = "trade\\trade_generic.ltx"
local generic_tt

local traders = {
	[story_ids.gar_voron]			= { val = "voron_enough",	cnt = 5 }, -- Витёк Ворон
	[story_ids.Mil_Master_Max]		= { val = "maks_enough",	cnt = 4 }, -- Макс
	[story_ids.Escape_Trader]		= { val = "sidor_enough",	cnt = 3 }, -- Сидорович
	[story_ids.bar_Barman]			= { val = "barman_enough",	cnt = 5 }, -- Бармен
	[story_ids.bar_dolg_polkovnik_petrenko]	= { val = "petrenko_enough",	cnt = 4 }, -- Петренко
	[story_ids.Mil_Miser]			= { val = "skraga_enough",	cnt = 3 }, -- Скряга
	[story_ids.yan_general_ecolog]		= { val = "sakharov_enough",	cnt = 5 }, -- Сахаров
	[story_ids.Sak]				= { val = "sak_enough",		cnt = 5 }, -- Сяк
	[story_ids.Doktor]			= { val = "doktor_enough",	cnt = 4 }, -- Доктор в Припяти
	[story_ids.Sherstuk]			= { val = "sherstyk_enough",	cnt = 3 }, -- Шерстюк
	[story_ids.val_bandit_trader]		= { val = "jlob_enough",	cnt = 3 }, -- Жила
	[story_ids.esc_kuznetsov]		= { val = "kuznezov_enough",	cnt = 4 }, -- Кузнецов
	[story_ids.esc_dan]			= { val = "dan_enough",		cnt = 5 }  -- Дэн
}

local checklist = { story_ids.gar_kulinar, story_ids.bar_linspiro_ecolog, story_ids.val_horyn }
for name, _ in pairs(traders) do
	checklist[#checklist + 1] = name
end

function trade_init_generic()
	local ini = ini_file(generic_ltx)
	local section = "trader"

	generic_tt = {
		config		= ini,
		buy_condition	= xr_logic.parse_condlist(ini:r_string(section, "buy_condition")),
		sell_condition	= xr_logic.parse_condlist(ini:r_string(section, "sell_condition")),

		weap_condition	= ini:r_float(section, "item_condition_weapon"),
		outf_condition	= ini:r_float(section, "item_condition_outfit"),
		part_condition	= ini:r_float(section, "item_condition_monster_part")
	}
end

function trade_init(npc, cfg)
	npc:disable_trade()

	if not cfg or cfg == generic_ltx then
		if not generic_tt then
			trade_init_generic()
		end

		return
	end

	local tt = trade_manager_tbl[npc:id()]
	if tt then return end

	local ini = ini_file(cfg)
	local section = "trader"

	if not ini:line_exist(section, "buy_condition") or
	   not ini:line_exist(section, "sell_condition") or
	   not ini:line_exist(section, "buy_supplies") then
		abort("Incorrect trader settings. Missing buy_condition or  sell_condition or buy_supplies. [%s]->[%s]", npc:name(), cfg)
		return
	end

	trade_manager_tbl[npc:id()] = {
		config		= ini,

		-- коэфициенты покупки
		buy_condition	= xr_logic.parse_condlist(ini:r_string(section, "buy_condition")),
		-- коэфициенты продажи
		sell_condition	= xr_logic.parse_condlist(ini:r_string(section, "sell_condition")),
		-- список закупки
		buy_supplies	= ini:r_string(section, "buy_supplies"),

		-- состояние покупаемого
		weap_condition	= ini:r_float_ex(section, "item_condition_weapon"),
		outf_condition	= ini:r_float_ex(section, "item_condition_outfit"),
		part_condition	= ini:r_float_ex(section, "item_condition_monster_part"),

		resupply_time	= ini:r_float_ex(section, "resupply_time", DEF_RESUPPLY_TIME),
		resupply_rnd	= ini:r_float_ex(section, "resupply_rnd", DEF_RESUPPLY_RND)
	}
end

function first_update(npc)
	npc:enable_trade()
	local tt = trade_manager_tbl[npc:id()] or generic_tt

	local str = xr_logic_pick_section_from_condlist(npc, tt.buy_condition)
	if str then
		npc:buy_condition(tt.config, str)
	end

	str = xr_logic_pick_section_from_condlist(npc, tt.sell_condition)
	if str then
		npc:sell_condition(tt.config, str)
	end

	if tt.buy_supplies or traders[npc.m_story_id or npc:story_id()] then
		resupply(npc)
	end
end

function resupply(npc)
	local sobj = server_object(npc)
	local next_resupply = sobj.resupply_time
	if next_resupply > time_game_hours then return end

	local tt = trade_manager_tbl[sobj.id] or generic_tt
	if tt.buy_supplies then
		local str = xr_logic.parse_condlist(tt.buy_supplies)
		str = xr_logic_pick_section_from_condlist(npc, str)
		if str then
			npc:buy_supplies(tt.config, str)
		end
	end

	local lim = traders[npc.m_story_id or npc:story_id()]
	if lim then
		del_value(lim.val)
	end

	local resupply_time = tt.resupply_time or DEF_RESUPPLY_TIME
	local resupply_rnd = tt.resupply_rnd or DEF_RESUPPLY_RND
	next_resupply = next_resupply - time_game_hours
	while next_resupply <= 0 do
		next_resupply = next_resupply + resupply_time + math_random(-resupply_rnd, resupply_rnd)
	end
	sobj.resupply_time = time_game_hours + next_resupply
end

function check_supplies()
	local sobj, obj
	for i = 1, #checklist do
		sobj = story_object(checklist[i])
		if sobj and sobj.resupply_time ~= 0 and sobj.resupply_time <= time_game_hours and
		   sobj:alive() then
			obj = level_object(sobj.id)
			if obj and obj:binded_object() then
				resupply(obj)
			else
				sobj.resupply_time = 0
			end

			news_main.send_resupply(sobj)
		end
	end

	timer("trade_manager.check_supplies", 5 * 60 * 1000, true)
end

function new_game()
	timer("trade_manager.check_supplies", 5 * 60 * 1000, true)
end

function get_item_condition()
	local npc = Actor:is_talking() and level.get_second_talker() or nil
	if not npc then return nil end

	local tt = trade_manager_tbl[npc:id()] or generic_tt
	return {
		weapon	= tt.weap_condition or generic_tt.weap_condition,
		outfit	= tt.outf_condition or generic_tt.outf_condition,
		part	= tt.part_condition or generic_tt.part_condition
	}
end

function trader_enough(id)
	local lim = traders[id]

	return get_value(lim.val, 0) >= lim.cnt
end

function trader_count(id)
	local lim = traders[id]

	set_value(lim.val, get_value(lim.val, 0) + 1)
end
