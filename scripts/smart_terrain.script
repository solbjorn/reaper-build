--[[------------------------------------------------------------------------------------------------------------------
Smart Terrain (механизм, организовывающий всех сталкеров и некоторых монстров в сцены)
Чугай Александр
!без симуляции не работает!
--------------------------------------------------------------------------------------------------------------------]]

local math_random = math.random
local string_gsub = string.gsub

local check_period = game.CTime()
check_period:setHMSms( 0, 0, 0, 50000 )

local CTime_0 = game.CTime()

local disagreed, agreed, agreed_exclusive = 0, 1, 2

local smart_section = "smart_terrains"

local smart_terrains = {}

exclusives = {}

--[[ список всех серверных объектов смартов, которые зарегистрированы в симуляторе
Формат:
  smart_terrains = {
    level_name = { id=obj, id=obj, ... },
    level_name = { id=obj, id=obj, ... },
    ...
  }
]]

----------------------------------------------------------------------------------------------------------------------
-- Класс "se_smart_terrain". Обеспечивает поддержку smart terrain в ОФЛАЙНЕ.
-- Унаследован от скриптовой зоны.
----------------------------------------------------------------------------------------------------------------------
class "se_smart_terrain" ( cse_alife_smart_zone )

function se_smart_terrain:__init( section ) super( section )
	if not graph then before_objs_load_callback() end

  self.initialized = false
  self.registred = false
end

-- сохранение
function se_smart_terrain:STATE_Write( packet )
  cse_alife_smart_zone.STATE_Write( self, packet )

  if self.gulag_working then
    packet:w_bool( true )

    self.gulag:save_common( packet )

		packet:w_u8(table.size(self.npc_info))

    for id, v in pairs( self.npc_info ) do
      packet:w_u16  ( id )
      packet:w_u8   ( v.o_group )
      packet:w_u8   ( v.o_squad )
      packet:w_bool ( v.exclusive )
			packet:w_CTime(v.stay_end)

      self.gulag:save_obj( packet, id )
    end
  else
    packet:w_bool( false )
  end
end

-- восстановление
function se_smart_terrain:STATE_Read( packet, size )
  cse_alife_smart_zone.STATE_Read( self, packet, size )

  self:read_params()

  self.gulag_working = packet:r_bool()

  -- если есть работающий гулаг
  if self.gulag_working then
    self.check_time = CTime_0

    self.gulag:load_common( packet )

    local n = packet:r_u8()
    local o_id, o

    for i = 1, n do
      o_id = packet:r_u16()
      self.npc_info[o_id] = {}
      o = self.npc_info[o_id]

      o.o_group   = packet:r_u8()
      o.o_squad   = packet:r_u8()
      o.exclusive = packet:r_bool()
			o.stay_end  = packet:r_CTime()

      self.gulag:load_obj( packet, o_id )
    end
  end
end

-- инициализировать работу смарт террейна.
-- после этой функции смарт ПОЛНОСТЬЮ работоспособен.
-- вызывается из всех мест, которые могут вызвать другие объекты:
--   se_smart_terrain:enabled()
--   se_smart_terrain:update()
--   xr_gulag.setup_gulag_and_logic_on_spawn()
--   xr_gulag.get_npc_gulag()
--   xr_gulag.get_gulag_by_name()
--   xr_gulag.get_gulag_by_sid()
function se_smart_terrain:initialize_if_needed()
  if not self.initialized then
    self:get_se_objs()

    self:preserve_exclusives()

    self.initialized = true
  end
end

-- зарезервировать места для эксклюзивных персонажей
function se_smart_terrain:preserve_exclusives()
  local e = exclusives[self:name()]

  if e then
  self.exclusives = e
    self.gulag.capacity_non_exclusive = self.gulag.capacity_non_exclusive - e

    exclusives[self:name()] = nil
  else
    self.exclusives = 0
  end
end

-- получить серверные объекты персонажей
function se_smart_terrain:get_se_objs()
  local obj

  for id, v in pairs( self.npc_info ) do
    obj = AI:object( id )

    if not obj then
      abort( "[smart_terrain %s] can't get server object id=%d", self:name(), id )
    end

    self:fill_npc_info( obj, v )
  end
end

-- заполнить информацию о персонаже
-- у монстров нету метода profile_name()
-- TODO передавать в предикаты не npc_info, а объект
function se_smart_terrain:fill_npc_info( obj, npc_info )
  if not npc_info then
    npc_info = {}
  end

  npc_info.se_obj       = obj

  npc_info.class_id     = obj:clsid()
  npc_info.name         = obj:name()
  npc_info.story_id     = obj.m_story_id
  npc_info.community    = (self:get_obj_community(obj))
  npc_info.profile_name = obj.profile_name and obj:profile_name()

  if npc_info.profile_name then
    npc_info.is_sniper = string.find( npc_info.profile_name, "sniper" ) ~= nil
  end

  local t               = obj.smart_terrain_conditions
  if t then
    t = t[self:name()]
  end

  npc_info.cond         = t
  return npc_info
end

-- возвращает:
-- а) если сталкер: группировку сталкера и true
-- б) если монстр:  вид монстра и false
function se_smart_terrain:get_obj_community(obj)
	if obj:clsid() == clsid_script_stalker then
		return obj:community(), true
	else
		return config:r_string_cache(obj:section_name(), "community"), false
	end
end

-- инициализация.
-- чтение custom data.
function se_smart_terrain:read_params()
  local ini  = self:spawn_ini()
  local sect = "smart_terrain"
	local function r_str(line, default)
		if ini:line_exist( sect, line ) then
			return ini:r_string( sect, line )
		else
			return default
		end
	end

  if not ini:section_exist( sect ) then
    sect = "gulag1"

    if not ini:section_exist( sect ) then
      self.disabled = true
      return
    end
  end

  if not ini:line_exist( sect, "type" ) then
    abort( "[smart_terrain %s] type is not specified", self:name() )
  end

	self.level_name = object_level_name(self)

  local gp       = {}

  self.npc_info  = {}          -- group и squad для каждого npc
  self.gparams   = gp          -- настройки гулага

  gp.type        = ini:r_string( sect, "type" )
	gp.type_prefix = string.sub(gp.type, 1, 3)
	gp.preset_name = r_str("preset") or self.level_name
  gp.capacity    = ini:r_float_ex(sect, "capacity", 100) -- ёмкость. а настоящая ёмкость = min(эта_ёмкость, ёмкость гулага)
  gp.squad       = ini:r_float_ex(sect, "squad")

  gp.stay_min,     gp.stay_max      = smart_terrain_params.get_stay_time_interval( r_str( "stay", "default" ) )

  gp.respawn     = r_str ( "respawn" )

  gp.cond        = r_str( "cond" )
  if gp.cond then
		gp.cond = xr_logic.parse_condlist(gp.cond)
		gp.cond = reap_misc.cached_condlist(gp.cond, 1000)
  end

  gp.groups      = r_str( "groups" )
  if gp.groups then
    gp.groups = string.parse_nums( gp.groups )
  end

	local t = r_str( "communities" )
	if t then
		t = t:parse_names()
		self.accepted_communities = {}
		for i, v in ipairs( t ) do
			self.accepted_communities[v] = true
		end
	else
		self.accepted_communities = nil
	end

	self.rank_inc_min = config:r_string_cache("smart_terrain_rank_change", "min")
	self.rank_inc_max = config:r_string_cache("smart_terrain_rank_change", "max")

	self.gulag = xr_gulag.gulag( self )

	self.gulag_working = false
end

-- подходит ли персонаж по предустановкам.
-- если такой предустановки нету, то он всегда подходит.
function se_smart_terrain:check_preset( npc_community, npc_rank, preset_name )
  local preset = smart_terrain_params.get_preset( preset_name )

  if not preset then
    return true
  else
    local t = preset[npc_community]

    if t and ( npc_rank >= t[1] and npc_rank <= t[2] ) then
      return true
    else
      return false
    end
  end
end

--[[ подходит ли объект гулагу?
1) если объект не согласен сюда идти, то smart terrain его не возьмёт
2) если объект согласен идти куда угодно, то проверить, есть ли ещё места, подходит ли он гулагу,
   подходит ли он хоть на одну работу
3) если объект согласен идти только в этот смарт, то принимаем даже если нету места (он вытеснит кого-то), проверить,
   подходит ли он гулагу, подходит ли он хоть на одну работу
]]
local level_groups

function init_level_groups()
	level_groups = {
		l01_escape		= 1,
		l02_garbage		= 1,
		l03_agroprom		= 1,
		l03u_agr_underground	= 1,
		l04_darkvalley		= 1,
		l04u_labx18		= 1,
		l05_bar			= 1,
		l06_rostok		= 1,
		l07_military		= 1,
		l08_yantar		= 1,
		l08u_brainlab		= 1,
		l10_radar		= has_info("bar_deactivate_radar_done") and 1 or 2,
		l10u_bunker		= has_info("bar_deactivate_radar_done") and 1 or 2,
		l11_pripyat		= has_info("bar_deactivate_radar_done") and 1 or 2,
		l12_stancia		= has_info("sar_finish_decoding") and 1 or 2,
		l12u_sarcofag		= has_info("sar2_monolith_miracle") and 1 or 2,
		l12u_control_monolith	= has_info("sar2_monolith_miracle") and 1 or 2,
		l12_stancia_2		= has_info("aes2_monolit_teleport_ready_final") and 1 or 2
	}
end

function se_smart_terrain:smart_terrain_accepts_obj( obj, obj_agreement )
  if obj_agreement == disagreed then
    return false
  end

  if obj_agreement == agreed_exclusive or
     self.gulag:get_non_exclusive_population() < self.gulag.capacity_non_exclusive
  then
		--' Проверка что смарттеррейн и НПС находятся в одном кластере уровней (чтобы не ходили через БАР)
		if obj.m_game_vertex_id == 65535 then
			abort("Bad game_vertex_id for %s, causes 'no specified level in the game graph' errors", obj:name())
			return false
		end
		if not level_groups then
			init_level_groups()
		end

		local npc_level_group = object_level_name(obj)
		if level_groups[self.level_name] ~= level_groups[npc_level_group] then
			return false
		end

		local community, is_stalker = self:get_obj_community( obj )
		if not community then return false end

    if self.accepted_communities and not self.accepted_communities[community] then
      return false
    end

    if not self:check_preset( community, obj:rank(), self.gparams.preset_name ) then
      return false
    end

    if not xr_gulag.checkNpc( community, is_stalker, self.gparams, obj ) then
      return false
    end

    return self.gulag:is_there_any_suitable_job( self:fill_npc_info( obj ), obj_agreement == agreed_exclusive )
  else
    return false
  end
end

--[[ подходит ли гулаг объекту?
у объекта в custom data прописаны условия для некоторых smart_terrains:
  <smart_terrain_name1> = <condlist1>
  <smart_terrain_name2> = <condlist2>
  ...
Если для какого-то smart_terrain условие выполнилось, он называется эксклюзивным.
Если у объекта появился хоть один эксклюзивный smart terrain, то он будет согласен идти только в него.
Если не появилось ни одного эксклюзивного, то он согласен идти в любой.
]]
-- TODO а если в начале эксклюзивный, а потом в любой?
-- вариант: any=condlist
function se_smart_terrain:obj_accepts_smart_terrain( obj )
  if obj.smart_terrain_conditions then
    local s

    for name, condlist in pairs(obj.smart_terrain_conditions) do
      s = xr_logic.pick_section_from_condlist(obj, condlist)

      if s ~= nil then
        if name == "none" then
          return disagreed
        elseif name == self:name() then
          return agreed_exclusive
        end
      else
        --' Если текущий смарттеррейн эксклюзивный и недоступен
        if name == self:name() then
          return disagreed
        end
      end
    end

		--' Если объекту запрещено переходить в online и эксклюзивные
		--' смарты недоступны, то не пускаем его никуда. Это исключает
		--' переброску отключенных до (или после) определённого события
		--' людей и мутантов в другой неэксклюзивный смарт.
		if obj:can_switch_online() == false then
			return disagreed
		end
  end

  return agreed
end

-- может ли объект быть добавлен в smart terrain?
-- вызывается симулятором при поиске задания для объекта/группы.
-- если объект - группа, то вернёт true только если все объекты в группе вернут true
function se_smart_terrain:enabled(obj)
  -- DEBUG
  if self.disabled then
    return false
  end
  --------
  self:register_if_needed()
  self:initialize_if_needed()

  if self:is_gulag_available() then
    local b = self:obj_accepts_smart_terrain( obj )
    local a = self:smart_terrain_accepts_obj( obj, b )
    return a
  else
    return false
  end
end

-- возвращает меру подходящести персонажа смарттерейну.
-- вызывается для всех смарттерейнов, которые вернули true из enabled
-- для того, чтобы выбрать тот единственный, в который персонаж всё-таки пойдёт.
-- критерии:
--   1) если объект уже бывал в других смартах, то чем больше свободных работ на уровне этого смарта, тем лучше
--   2) иначе ближе - лучше
-- TODO Оптимизировать
function se_smart_terrain:suitable( obj )
  local v = 0

  --' Повысить подходящесть эксклюзивного смарттеррейна
  if self:obj_accepts_smart_terrain(obj) == agreed_exclusive then
    v = 100000 --'Так чтобы все эксклюзивные были заведомо лучше
  end

	for id, strn in pairs(smart_terrains[self.level_name]) do
    if strn:is_gulag_available() then
      v = v + strn.gulag.capacity - strn.gulag:get_population()
    end
  end

  return v
end

-- добавить npc в smart terrain.
-- если места нету или нету свободных подходящих работ, то
-- вытолкнуть из этого smart terrain с подходящей работы объект, который попал в него не эксклюзивно.
function se_smart_terrain:register_npc( obj )
  local npc_info = {
    -- старые squad и group
    o_group        = obj:g_group(),
    o_squad        = obj:g_squad(),

    exclusive      = self:obj_accepts_smart_terrain( obj ) == agreed_exclusive,

    stay_end       = game.CTime()
  }

  self:fill_npc_info( obj, npc_info )

  if self.gulag_working and
     not self.gulag:is_there_any_suitable_job( npc_info, false )
  then
    self:kick_someone_non_exclusive( npc_info )
  end

  self:update_obj_rank( obj )

  obj.was_in_smart_terrain = true

  self.npc_info[obj.id] = npc_info

  t = self.npc_info[obj.id].stay_end
  t:setHMSms( math_random( self.gparams.stay_min, self.gparams.stay_max ), 0, 0, 0 )
  t:add( game.get_game_time() )

  if not self.gulag_working then
    self:create_gulag()
  end

  self.gulag:addObject( obj.id )
  self.gulag:update()
end

-- отпустить npc
-- TODO а если такого объекта уже нету?
function se_smart_terrain:unregister_npc( obj )
  local n = self.npc_info[obj.id]

  --' Если анрегистрим мертвого эксклюзивного НПС, нужно уменьшить счетчик эксклюзивности
  if not obj:alive() and obj.smart_terrain_conditions then
    local any_exclusive = false
    local s

    for name, condlist in pairs(obj.smart_terrain_conditions) do
      s = xr_logic.pick_section_from_condlist(obj, condlist)

      if s ~= nil then
        if name == self:name() then
          --' уменьшаем счетчик
          self.exclusives = self.exclusives - 1
          self.gulag.capacity_non_exclusive = self.gulag.capacity_non_exclusive + 1
        end
      end
    end
  end

  self.gulag:removeObject( obj.id )

  obj.squad = n.o_squad
  obj.group = n.o_group

  self.npc_info[obj.id] = nil

  obj:clear_smart_terrain()
	obj:brain():can_choose_alife_tasks(true)	-- разрешаем мобу юзать смарты (dsh)
end

-- изменть ранг сталкера при регистрации в смарт
function se_smart_terrain:update_obj_rank( obj )
  local community, is_stalker = self:get_obj_community( obj )

  if is_stalker then
    local old_rank = obj:rank()

    obj:set_rank( old_rank + math_random( self.rank_inc_min, self.rank_inc_max ) )
  end
end

-- выгнать из-под смарттеррейна первого попавшегося неэксклюзивного персонажа,
-- который занимает работу, подходящую новому персонажу.
-- TODO а если я выгоню кого-то, а его работа не подойдёт по idle ?
function se_smart_terrain:kick_someone_non_exclusive( new_npc_info )
  for obj_id, npc_info in pairs( self.npc_info ) do
    if not npc_info.exclusive and self.gulag:obj1_job_suits_obj2( obj_id, new_npc_info ) then
      self:unregister_npc( npc_info.se_obj )
      return
    end
  end

  abort( "[smart_terrain %s] can't add npc, all are exclusive or there are no suitable jobs", self:name() )
end

-- выдать объекту задание.
function se_smart_terrain:task( obj )
	local job = self.gulag:getJob(obj.id)
	local alife_task = job and job.alife_task
	if not alife_task then
		self:unregister_npc(obj) --'Затычка против вылета.
		return CALifeSmartTerrainTask("simulation_default_path")
	end

	return alife_task
end

-- может ли данный гулаг создаться в данный момент?
function se_smart_terrain:is_gulag_available()
	if self.gparams.cond then
		if not random_task:smart_is_protected(self) then
			return self.gparams.cond:pick_section_from_condlist(self) ~= nil
		end
	end
	return true
end

-- в гулаг поступил первый персонаж и он начинает работать
function se_smart_terrain:create_gulag()
  self.check_time = CTime_0

  self.gulag:initialize()

  self.gulag_working = true
end

-- всех освободить, убить гулаг,
-- создать новый нерабочий гулаг, зарезервировать в нём места для эксклюзивных
function se_smart_terrain:remove_gulag( disable )
  -- DEBUG
  self.disabled = disable
  --------

  if not self.gulag_working then
    return
  end

  -- освободить всех персонажей
  for id, npc_info in pairs( self.npc_info ) do
    self:unregister_npc( npc_info.se_obj )
  end

  self.gulag = xr_gulag.gulag( self )
  self.gulag:load_jobs()

  self.gulag_working = false

  self.gulag.capacity_non_exclusive = self.gulag.capacity_non_exclusive - self.exclusives
end

-- регистрация объекта в симуляторе.
-- вызывается симулятором.
function se_smart_terrain:on_register()
  cse_alife_smart_zone.on_register( self )

  self:register_if_needed()
  self:initialize_if_needed()
end

function se_smart_terrain:register_if_needed()
  --' Если уже зарегистрены то ничего не делать.
  if self.registred == true then
    return
  end
  self.registred = true

  -- DEBUG
  if self.disabled then
    return
  end

	local level_smarts = smart_terrains[self.level_name]
	if not level_smarts then
		level_smarts = { }
		smart_terrains[self.level_name] = level_smarts
	end
	level_smarts[self.id] = self

	if self.gparams.respawn then
		db.strn_by_respawn[self.gparams.respawn] = self
	end

  self.gulag:load_jobs()

  if self.gulag_working then
    self.gulag:initialize()
  end

	-- Регистрация в таскменеджере
	random_task:register_smart(self, clsid_smart_terrain)
end

-- дерегистрация объекта в симуляторе.
-- вызывается симулятором.
function se_smart_terrain:on_unregister()
  cse_alife_smart_zone.on_unregister( self )

	local lvl_smarts = smart_terrains[self.level_name]
  if lvl_smarts then
    lvl_smarts[self.id] = nil
  end

	if self.gparams and self.gparams.respawn then
		db.strn_by_respawn[self.gparams.respawn] = nil
	end
end

-- вызвать спавнер, если настроен.
function se_smart_terrain:call_respawn()
  if self.gparams.respawn then
    se_respawn.spawn( self.gparams.respawn )
  end
end

-- Обновление.
-- В онлайне вызывается через binder.
-- Также может вызваться принудительно из xr_effects
-- Если мужиков в гулаге больше не осталось или условия существования гулага не выполняются, то убрать гулаг.
function se_smart_terrain:update()
	cse_alife_smart_zone.update( self )

	if not self.gulag_working then
		return
	end

	if self:is_gulag_available() then
		local game_time = game.get_game_time()
		if self.check_time < game_time then
			self.check_time = game_time + check_period

			--' проверять, не собрался ли кто-то к этому времени уже уходить
			for id, npc_info in pairs( self.npc_info ) do
				if npc_info.cond and xr_logic.pick_section_from_condlist(npc_info.se_obj, npc_info.cond) == nil then
					self:unregister_npc( npc_info.se_obj )
				-- если вышло время пребывания
				elseif (not npc_info.exclusive) and npc_info.stay_end then
					if npc_info.stay_end < game_time then
						-- если смарт используется в данный момент таск-менеджером, то продлеваем неписю время
						-- чтобы задание не засчиталось выполненным или проваленным само по себе
						if random_task:smart_is_protected(self) then
							npc_info.stay_end:setHMSms( math_random( self.gparams.stay_min, self.gparams.stay_max ), 0, 0, 0 )
							npc_info.stay_end:add(game_time)
						else
							local se_npc = npc_info.se_obj
							if se_npc:alive() then
								self:unregister_npc(se_npc)
								se_npc:brain():update()
							else
								self.gulag:clear_dead(se_npc.id)
							end
						end
					end
				end
			end

			if self.gulag:get_population() == 0 then
				self:remove_gulag(self.id)
			else
				self.gulag:update()
			end
		end
	else
		self:remove_gulag()
	end
end

--------------------
function on_death( obj_id )
    local obj     = AI:object( obj_id )
		if obj == nil or (type(obj.smart_terrain_id) ~= "function") then return end
		local strn_id = obj:smart_terrain_id()
		if strn_id ~= 65535 then
	      AI:object( strn_id ).gulag:clear_dead(obj_id)
	    end
end

-----------------------
--' Удаляет объект из смарттеррейнов.
function unregister_npc(npc)
    local obj     = AI:object(npc.id)
		if obj == nil or (type(obj.smart_terrain_id) ~= "function") then return end
    local strn_id = obj:smart_terrain_id()

    if strn_id ~= 65535 then
      if AI:object(strn_id) then
        AI:object(strn_id):unregister_npc(obj)
      end
    end
end

--------------------
-- прочитать секцию [smart_terrains]
-- вызывается объектами, которые могут ходить под smart terrain
function read_smart_terrain_conditions( self )
	if self.ini and self.ini:section_exist( smart_section ) then
		local conds = {}
		self.ini:iterate_lines(smart_section, function(result, field, str)
			conds[field] = xr_logic.parse_condlist(str)
		end)
		return conds
	end
	return nil
end
