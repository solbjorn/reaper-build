--[[------------------------------------------------------------------------------------------------------------------
Smart Terrain (механизм, организовывающий всех сталкеров и некоторых монстров в сцены)
Чугай Александр
!без симуляции не работает!
--------------------------------------------------------------------------------------------------------------------]]

local check_period = game.CTime()
check_period:setHMSms( 0, 0, 0, 50000 )

CTime_0 = game.CTime()

local monster_classes

local disagreed, agreed, agreed_exclusive = 0, 1, 2

local smart_section = "smart_terrains"

local smart_terrains = {}

exclusives = {}

--[[ список всех серверных объектов смартов, которые зарегистрированы в симуляторе
Формат:
  smart_terrains = {
    level_name = { id=obj, id=obj, ... },
    level_name = { id=obj, id=obj, ... },
    ...
  }
]]

----------------------------------------------------------------------------------------------------------------------
-- Разные полезные функции
----------------------------------------------------------------------------------------------------------------------
-------------- помощники для чтения ini (custom data) -------------------
-- TODO убрать их
function r_num( spawn_ini, section, line, default )
  if spawn_ini:line_exist( section, line ) then
    return spawn_ini:r_float( section, line )
  else
    return default
  end
end

function r_2nums( spawn_ini, section, line, def1, def2 )
  if spawn_ini:line_exist( section, line ) then
    -- если default-ов больше, чем значений в ini, то забить недостающие последним значением из ini
    local t = parse_nums( spawn_ini:r_string( section, line ) )
    local n = #t

    if n == 0 then
      return def1, def2
    elseif n == 1 then
      return t[1], def2
    else
      return t[1], t[2]
    end
  else
    return def1, def2
  end
end

----------------------------------------------------------------------------------------------------------------------
-- Класс "se_smart_terrain". Обеспечивает поддержку smart terrain в ОФЛАЙНЕ.
-- Унаследован от скриптовой зоны.
----------------------------------------------------------------------------------------------------------------------
class "se_smart_terrain" ( cse_alife_smart_zone )

function se_smart_terrain:__init( section ) super( section )
  self.initialized = false
  self.registred = false
	self:fill_monster_classes()
end

local math_random = math.random
local utils_w_CTime = utils.w_CTime
local utils_r_CTime = utils.r_CTime

-- сохранение
function se_smart_terrain:STATE_Write( packet )
  cse_alife_smart_zone.STATE_Write( self, packet )

  utils_w_CTime( packet, self.duration_end )
  utils_w_CTime( packet, self.idle_end )

  if self.gulag_working then
    packet:w_bool( true )

    self.gulag:save_common( packet )

    local n = 0

    for id, v in pairs( self.npc_info ) do
      n = n + 1
    end

    packet:w_u8( n )

    for id, v in pairs( self.npc_info ) do
      packet:w_u16  ( id )
      packet:w_u8   ( v.o_group )
      packet:w_u8   ( v.o_squad )
      packet:w_bool ( v.exclusive )
      utils_w_CTime ( packet, v.stay_end )

      self.gulag:save_obj( packet, id )
    end

    packet:w_bool ( self.population_locked )
  else
    packet:w_bool( false )
  end
end

-- восстановление
function se_smart_terrain:STATE_Read( packet, size )
  cse_alife_smart_zone.STATE_Read( self, packet, size )

  self:read_params()

  self.duration_end = utils_r_CTime( packet )
  self.idle_end     = utils_r_CTime( packet )

  self.gulag_working = packet:r_bool()

  -- если есть работающий гулаг
  if self.gulag_working then
    self.check_time = CTime_0

    self.gulag:load_common( packet )

    local n = packet:r_u8()
    local o_id, o

    for i = 1, n do
      o_id = packet:r_u16()
      self.npc_info[o_id] = {}
      o = self.npc_info[o_id]

      o.o_group   = packet:r_u8()
      o.o_squad   = packet:r_u8()
      o.exclusive = packet:r_bool()
      o.stay_end  = utils_r_CTime( packet )

      self.gulag:load_obj( packet, o_id )
    end

    self.population_locked = packet:r_bool()
  end
end

-- инициализировать работу смарт террейна.
-- после этой функции смарт ПОЛНОСТЬЮ работоспособен.
-- вызывается из всех мест, которые могут вызвать другие объекты:
--   se_smart_terrain:enabled()
--   se_smart_terrain:update()
--   xr_gulag.setup_gulag_and_logic_on_spawn()
--   xr_gulag.get_npc_gulag()
--   xr_gulag.get_gulag_by_name()
--   xr_gulag.get_gulag_by_sid()
function se_smart_terrain:initialize_if_needed()
  if not self.initialized then
    self:get_se_objs()

    self:preserve_exclusives()

    self.initialized = true
  end
end

-- зарезервировать места для эксклюзивных персонажей
function se_smart_terrain:preserve_exclusives()
  local e = exclusives[self:name()]

  if e then
  self.exclusives = e
    self.gulag.capacity_non_exclusive = self.gulag.capacity_non_exclusive - e

    exclusives[self:name()] = nil
  else
    self.exclusives = 0
  end
end

-- получить серверные объекты персонажей
function se_smart_terrain:get_se_objs()
  local sim = alife()
  local obj

  for id, v in pairs( self.npc_info ) do
    obj = sim:object( id )

    if not obj then
      abort( "[smart_terrain %s] can't get server object id=%d", self:name(), id )
    end

    self:fill_npc_info( obj, v )
  end
end

-- заполнить информацию о персонаже
-- у монстров нету метода profile_name()
-- TODO передавать в предикаты не npc_info, а объект
function se_smart_terrain:fill_npc_info( obj, npc_info )
  if not npc_info then
    npc_info = {}
  end

  npc_info.se_obj       = obj

  npc_info.class_id     = obj:clsid()
  npc_info.section_name = obj:section_name()
  npc_info.name         = obj:name()
  npc_info.story_id     = obj.m_story_id
  npc_info.community    = self:get_obj_community( obj )
  npc_info.profile_name = obj.profile_name and obj:profile_name()
  npc_info.rank         = obj:rank()

  npc_info.group        = obj:g_group()
  npc_info.squad        = obj:g_squad()
  npc_info.team         = obj:g_team()

  if npc_info.profile_name then
    npc_info.is_sniper = string.find( npc_info.profile_name, "sniper" ) ~= nil
  end
  npc_info.is_sniper_name = string.find( npc_info.name, "sniper" ) ~= nil

  local t               = obj.smart_terrain_conditions
  if t then
    t = t[self:name()]
  end

  npc_info.cond         = t
  return npc_info
end

-- возвращает:
-- а) если сталкер: группировку сталкера и true
-- б) если монстр:  вид монстра и false
function se_smart_terrain:get_obj_community( obj )
  local cls = obj:clsid()

  if cls == clsid_script_stalker then
    return obj:community(), true
  else
    return monster_classes[cls], false
  end
end

-- инициализация.
-- чтение custom data.
function se_smart_terrain:read_params()
  local ini  = self:spawn_ini()
  local sect = "smart_terrain"
	local function r_str(line, default)
		if ini:line_exist( sect, line ) then
			return ini:r_string( sect, line )
		else
			return default
		end
	end

  if not ini:section_exist( sect ) then
    sect = "gulag1"

    if not ini:section_exist( sect ) then
      self.disabled = true
      return
    end
  end

  if not ini:line_exist( sect, "type" ) then
    abort( "[smart_terrain %s] type is not specified", self:name() )
  end

  local gp       = {}

  self.npc_info  = {}          -- group и squad для каждого npc
  self.gparams   = gp          -- настройки гулага

  gp.type        = ini:r_string( sect, "type" )
	gp.type_prefix = string.sub(gp.type, 1, 3)
	gp.preset_name = r_str ( "preset" ) or self:get_level_name()
  gp.capacity    = r_num ( ini, sect, "capacity", 100 ) -- ёмкость. а настоящая ёмкость = min(эта_ёмкость, ёмкость гулага)
  gp.squad       = r_num ( ini, sect, "squad" )

  gp.idle_min,     gp.idle_max      = r_2nums( ini, sect, "idle",       0,     0 )
  gp.duration_min, gp.duration_max  = r_2nums( ini, sect, "duration",   10000, 10001 )
  gp.stay_min,     gp.stay_max      = smart_terrain_params.get_stay_time_interval( r_str( "stay", "default" ) )

  gp.respawn     = r_str ( "respawn" )

  gp.cond        = r_str( "cond" )
  if gp.cond then
    gp.cond = xr_logic.parse_condlist_q(gp.cond)
  end

  gp.groups      = r_str( "groups" )
  if gp.groups then
    gp.groups = parse_nums( gp.groups )
  end

  self.accepted_communities = nil

  local t = r_str( "communities" )
  if t then
    t = parse_names( t )

    self.accepted_communities = {}

		for i, v in ipairs( t ) do
			-- обходим опечатки в all.spawn для pri_smart_controler_lairN
			if v == "controllers" then
				self.accepted_communities["controller"] = true
			-- и для x162_st_gigant
			elseif v == "giant" then
				self.accepted_communities["pseudo_gigant"] = true
			else
				self.accepted_communities[v] = true
			end
		end
	end

	self.rank_inc_min = system_ini():r_string( "smart_terrain_rank_change", "min" )
	self.rank_inc_max = system_ini():r_string( "smart_terrain_rank_change", "max" )

  self.population_locked = false

	self.gulag = xr_gulag.gulag( self )

  self.gulag_working = false
end

-- подходит ли персонаж по предустановкам.
-- если такой предустановки нету, то он всегда подходит.
function se_smart_terrain:check_preset( npc_community, npc_rank, preset_name )
  local preset = smart_terrain_params.get_preset( preset_name )

  if preset == false then
    return true
  else
    local t = preset[npc_community]

    if t and ( npc_rank >= t[1] and npc_rank <= t[2] ) then
      return true
    else
      return false
    end
  end
end

--[[ подходит ли объект гулагу?
1) если объект не согласен сюда идти, то smart terrain его не возьмёт
2) если объект согласен идти куда угодно, то проверить, есть ли ещё места, подходит ли он гулагу,
   подходит ли он хоть на одну работу
3) если объект согласен идти только в этот смарт, то принимаем даже если нету места (он вытеснит кого-то), проверить,
   подходит ли он гулагу, подходит ли он хоть на одну работу
]]
local level_groups = {
    l01_escape = "group1",
    l02_garbage = "group1",
    l03_agroprom = "group1",
    l03u_agr_underground = "group1",
    l04_darkvalley = "group1",
    l04u_labx18 = "group1",
    l05_bar = "group1",
    l06_rostok = "group1",
    l07_military = "group1",
    l08_yantar = "group1",
    l08u_brainlab = "group1",
    l10_radar = "group1",
    l10u_bunker = "group1",
    l11_pripyat = "group1",
    l12_stancia = "group3",
    l12u_sarcofag = "group3",
    l12u_control_monolith = "group3",
    l12_stancia_2 = "group3"
}

function se_smart_terrain:smart_terrain_accepts_obj( obj, obj_agreement )
  if obj_agreement == disagreed then
    return false
  end

  if obj_agreement == agreed_exclusive or
     self.gulag:get_non_exclusive_population() < self.gulag.capacity_non_exclusive
  then
    local community, is_stalker = self:get_obj_community( obj )

        --' Проверка что смарттеррейн и НПС находятся в одном кластере уровней (чтобы не ходили через БАР)
        local smart_level_group = self:get_level_name()
		if obj.m_game_vertex_id == 65535 then
			return false
		end
        local npc_level_group = alife():level_name(game_graph():vertex(obj.m_game_vertex_id):level_id())

        if level_groups[smart_level_group] ~= level_groups[npc_level_group] then
            return false
        end
    

    if self.accepted_communities and not self.accepted_communities[community] then
      return false
    end

    if not self:check_preset( community, obj:rank(), self.gparams.preset_name ) then
      return false
    end

    if not xr_gulag.checkNpc( community, is_stalker, self.gparams, obj ) then
      return false
    end

    return self.gulag:is_there_any_suitable_job( self:fill_npc_info( obj ), obj_agreement == agreed_exclusive )
  else
    return false
  end
end

--[[ подходит ли гулаг объекту?
у объекта в custom data прописаны условия для некоторых smart_terrains:
  <smart_terrain_name1> = <condlist1>
  <smart_terrain_name2> = <condlist2>
  ...
Если для какого-то smart_terrain условие выполнилось, он называется эксклюзивным.
Если у объекта появился хоть один эксклюзивный smart terrain, то он будет согласен идти только в него.
Если не появилось ни одного эксклюзивного, то он согласен идти в любой.
]]
-- TODO а если в начале эксклюзивный, а потом в любой?
-- вариант: any=condlist
function se_smart_terrain:obj_accepts_smart_terrain( obj )
  if obj.smart_terrain_conditions then
    local s

    for name, condlist in pairs(obj.smart_terrain_conditions) do
      s = xr_logic.pick_section_from_condlist( db.actor_proxy, obj, condlist )

      if s ~= nil then
        if name == "none" then        
          return disagreed
        elseif name == self:name() then
          return agreed_exclusive
        end
      else
        --' Если текущий смарттеррейн эксклюзивный и недоступен
        if name == self:name() then
          return disagreed
        end
      end
    end

		--' Если объекту запрещено переходить в online и эксклюзивные
		--' смарты недоступны, то не пускаем его никуда. Это исключает
		--' переброску отключенных до (или после) определённого события
		--' людей и мутантов в другой неэксклюзивный смарт.
		if obj:can_switch_online() == false then
			return disagreed
		end
  end

  return agreed
end

-- может ли объект быть добавлен в smart terrain?
-- вызывается симулятором при поиске задания для объекта/группы.
-- если объект - группа, то вернёт true только если все объекты в группе вернут true
function se_smart_terrain:enabled(obj)
  -- DEBUG
  if self.disabled then
    return false
  end
  --------
  self:register_if_needed()
  self:initialize_if_needed()

  if self:is_gulag_available() then
    local b = self:obj_accepts_smart_terrain( obj )
    local a = self:smart_terrain_accepts_obj( obj, b )
    return a
  else
    return false
  end
end

-- возвращает меру подходящести персонажа смарттерейну.
-- вызывается для всех смарттерейнов, которые вернули true из enabled
-- для того, чтобы выбрать тот единственный, в который персонаж всё-таки пойдёт.
-- критерии:
--   1) если объект уже бывал в других смартах, то чем больше свободных работ на уровне этого смарта, тем лучше
--   2) иначе ближе - лучше
-- TODO Оптимизировать
function se_smart_terrain:suitable( obj )
  local v = 0
  
  --' Повысить подходящесть эксклюзивного смарттеррейна
  if self:obj_accepts_smart_terrain(obj) == agreed_exclusive then
    v = 100000 --'Так чтобы все эксклюзивные были заведомо лучше
  end

  for id, strn in pairs( smart_terrains[self:get_level_name()] ) do

    if strn:is_gulag_available() then
      v = v + strn.gulag.capacity - strn.gulag:get_population()
    end
  end

  return v
end

-- добавить npc в smart terrain.
-- если места нету или нету свободных подходящих работ, то
-- вытолкнуть из этого smart terrain с подходящей работы объект, который попал в него не эксклюзивно.
function se_smart_terrain:register_npc( obj )
  local npc_info = {
    -- старые squad и group
    o_group        = obj:g_group(),
    o_squad        = obj:g_squad(),

    exclusive      = self:obj_accepts_smart_terrain( obj ) == agreed_exclusive,

    stay_end       = game.CTime()
  }

  self:fill_npc_info( obj, npc_info )

  if self.gulag_working and
     not self.gulag:is_there_any_suitable_job( npc_info, false )
  then
    self:kick_someone_non_exclusive( npc_info )
  end

  self:update_obj_rank( obj )

  obj.was_in_smart_terrain = true

  self.npc_info[obj.id] = npc_info

  t = self.npc_info[obj.id].stay_end
  t:setHMSms( math_random( self.gparams.stay_min, self.gparams.stay_max ), 0, 0, 0 )
  t:add( game.get_game_time() )

  if not self.gulag_working then
    self:create_gulag()
  end

  self.gulag:addObject( obj.id )
  self.gulag:update()
end

-- отпустить npc
-- TODO а если такого объекта уже нету?
function se_smart_terrain:unregister_npc( obj )
  local n = self.npc_info[obj.id]

  --' Если анрегистрим мертвого эксклюзивного НПС, нужно уменьшить счетчик эксклюзивности
  if not obj:alive() and obj.smart_terrain_conditions then
    local any_exclusive = false
    local s

    for name, condlist in pairs(obj.smart_terrain_conditions) do
      s = xr_logic.pick_section_from_condlist( db.actor_proxy, obj, condlist )

      if s ~= nil then
        if name == self:name() then
          --' уменьшаем счетчик
          self.exclusives = self.exclusives - 1
          self.gulag.capacity_non_exclusive = self.gulag.capacity_non_exclusive + 1
        end
      end
    end
  end

  self.gulag:removeObject( obj.id )

  obj.squad = n.o_squad
  obj.group = n.o_group

  self.npc_info[obj.id] = nil

  obj:clear_smart_terrain()
end

-- изменть ранг сталкера при регистрации в смарт
function se_smart_terrain:update_obj_rank( obj )
  local community, is_stalker = self:get_obj_community( obj )

  if is_stalker then
    local old_rank = obj:rank()

    obj:set_rank( old_rank + math_random( self.rank_inc_min, self.rank_inc_max ) )
  end
end

-- выгнать из-под смарттеррейна первого попавшегося неэксклюзивного персонажа,
-- который занимает работу, подходящую новому персонажу.
-- TODO а если я выгоню кого-то, а его работа не подойдёт по idle ?
function se_smart_terrain:kick_someone_non_exclusive( new_npc_info )
  for obj_id, npc_info in pairs( self.npc_info ) do
    if not npc_info.exclusive and self.gulag:obj1_job_suits_obj2( obj_id, new_npc_info ) then
      printf("[smart_terrain %s] kicking %s", self:name(), npc_info.name)
      self:unregister_npc( npc_info.se_obj )
      return
    end
  end

  abort( "[smart_terrain %s] can't add npc, all are exclusive or there are no suitable jobs", self:name() )
end

-- выдать объекту задание.
function se_smart_terrain:task( obj )
  local path_name = self.gulag:get_obj_job_path_name( obj.id )
  if not path_name then
    self:unregister_npc(obj) --'Затычка против вылета.
    return CALifeSmartTerrainTask("simulation_default_path")
  end

  return CALifeSmartTerrainTask( path_name )
end

-- может ли данный гулаг создаться в данный момент?
function se_smart_terrain:is_gulag_available()
  if self.gparams.cond then
    return xr_logic.pick_section_from_condlist( db.actor_proxy, self, self.gparams.cond ) ~= nil
  else
    return true
  end
end

-- в гулаг поступил первый персонаж и он начинает работать
function se_smart_terrain:create_gulag()
  self.duration_end = game.CTime()
  self.duration_end:setHMSms( math_random( self.gparams.duration_min, self.gparams.duration_max ), 0, 0, 0 )
  self.duration_end:add( game.get_game_time() )

  self.check_time = CTime_0

  self.gulag:initialize()

  self.gulag_working = true
end

-- всех освободить, убить гулаг,
-- создать новый нерабочий гулаг, зарезервировать в нём места для эксклюзивных
function se_smart_terrain:remove_gulag( disable )
  -- DEBUG
  self.disabled = disable
  --------

  if not self.gulag_working then
    return
  end

  -- освободить всех персонажей
  for id, npc_info in pairs( self.npc_info ) do
    self:unregister_npc( npc_info.se_obj )
  end

  if self.gparams.idle_max > 0 then
    self.idle_end = game.CTime()
    self.idle_end:setHMSms( math_random( self.gparams.idle_min, self.gparams.idle_max ), 0, 0, 0 )
    self.idle_end:add( game.get_game_time() )
  else
    self.idle_end = nil
  end

  self.gulag = xr_gulag.gulag( self )
  self.gulag:load_jobs()

  self.gulag_working = false

  self.gulag.capacity_non_exclusive = self.gulag.capacity_non_exclusive - self.exclusives
end

-- заполняет таблицу monster_classes
function se_smart_terrain:fill_monster_classes()
  if not monster_classes then
    monster_classes = {
      [clsid.bloodsucker_s ] = "bloodsucker",
      [clsid.boar_s        ] = "boar",
      [clsid.burer_s       ] = "burer",
      [clsid.cat_s         ] = "cat",
      [clsid.chimera_s     ] = "chimera",
      [clsid.controller_s  ] = "controller",
      [clsid.pseudodog_s   ] = "pseudodog",
      [clsid.psy_dog_s     ] = "psy_dog",
      [clsid.dog_s         ] = "dog",
      [clsid.flesh_s       ] = "flesh",
      [clsid.fracture_s    ] = "fracture",
      [clsid.poltergeist_s ] = "poltergeist",
      [clsid.gigant_s      ] = "pseudo_gigant",
      [clsid.snork_s       ] = "snork",
      [clsid.tushkano_s    ] = "tushkano",
      [clsid.zombie_s      ] = "zombie"
    }
  end
end

-- возвращает название уровня, на котором находится smart terrain
function se_smart_terrain:get_level_name()
  return alife():level_name( game_graph():vertex( self.m_game_vertex_id ):level_id() )
end

-- регистрация объекта в симуляторе.
-- вызывается симулятором.
function se_smart_terrain:on_register()
  cse_alife_smart_zone.on_register( self )

  self:register_if_needed()
  self:initialize_if_needed()
end

function se_smart_terrain:register_if_needed()
  --' Если уже зарегистрены то ничего не делать.
  if self.registred == true then
    return
  end
  self.registred = true

  -- DEBUG
  if self.disabled then
    return
  end

  local level_name = self:get_level_name()

  if not smart_terrains[level_name] then
    smart_terrains[level_name] = {}
  end

  smart_terrains[level_name][self.id] = self

  self.gulag:load_jobs()

  if self.gulag_working then
    self.gulag:initialize()
  end

  -- Регистрация в таскменеджере
  task_manager.get_random_task():register_target(self, clsid_smart_terrain)
end



-- дерегистрация объекта в симуляторе.
-- вызывается симулятором.
function se_smart_terrain:on_unregister()
  cse_alife_smart_zone.on_unregister( self )

  local lvl_smarts = smart_terrains[self:get_level_name()]

  if lvl_smarts then
    lvl_smarts[self.id] = nil
  end

  db.actor_proxy:deinit()
end

-- вызвать спавнер, если настроен.
function se_smart_terrain:call_respawn()
  if self.gparams.respawn then
    se_respawn.spawn( self.gparams.respawn )
  end
end

-- Обновление.
-- В онлайне вызывается через binder.
-- Также может вызваться принудительно из xr_effects
-- Если мужиков в гулаге больше не осталось или условия существования гулага не выполняются, то убрать гулаг.
function se_smart_terrain:update()
  cse_alife_smart_zone.update( self )

  if not self.gulag_working then
    return
  end

  if self:is_gulag_available() then
    if self.check_time < game.get_game_time() then
      self.check_time = game.get_game_time() + check_period

      --' проверять, не собрался ли кто-то к этому времени уже уходить
      for id, npc_info in pairs( self.npc_info ) do
        if npc_info.cond and xr_logic.pick_section_from_condlist( db.actor_proxy, npc_info.se_obj, npc_info.cond ) == nil then
          self:unregister_npc( npc_info.se_obj )
        end
      end

      if self.gulag:get_population() == 0 then
        self:remove_gulag()
      else
        self.gulag:update()
      end
    end
  else
    self:remove_gulag()
  end
end

--------------------
function on_death( obj_id )
	local sim = alife()
  if sim then
    local obj     = sim:object( obj_id )
		if obj == nil or (type(obj.smart_terrain_id) ~= "function") then return end
		local strn_id = obj:smart_terrain_id()
		if strn_id ~= 65535 then
	      sim:object( strn_id ).gulag:clear_dead(obj_id)
	    end
	end
end

-----------------------
--' Удаляет объект из смарттеррейнов.
function unregister_npc(npc)
  local sim = alife()

  if sim then
    local obj     = sim:object(npc.id)
		if obj == nil or (type(obj.smart_terrain_id) ~= "function") then return end
    local strn_id = obj:smart_terrain_id()

    if strn_id ~= 65535 then
      if sim:object(strn_id) then
        sim:object(strn_id):unregister_npc(obj)
      end
    end
  end
end



--------------------
-- прочитать секцию [smart_terrains]
-- вызывается объектами, которые могут ходить под smart terrain
function read_smart_terrain_conditions( self )
  if self.ini and self.ini:section_exist( smart_section ) then
    local conds = {}
    local accepts = false
    local result, field, str
    local n = self.ini:line_count( smart_section )

    if n > 0 then
      for i = 0, n-1 do
        result, field, str = self.ini:r_line( smart_section, i, "", "" )
        str=string.gsub(str,"{\-aes_arrive_to}","true")
        conds[field] = xr_logic.parse_condlist_q(str)
      end

      return conds
    end
  end

  return nil
end
