----------------------------------------------------------------------------------------------------
-- Mob Camp
----------------------------------------------------------------------------------------------------
-- Разработчик: Jim
----------------------------------------------------------------------------------------------------

local camp_storage = {}
local STATE_CAMP					= 1
local STATE_ALIFE					= 2
local STATE_MOVE_HOME				= 3

local math_random = math.random

function set_state(obj, state)
	if not state then
		return
	end

	if obj and obj:clsid() == clsid_bloodsucker_s then
		if state == "invis" then
			obj:set_invisible(true)
			return
		elseif state == "vis" then
			obj:set_invisible(false)
			return
		end
	end

	abort("mob_camp.set_state: object '%s': unknown state '%s' requested", obj:name(), tostring(state))
end

class "mob_camp"

----------------------------------------------------------------------------------------------------
-- CONSTRUCTION SCHEME
----------------------------------------------------------------------------------------------------
function mob_camp:__init(obj, storage)
	self.object = obj
	self.st		= storage
	self.is_dead = false
end

----------------------------------------------------------------------------------------------------
-- RESET SCHEME
----------------------------------------------------------------------------------------------------
function mob_camp:reset_scheme()
	xr_logic.mob_capture		(self.object, true)

	set_state(self.object, self.st.state)

	-- reset signals
	self.st.signals				= {}

	-- initialize look point
	self.look_path = patrol(self.st.look_point)
	if not self.look_path then
		abort("object '%s': unable to find look_point '%s' on the map",
		      self.object:name(), self.st.look_point)
	end

	-- initialize home point
	if self.st.home_point then
		self.home_path = patrol(self.st.home_point)
		if not self.home_path then
			abort("object '%s': unable to find home_point '%s' on the map",
			      self.object:name(), self.st.home_point)
		end
	else
		self.home_path = nil
	end

	-- checkings
	-- if there is home path and look path - point count must be equal
	if self.home_path then
		if (self.home_path:count() ~= self.look_path:count()) then
			abort("object '%s': you must setup home path points count must be equal to look path points count!", self.object:name())
		end
	end

	-- save position and node of object
	self.camp_position		= vector():set(self.object:position())
	self.camp_node			= self.object:level_vertex_id()

	self.state_current		= STATE_CAMP
	self.state_prev			= self.state_current

	-- select cur point
	self.cur_point_index	= 0
	self:select_current_home_point(true)

	self.time_point_changed = time_global()

	self.prev_enemy			= false

	-- check enemy transfering
	if self.st.skip_transfer_enemy then
		self.object:skip_transfer_enemy(true)
	end
end

----------------------------------------------------------------------------------------------------
-- UPDATE
----------------------------------------------------------------------------------------------------

function mob_camp:update(delta)
	if self.is_dead then return end -- no need to do additional processing

	if xr_logic.try_switch_to_another_section(self.object, self.st) then
		return
	end

	-- if dead then release
	if not self.object:alive() then
		xr_logic.mob_release(self.object)
		self.is_dead = true
		return
	end

	-- update point changer
	if (self.time_point_changed + self.st.time_change_point < time_global()) then
		self:select_current_home_point(false)
		self.time_point_changed = time_global()
	end

	-- update fsm
	self:select_state	()
	self:execute_state  ()

end

----------------------------------------------------------------------------------------------------
-- SERVICE FUNCTIONS
----------------------------------------------------------------------------------------------------
function mob_camp:select_current_home_point(first_call)
	local prev_point_index = self.cur_point_index

	if self.home_path then
		-- fill table of free points
		local free_points	= {}

		local camp_st = camp_storage[self.st.home_point]
		if (camp_st == nil) then
			camp_st = {}
			camp_storage[self.st.home_point] = camp_st
		end

		for i = 1, self.home_path:count() do
			if (camp_st[i] == nil) or
				(camp_st[i] == false) then
				free_points[#free_points+1] = i
			end
		end

		if (#free_points < 1) then
			if first_call == true then
				abort("Mob_Camp : too many campers for home path")
				return
			end
		else
			local free_points_index = math_random(1, #free_points)
			self.cur_point_index	= free_points[free_points_index]-1
		end

		if not first_call then
			if prev_point_index ~= self.cur_point_index then
				camp_st[prev_point_index+1] = false
			end
		end
		camp_st[self.cur_point_index+1]	= true
	else
		self.cur_point_index	= math_random(0, self.look_path:count() - 1)
	end
end

---------------------------------------------------------------------------------
function mob_camp:select_state()
	self.state_prev = self.state_current

	local home_position = self.camp_position
	local home_node		= self.camp_node

	if self.home_path then
		home_position	= self.home_path:point(self.cur_point_index)
		home_node		= self.home_path:level_vertex_id(self.cur_point_index)
	end

	-- if enemy
	local enemy = self.object:get_enemy()

	-- if enemy just appeared - signal
	if enemy ~= nil then
		if not self.prev_enemy then
			self.st.signals["enemy"] = true
		end
		self.prev_enemy = true
	else
		self.prev_enemy = false
	end

	if enemy ~= nil then
		local enemy_dist	= enemy:position():distance_to(home_position)
		--local my_dist		= self.object:position():distance_to(home_position)

		if (self.state_prev == STATE_MOVE_HOME) and (enemy_dist > self.st.home_min_radius) then
		elseif (self.state_prev == STATE_ALIFE) and (enemy_dist > self.st.home_max_radius) then
			self.state_current = STATE_MOVE_HOME
		elseif (self.state_prev == STATE_CAMP) and (enemy_dist > self.st.home_min_radius) then
		else
			self.state_current = STATE_ALIFE
		end

	end

	-- select MOVE_HOME OR CAMP
	if (enemy == nil) or ((enemy ~= nil) and (self.state_current ~= STATE_ALIFE) ) then
		-- check if we go home
		if  (home_position:distance_to(self.object:position()) > 1) and
			(home_node ~= self.object:level_vertex_id()) then
			self.state_current = STATE_MOVE_HOME
		else
			-- we are on place - camp!
			self.state_current = STATE_CAMP
		end
	end

	-- Отпускать в alife монстров, которых обстреляли
	local h = self.object:get_monster_hit_info()
	if (enemy == nil) and (h.who) and (h.time ~= 0) and (h.who:is_monster() or h.who:is_stalker()) then
		local dist = self.object:position():distance_to(home_position)
		if (dist < self.st.home_min_radius) then
			self.state_current = STATE_ALIFE
		end
	end

end

----------------------------------
-- EXECUTE_STATE
function mob_camp:execute_state()
	if (self.state_current == STATE_ALIFE) and (self.state_prev == STATE_ALIFE) then
		return
	end

	if (self.state_current == STATE_ALIFE) and (self.state_prev ~= STATE_ALIFE) then
		xr_logic.mob_release(self.object)
		return
	end

	if (self.state_current ~= STATE_ALIFE) and (self.state_prev == STATE_ALIFE) then
		xr_logic.mob_capture(self.object, true)
	end

	-- STATE_CAMP
	if self.state_current == STATE_CAMP then
		-- handle look point
		if not self.object:action() then
			action(	self.object,
					anim(anim.stand_idle),
					look(look.point, self.look_path:point(self.cur_point_index)),
					cond(cond.look_end)
			)
		end

		return
	end

	-- STATE_MOVE_HOME
	if self.state_current == STATE_MOVE_HOME then
		if not self.object:action() then

			local home_position = self.camp_position
			local home_node		= self.camp_node

			if self.home_path then
				home_position	= self.home_path:point(self.cur_point_index)
				home_node		= self.home_path:level_vertex_id(self.cur_point_index)
			end

			action(	self.object,
					move(move.run_fwd,
					home_node,
					home_position),
					cond(cond.move_end))
		end
		return
	end

end

function mob_camp:deactivate()
	if self.home_path then
		camp_storage[self.st.home_point][self.cur_point_index+1] = false
	end
	self.object:skip_transfer_enemy(false)
end

function mob_camp:net_destroy()
	if self.home_path then
		camp_storage[self.st.home_point][self.cur_point_index+1] = false
	end
	self.object:skip_transfer_enemy(false)
end

----------------------------------------------------------------------------------------------------
-- ADD_TO_BINDER
----------------------------------------------------------------------------------------------------
function add_to_binder(npc, storage)
	-- Зарегистрировать все actions, в которых должен быть вызван метод reset_scheme при изменении настроек схемы:
	storage.actions[ mob_camp(npc, storage) ] = true
end

----------------------------------------------------------------------------------------------------
-- SET_SCHEME
----------------------------------------------------------------------------------------------------
function set_scheme(npc, ini, scheme, section, gulag_name)
	local storage				= xr_logic.assign_storage_and_bind(npc, ini, scheme, section)

	storage.logic				= xr_logic.cfg_get_switch_conditions(ini, section, npc)

	if section and ini:section_exist(section) then
		if gulag_name and gulag_name ~= "" then
			gulag_name = gulag_name .. "_"
			if ini:line_exist(section, "path_look") then storage.look_point  = gulag_name .. ini:r_string(section, "path_look") end
			if ini:line_exist(section, "path_home") then storage.home_point  = gulag_name .. ini:r_string(section, "path_home") end
		else
			if ini:line_exist(section, "path_look") then storage.look_point  = ini:r_string(section, "path_look") end
			if ini:line_exist(section, "path_home") then storage.home_point  = ini:r_string(section, "path_home") end
		end
		if ini:line_exist(section, "state") then
			storage.state = ini:r_string(section, "state")
			if storage.state == "" then storage.state = nil end
		else
			storage.state = nil
		end
		storage.time_change_point	= (ini:line_exist(section, "time_change_point") and ini:r_float(section, "time_change_point")) or 10000
		storage.home_min_radius		= (ini:line_exist(section, "home_min_radius") and ini:r_float(section, "home_min_radius")) or 30
		storage.home_max_radius		= (ini:line_exist(section, "home_max_radius") and ini:r_float(section, "home_max_radius")) or 40
		-- load transfer enemy flag ()
		storage.skip_transfer_enemy = ini:line_exist( section, "skip_transfer_enemy")
	else
		storage.state = nil
		storage.time_change_point	= 10000
		storage.home_min_radius		= 30
		storage.home_max_radius		= 40
	end
	-- check min and max radius
	if	storage.home_min_radius > storage.home_max_radius then
		abort("Mob_Camp : Home Min Radius MUST be < Max Radius")
	end

	-- check if there is look point (must be!)
	if (not storage.look_point) or (not patrol(storage.look_point)) then
		abort("Mob_Camp : object '%s': unable to find look_point '%s' on the map",
					npc:name(), storage.look_point)
	end
end

