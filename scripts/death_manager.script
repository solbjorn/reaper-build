local string_find = string.find

--' Ключем является группировка персонажа. Значением является таблица, содержашая имена секций предметов.
local item_by_community = {}

--' Зависимости в спауне предметов. Предмет спауниться только если есть хотя бы один из зависимых.
local item_dependence = {}
local ammo_types = {}

--' Множители и минимаксы для выпадения вещей в зависимости от уровня
local count_by_level = {}

--' Предметы, которые нельзя удалять (квестовые например)
local always_keep_item = {}
local always_offs_items = {
	["device_pda"]=true,
	["hand_radio"]=true,
	["guitar_a"]=true,
	["harmonica_a"]=true,
	["binocular_a"]=true,
	["wpn_knife"]=true,
	["wpn_binoc"]=true,
	["bolt"]=true,
	["grenade_f1"]=true,
	["grenade_rgd5"]=true,
	["bandage"]=true,
	["medkit"]=true,
	["medkit_army"]=true,
	["medkit_scientic"]=true,
	["antirad"]=true,
	["bread"]=true,
	["kolbasa"]=true,
	["conserva"]=true,
	["vodka"]=true,
	["sigaret"]=true,
	["energy_drink"]=true
}
for k, v in pairs(ammo_section) do
	always_offs_items[k] = v
end

local dead_portion_names = {
	["snip_esc1"]	= true,
	["snip_esc2"]	= true,
	["snip_esc3"]	= true,
	["snip_esc4"]	= true,
	["snip_esc5"]	= true,
	["snip_esc6"]	= true,
	["snip_esc7"]	= true,
	["snip_esc8"]	= true,
	["snip_esc9"]	= true,
	["snip_esc10"]	= true,
	["snip_esc11"]	= true,
	["snip_esc12"]	= true,
	["naem_zahar1"]	= true,
	["naem_zahar2"]	= true,
	["naem_zahar3"]	= true,
	["naem_zahar4"]	= true,
	["naem_zahar5"]	= true,
	["naem_zahar6"]	= true
}
for k, v in pairs(dead_portion_names) do
	dead_portion_names[k] = k .. "_dead"
end
dead_portion_names["ecolog_wound_bunker"] = "ucen_talk_est"

out_by_name = {
	["esc_wolf"]				= "neytral_gaz_outfit_m2",
	["esc_stalker_fanat"]			= "neytral_gaz_outfit_m2",
	["esc_fox"]				= "neytral_gaz_outfit_m2",
	["esc_provodnik"]			= "neytral_gaz_outfit_m2",
	["gar_hellcar"]				= "neytral_gaz_outfit_m2",
	["gar_seryi"]				= "neytral_gaz_outfit_m2",
	["agr_krot"]				= "neytral_gaz_outfit_m2"
}

-- Таблица для проверки в лоб. Порядок не имеет значения.
local visuals = {
	["stalker_bandit"]			= "bandit_outfit",
	["stalker_bandit_1"]			= "bandit_outfit_red1",
	["stalker_bandit_4"]			= "bandit_outfit_red",
	["stalker_bandit_5"]			= "bandit_outfit_blue",
	["stalker_bandit_8"]			= "bandit_gaz_outfit_m1",
	["stalker_bandit_drunk"]		= "outfit_bandit_m1",
	["stalker_bandit_veteran"]		= "bandit_veteran_outfit",
	["stalker_bandit_borov"]		= "bandit_master_outfit",
	["stalker_bandit_master"]		= "bandit_master_outfit",
	["stalker_bandit_exoskeleton"]		= "exo_bandit_outfit",
	-- dolg

	["stalker_do_antigas"]			= "dolg_gaz_outfit_m1",
	["stalker_do_komandir"]			= "outfit_dolg_m1",
	["stalker_do_nauchniy"]			= "dolg_scientific_outfit",
	["stalker_do_exoskeleton"]		= "dolg_black_exoskeleton",
	-- ecolog
	["stalker_ecolog"]			= "ecolog_outfit",
	["nauchniy_1"]				= "ecolog_outfit",
	["protect_suit2"]			= "ecolog_outfit",
	["stalker_ecolog_military"]		= "protection_outfit",
	["stalker_chemical"]			= "protection_outfit",
	["nauchniy_0"]				= "protection_outfit",
	["protect_suit1"]			= "protection_outfit",
	["stalker_nano"]			= "nano_outfit",
	-- izgoy
	["izgoy"]				= "bandit_veteran_outfit",
	-- killer

	["stalker_ki_head_1"]			= "outfit_killer_m1",
	["stalker_ki_antigas"]			= "killer_gaz_outfit_m1",
	["stalker_ki_nauchniy"]			= "merc_scientific_outfit",
	["stalker_ki_exoskeleton"]		= "killer_blue_exoskeleton",
	["stalker_france_killer_antigas"]	= "stalker_usa_killer_gaz",
	["stalker_usa_killer_antigas"]		= "stalker_france_killer_gaz",
	-- militari
	["stalker_militari_1"]			= "military_outfit",
	["stalker_militari_antigas_1"]		= "military_outfit",
	["stalker_military"]			= "military_outfit",
	["stalker_military_green"]		= "military_outfit",
	["stalker_militari_2"]			= "militaryspec_outfit",
	["stalker_militari_antigas_2"]		= "militaryspec_outfit",
	["stalker_commander"]			= "militaryspec_outfit",
	["stalker_military_black"]		= "militaryspec_outfit",
	["stalker_rus_spec"]			= "rus_spec_outfit",
	["stalker_zp_exoskeleton"]		= "military_exo_outfit",
	-- monolit
	["stalker_monolit"]			= "monolit_outfit",
	["stalker_mo_hood_9"]			= "monolit_gaz_outfit_m1",
	["stalker_mo_nauchniy"]			= "monolit_scientific_outfit",
	["stalker_mo_exo"]			= "monolit_exoskeleton",
	-- nauchniy (see ecolog)
	-- neytral
	["stalker_hood"]			= "stalker_outfit",
	["stalker_bar_security"]		= "stalker_guard_outfit",
	["stalker_neytral_hood_9"]		= "neytral_gaz_outfit_m1",
	["stalker_2_gas"]			= "neytral_gaz_outfit_v1",
	["stalker_2_mask"]			= "stalker_outfit_v1",
	["stalker_3_gas"]			= "neytral_gaz_outfit_v2",
	["stalker_3_mask"]			= "stalker_outfit_v2",
	["stalker_4_gas"]			= "neytral_gaz_outfit_v3",
	["stalker_4_rozh3"]			= "stalker_outfit_v3",

	["stalker_prizrak"]			= "outfit_stalker_m1",
	["stalker_neytral_nauchniy"]		= "scientific_outfit",
	["stalker_scien"]			= "scientific_outfit",
	["stalker_neytral_exoskeleton"]		= "exo_outfit",
	["stalker_exoskeleton"]			= "exo_outfit",
	-- novice
	["stalker_novice"]			= "novice_outfit",
	["green_stalker_1"]			= "neytral_novice_outfit_m1",
	["green_stalker_3"]			= "novice_outfit_rain_1",
	["green_stalker_5"]			= "neytral_novice_outfit_m1",
	["green_stalker_6"]			= "novice_outfit_rain_2",
	["green_stalker_7"]			= "neytral_novice_outfit_cam_2",
	["green_stalker_8"]			= "neytral_novice_outfit_cam_3",
	["green_stalker_9"]			= "novice_outfit_new_1",
	["green_stalker_10"]			= "neytral_novice_outfit_m1",
	["green_stalker_11"]			= "neytral_novice_outfit_m1",
	["green_stalker_antigas"]		= "neytral_novice_gaz_outfit_m1",
	-- protect (see ecolog)
	-- soldier
	["soldier_mask"]			= "outfit_soldier_m1",
	["soldier_obichniy"]			= "outfit_soldier_m1",
	["stalker_soldier"]			= "outfit_soldier_m1",
	["soldier_spetsnaz"]			= "specops_outfit",
	["stalker_specops"]			= "specops_outfit",
	["soldier_antigas"]			= "outfit_specnaz_m1",
	-- stalker_zombi
	["stalker_zombie1"]			= "bandit_outfit",
	["stalker_zombie2"]			= "dolg_outfit",
	["zombie_fresh_1"]			= "dolg_outfit",
	["stalker_zombie3"]			= "stalker_outfit",
	["stalker_zombie6"]			= "stalker_outfit",
	["zombie_fresh_2"]			= "stalker_outfit",
	["stalker_zombie4"]			= "killer_outfit",
	["stalker_zombie5"]			= "stalker_guard_outfit",
	["stalker_zombie7"]			= "novice_outfit",
	["stalker_zombie8"]			= "neytral_novice_outfit_m1",
	["stalker_zombie_specnaz"]		= "specops_outfit",
	["zombie_fresh_0"]			= "svoboda_heavy_outfit",
	["zombie_exoskeleton"]			= "broken_exoskeleton",
	-- svoboda
	["stalker_sv_rukzak_1_1"]		= "svoboda_light_outfit",
	["stalker_sv_rukzak_3"]			= "svoboda_light_outfit",
	["stalker_svoboda_light"]		= "svoboda_light_outfit",
	["stalker_sv_rukzak_1"]			= "svoboda_heavy_outfit",
	["stalker_sv_rukzak_2"]			= "svoboda_heavy_outfit",
	["stalker_sv_rukzak_3_1"]		= "svoboda_heavy_outfit",
	["stalker_sv_cook"]			= "svoboda_heavy_outfit",
	["stalker_sv_max"]			= "svoboda_heavy_outfit",
	["stalker_svoboda_heavy"]		= "svoboda_heavy_outfit",
	["stalker_sv_hood_91"]			= "svoboda_gaz_outfit_m1",
	["stalker_sv_hood_9"]			= "svoboda_heavy_gaz_outfit_m1",
	["stalker_sv_nauchniy"]			= "freedom_scientific_outfit",
	["stalker_sv_exoskeleton"]		= "svoboda_exoskeleton",
	["stalker_sv_leader"]			= "outfit_svoboda_m1"
}

-- Если ничего не нашло по прямому соответствию, то будет поиск по части названия
-- Порядок следования в таблице имеет значение!! Сортировать её нельзя!
-- Бессмысленно сначала искать по "neytral", а потом - по "stalker_neytral"!
-- Можно только наоборот.
local sect_by_visual_part = {
	["stalker_bandit"]			= "bandit_outfit",
	["stalker_do"]				= "dolg_outfit",
	["stalker_ki"]				= "killer_outfit",
	["stalker_mo"]				= "monolit_outfit",
	["stalker_neytral_rukzak"]		= "outfit_stalker_m2",
	["stalker_neytral"]			= "stalker_outfit",
	["soldier_bandana"]			= "outfit_soldier_m1",
	["soldier_beret"]			= "outfit_soldier_m1",
	["stalker_sv_balon_1"]			= "svoboda_heavy_outfit"
}

local out_grades = {
	["bandit_outfit"]			= 1,
	["outfit_bandit_m1"]			= 1,
	["bandit_gaz_outfit_m1"]		= 1,
	["bandit_veteran_outfit"]		= 1,
	["bandit_master_outfit"]		= 1,
	["novice_outfit"]			= 1,
	["neytral_novice_outfit_m1"]		= 1,
	["neytral_novice_gaz_outfit_m1"]	= 1,

	["stalker_outfit"]			= 2,
	["killer_outfit"]			= 2,
	["outfit_soldier_m1"]			= 2,
	["svoboda_light_outfit"]		= 2,
	["svoboda_gaz_outfit_m1"]		= 2,

	["dolg_outfit"]				= 3,
	["dolg_gaz_outfit_m1"]			= 3,
	["ecolog_outfit"]			= 3,
	["outfit_dolg_m1"]			= 3,
	["outfit_killer_m1"]			= 3,
	["killer_gaz_outfit_m1"]		= 3,
	["specops_outfit"]			= 3,
	["outfit_specnaz_m1"]			= 3,
	["monolit_outfit"]			= 3,
	["monolit_gaz_outfit_m1"]		= 3,
	["stalker_guard_outfit"]		= 3,
	["outfit_stalker_m1"]			= 3,
	["outfit_stalker_m2"]			= 3,
	["neytral_gaz_outfit_m1"]		= 3,
	["neytral_gaz_outfit_m2"]		= 3,
	["svoboda_heavy_outfit"]		= 3,
	["svoboda_heavy_gaz_outfit_m1"]		= 3,
	["outfit_svoboda_m1"]			= 3,

	["dolg_scientific_outfit"]		= 4,
	["ecolog_outfit"]			= 4,
	["protection_outfit"]			= 4,
	["merc_scientific_outfit"]		= 4,
	["military_outfit"]			= 4,
	["militaryspec_outfit"]			= 4,
	["monolit_scientific_outfit"]		= 4,
	["scientific_outfit"]			= 4,
	["freedom_scientific_outfit"]		= 4
}

local grade_rnds = {
	[1]	= 650,
	[2]	= 550,
	[3]	= 450,
	[4]	= 350,
	[5]	= 250
}

local weap_conds = {
	bandit		= 40,
	dolg		= 60,
	ecolog		= 60,
	freedom		= 60,
	green		= 60,
	killer		= 75,
	military	= 75,
	monolith	= 20,
	sniper		= 60,
	stalker		= 60,
	zombied		= 5
}

local math_ceil   = math.ceil
local math_random = math.random

function outfit_cond(grade, id, obj)
	local rnd, add

	rnd = grade * 10 + 10
	add = 65 - grade * 10

	obj:set_condition((math_random(rnd) + add) / 100)
end

function init_drop_settings()
	local death_ini = ini_file("misc\\death_generic.ltx")

	--' Множители и минимаксы для выпадения вещей в зависимости от уровня
	local level_name = level.name()
	if not death_ini:section_exist(level_name) then level_name = "default" end

	--' Вспомогательная таблица. Чего здесь нет или что будет 0, будет удалено из списка для группировки
	local mul_by_level = {}
	local vvv

	--' Заполняем новые для данной локации
	death_ini:iterate_lines(level_name, function(result, id, value)
		--' Если предмет запрещён для данной локации, просто не добавляем его в список
		vvv = tonumber(value)
		if vvv > 0 then
			mul_by_level[id] = vvv
		end
	end)

	local item_count_section, t, _min, _max
	for i = 0, 3 do
		--' Вероятности для выпадения вещей в зависимости от уровня сложности
		item_count_section = "item_count_" .. i

		--' Заполняем новые для данного уровня сложности
		death_ini:iterate_lines(item_count_section, function(result, id, value)
			--' Если предмет не был в списке для уровня вообще или он здесь запрещён, просто не добавляем его в список
			if not mul_by_level[id] then return end

			--' Нужно распарсить value в два значения
			t = value:parse_nums()
			if t[1] == nil then
				abort("Error on [death_ini] declaration. Section [%s], line [%s]", item_count_section, tostring(id))
				return
			end

			_min = t[1]
			_max = t[2] or _min
			if _max < _min then _max = _min end
			if _max == 0 then return end

			if not count_by_level[id] then count_by_level[id] = { } end
			count_by_level[id][i] = {
				["min"]	= _min * mul_by_level[id],
				["max"]	= _max * mul_by_level[id]
			}
		end)
	end

	--' Разрешения для выпадения вещей в зависимости от группировки
	for k,v in pairs(weap_conds) do
		--' Необходимо заполнить таблицу
		--' Удаляем старые значения
		item_by_community[k] = {}

		--' Заполняем новые для данной группировки
		death_ini:iterate_lines(k, function(result, id, value)
			--' Если предмет не был в списке для локации вообще или он здесь запрещён, просто не добавляем его в список
			if not mul_by_level[id] then return end

			--' Если для предмета нету вероятности, то это ошибка!
			if not count_by_level[id] then
				abort("Error on [death_ini] declaration. Item [%s] is configured for community [%s], but has no probability for any difficulty", id, k)
				return
			end

			--' Если предмет запрещён для данной группировки, просто не добавляем его в список
			vvv = tonumber(value)
			if vvv == 0 then return end
			if vvv >= 0.4 then vvv = 0.2 end

			item_by_community[k][id] = 1000 * vvv
		end)
	end

	--' Предметы, которые нельзя удалять (квестовые например)
	death_ini:iterate_lines("keep_items", function(result, id, value)
		if value == "true" then
			always_keep_item[id] = true
		end
	end)

	--' Заполняем таблицу зависимостей
	death_ini:iterate_lines("item_dependence", function(result, id, value)
		item_dependence[id] = {}
		vvv = string.parse_names(value)
		for k,v in pairs(vvv) do
			item_dependence[id][v] = true
			if ammo_types[v] == nil then ammo_types[v] = {} end
			ammo_types[v][id] = true
		end
	end)
end

class "drop_manager"
function drop_manager:__init(npc)
	self.npc = npc
end

function drop_manager:create_release_item()
	local self_npc = self.npc
	if self_npc == nil then return end
	--' Спрашиваем у серверного объекта генерились ли предметы
	local se_obj = server_object(self_npc)
	se_obj.death_droped = true

	local npc_ammo = {}
	local cond = weap_conds[self_npc:character_community()]

	--' Запускаем итератор на удаление предметов
	self_npc:iterate_inventory(function(arg, item)
		local section = item:section()
		if section == "bolt" then return end

		if always_offs_items[section] then
			release(item)
			return
		end

		if always_keep_item[section] or not item:is_weapon() then
			item:set_condition(item:condition())
			return
		end

		local from = get_inventory_item_data(item, "slot") == 2 and 95 or 90

		--' Тут надо уменьшить кондишн оружия
		item:set_condition((math_random(from-cond)+cond)*item:condition()/100)
		item:set_ammo_elapsed(0)

		for k, v in pairs(ammo_types[section]) do
			npc_ammo[k] = v
		end
	end)

    --' Проверка на отсутствие спауна лута
    local ini = self_npc:spawn_ini()

    if ini and ini:section_exist("dont_spawn_loot") then
        return
    end

    --' Доспавниваем необходимое количество итемов:
    --' Необходимо составить список объектов которые могут быть заспавнены для персонажа
	local npc_pos, npc_lvid, npc_gvid, npc_id = self_npc:position(), self_npc:level_vertex_id(), self_npc:game_vertex_id(), self_npc:id()
    local spawn_items = item_by_community[self_npc:character_community()]
    if spawn_items then
	local diff = level.get_game_difficulty()
	local count, number
	for k,v in pairs(spawn_items) do
		--' По каждому объекту необходимо получить зависимости
		if item_dependence[k] == nil then
			count = count_by_level[k][diff]
			number = count and math_ceil(math_random(count["min"], count["max"])) or 0
			--' Необходимо заспавнить нужное количество.
			for i=1,number do
				--' Проверяем вероятность появить каждый объект в отдельности
				if math_random(1000) <= v then
					alife():create(k, npc_pos, npc_lvid, npc_gvid, npc_id)
				end
			end
		elseif npc_ammo[k] then
			--' По каждому объекту необходимо получить количество
			count = count_by_level[k][diff]
			number = count and math_ceil(math_random(count["min"], count["max"])) or 0
			--' Необходимо заспавнить нужное количество.
			if number > 0 then
				if ammo_section[k] == true then
					se_respawn.create_ammo(k, npc_pos, npc_lvid, npc_gvid, npc_id, number)
				else
					for i=1,number do
						--' Проверяем вероятность появить каждый объект в отдельности
						if math_random(1000) <= v then
							alife():create(k, npc_pos, npc_lvid, npc_gvid, npc_id)
						end
					end
				end
			end
		end
	end
    end

	local vis, sect, otf
	local npc_name = self_npc:name()
	if not string_find(self_npc:section(), "arena") and
	   self_npc:character_community() ~= "arena_enemy" and
	   npc_name ~= "yan_specnaz_dead" and
	   npc_name ~= "x16_stalker_ghost" then
		sect = out_by_name[npc_name]
		if not sect then
			local t = amk.read_stalker_params(se_obj)
			if t then
				vis = t.visual
				vis = amk.str_explode("\\", vis)
				vis = vis[3]
			end
			if vis then sect = visuals[vis] end
		end -- not sect
		if not sect and vis then
			for k,v in pairs(sect_by_visual_part) do
				if string_find(vis, k) then
					sect = v
					break
				end
			end -- pairs
		end -- not sect and vis
		if sect then
			local grade = out_grades[sect] or 5
			if math_random(1000) <= (grade_rnds[grade] or 250) then
				local otf = create(sect, npc_pos, npc_lvid, npc_gvid, npc_id)
				if otf then
					level.client_spawn_manager():add(otf.id, 0, outfit_cond, grade)
				end
			end
		end -- sect
	end -- string_find("arena")

	local info = dead_portion_names[npc_name]
	if info and not has_info(info) then
		Actor:give_info_portion(info)
	end
end
