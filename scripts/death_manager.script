local string_find = string.find

--' Ключем является группировка персонажа. Значением является таблица, содержашая имена секций предметов.
local item_by_community = {}

--' Зависимости в спауне предметов. Предмет спауниться только если есть хотя бы один из зависимых.
local item_dependence = {}

--' Множители и минимаксы для выпадения вещей в зависимости от уровня
local count_by_level = {}

--' Предметы, которые нельзя удалять (квестовые например)
local always_keep_item = {}
local always_offs_items = {
	["device_pda"]=true,
	["hand_radio"]=true,
	["guitar_a"]=true,
	["harmonica_a"]=true,
	["binocular_a"]=true,
	["wpn_knife"]=true,
	["wpn_binoc"]=true,
	["bolt"]=true,
	["grenade_f1"]=true,
	["grenade_rgd5"]=true,
	["bandage"]=true,
	["medkit"]=true,
	["medkit_army"]=true,
	["medkit_scientic"]=true,
	["antirad"]=true,
	["bread"]=true,
	["kolbasa"]=true,
	["conserva"]=true,
	["vodka"]=true,
	["sigaret"]=true,
	["energy_drink"]=true
}

local dead_portion_names = {
	["snip_esc1"]	= true,
	["snip_esc2"]	= true,
	["snip_esc3"]	= true,
	["snip_esc4"]	= true,
	["snip_esc5"]	= true,
	["snip_esc6"]	= true,
	["snip_esc7"]	= true,
	["snip_esc8"]	= true,
	["snip_esc9"]	= true,
	["snip_esc10"]	= true,
	["snip_esc11"]	= true,
	["snip_esc12"]	= true,
	["naem_zahar1"]	= true,
	["naem_zahar2"]	= true,
	["naem_zahar3"]	= true,
	["naem_zahar4"]	= true,
	["naem_zahar5"]	= true,
	["naem_zahar6"]	= true
}
for k, v in pairs(dead_portion_names) do
	dead_portion_names[k] = k .. "_dead"
end
dead_portion_names["ecolog_wound_bunker"] = "ucen_talk_est"

out_by_name = {
	["esc_wolf"]				= "neytral_gaz_outfit_m2",
	["esc_stalker_fanat"]			= "neytral_gaz_outfit_m2",
	["esc_fox"]				= "neytral_gaz_outfit_m2",
	["esc_provodnik"]			= "neytral_gaz_outfit_m2",
	["gar_hellcar"]				= "neytral_gaz_outfit_m2",
	["gar_seryi"]				= "neytral_gaz_outfit_m2",
	["agr_krot"]				= "neytral_gaz_outfit_m2"
}

-- Таблица для проверки в лоб. Порядок не имеет значения.
local visuals = {
	["stalker_bandit"]			= "bandit_outfit",
	["stalker_bandit_1"]			= "bandit_outfit_red1",
	["stalker_bandit_4"]			= "bandit_outfit_red",
	["stalker_bandit_5"]			= "bandit_outfit_blue",
	["stalker_bandit_8"]			= "bandit_gaz_outfit_m1",
	["stalker_bandit_drunk"]		= "outfit_bandit_m1",
	["stalker_bandit_veteran"]		= "bandit_veteran_outfit",
	["stalker_bandit_borov"]		= "bandit_master_outfit",
	["stalker_bandit_master"]		= "bandit_master_outfit",
	["stalker_bandit_exoskeleton"]		= "exo_bandit_outfit",
	-- dolg

	["stalker_do_antigas"]			= "dolg_gaz_outfit_m1",
	["stalker_do_komandir"]			= "outfit_dolg_m1",
	["stalker_do_nauchniy"]			= "dolg_scientific_outfit",
	["stalker_do_exoskeleton"]		= "dolg_black_exoskeleton",
	-- ecolog
	["stalker_ecolog"]			= "ecolog_outfit",
	["nauchniy_1"]				= "ecolog_outfit",
	["protect_suit2"]			= "ecolog_outfit",
	["stalker_ecolog_military"]		= "protection_outfit",
	["stalker_chemical"]			= "protection_outfit",
	["nauchniy_0"]				= "protection_outfit",
	["protect_suit1"]			= "protection_outfit",
	["stalker_nano"]			= "nano_outfit",
	-- izgoy
	["izgoy"]				= "bandit_veteran_outfit",
	-- killer

	["stalker_ki_head_1"]			= "outfit_killer_m1",
	["stalker_ki_antigas"]			= "killer_gaz_outfit_m1",
	["stalker_ki_nauchniy"]			= "merc_scientific_outfit",
	["stalker_ki_exoskeleton"]		= "killer_blue_exoskeleton",
	["stalker_france_killer_antigas"]	= "stalker_usa_killer_gaz",
	["stalker_usa_killer_antigas"]		= "stalker_france_killer_gaz",
	-- militari
	["stalker_militari_1"]			= "military_outfit",
	["stalker_militari_antigas_1"]		= "military_outfit",
	["stalker_military"]			= "military_outfit",
	["stalker_military_green"]		= "military_outfit",
	["stalker_militari_2"]			= "militaryspec_outfit",
	["stalker_militari_antigas_2"]		= "militaryspec_outfit",
	["stalker_commander"]			= "militaryspec_outfit",
	["stalker_military_black"]		= "militaryspec_outfit",
	["stalker_rus_spec"]			= "rus_spec_outfit",
	["stalker_zp_exoskeleton"]		= "military_exo_outfit",
	-- monolit
	["stalker_monolit"]			= "monolit_outfit",
	["stalker_mo_hood_9"]			= "monolit_gaz_outfit_m1",
	["stalker_mo_nauchniy"]			= "monolit_scientific_outfit",
	["stalker_mo_exo"]			= "monolit_exoskeleton",
	-- nauchniy (see ecolog)
	-- neytral		
	["stalker_hood"]			= "stalker_outfit",
	["stalker_bar_security"]		= "stalker_guard_outfit",
	["stalker_neytral_hood_9"]		= "neytral_gaz_outfit_m1",
	["stalker_2_gas"]			= "neytral_gaz_outfit_v1",
	["stalker_2_mask"]			= "stalker_outfit_v1",
	["stalker_3_gas"]			= "neytral_gaz_outfit_v2",
	["stalker_3_mask"]			= "stalker_outfit_v2",
	["stalker_4_gas"]			= "neytral_gaz_outfit_v3",
	["stalker_4_rozh3"]			= "stalker_outfit_v3",

	["stalker_prizrak"]			= "outfit_stalker_m1",
	["stalker_neytral_nauchniy"]		= "scientific_outfit",
	["stalker_scien"]			= "scientific_outfit",
	["stalker_neytral_exoskeleton"]		= "exo_outfit",
	["stalker_exoskeleton"]			= "exo_outfit",
	-- novice
	["stalker_novice"]			= "novice_outfit",
	["green_stalker_1"]			= "neytral_novice_outfit_m1",
	["green_stalker_3"]			= "novice_outfit_rain_1",
	["green_stalker_5"]			= "neytral_novice_outfit_m1",
	["green_stalker_6"]			= "novice_outfit_rain_2",
	["green_stalker_7"]			= "neytral_novice_outfit_cam_2",
	["green_stalker_8"]			= "neytral_novice_outfit_cam_3",
	["green_stalker_9"]			= "novice_outfit_new_1",
	["green_stalker_10"]			= "neytral_novice_outfit_m1",
	["green_stalker_11"]			= "neytral_novice_outfit_m1",
	["green_stalker_antigas"]		= "neytral_novice_gaz_outfit_m1",
	-- protect (see ecolog)
	-- soldier
	["soldier_mask"]			= "outfit_soldier_m1", 
	["soldier_obichniy"]			= "outfit_soldier_m1", 
	["stalker_soldier"]			= "outfit_soldier_m1", 
	["soldier_spetsnaz"]			= "specops_outfit",
	["stalker_specops"]			= "specops_outfit",
	["soldier_antigas"]			= "outfit_specnaz_m1",
	-- stalker_zombi
	["stalker_zombie1"]			= "bandit_outfit",
	["stalker_zombie2"]			= "dolg_outfit",
	["zombie_fresh_1"]			= "dolg_outfit",
	["stalker_zombie3"]			= "stalker_outfit",
	["stalker_zombie6"]			= "stalker_outfit",
	["zombie_fresh_2"]			= "stalker_outfit",
	["stalker_zombie4"]			= "killer_outfit",
	["stalker_zombie5"]			= "stalker_guard_outfit",
	["stalker_zombie7"]			= "novice_outfit",
	["stalker_zombie8"]			= "neytral_novice_outfit_m1",
	["stalker_zombie_specnaz"]		= "specops_outfit",
	["zombie_fresh_0"]			= "svoboda_heavy_outfit",
	["zombie_exoskeleton"]			= "broken_exoskeleton",
	-- svoboda
	["stalker_sv_rukzak_1_1"]		= "svoboda_light_outfit",
	["stalker_sv_rukzak_3"]			= "svoboda_light_outfit",
	["stalker_svoboda_light"]		= "svoboda_light_outfit",
	["stalker_sv_rukzak_1"]			= "svoboda_heavy_outfit",
	["stalker_sv_rukzak_2"]			= "svoboda_heavy_outfit",
	["stalker_sv_rukzak_3_1"]		= "svoboda_heavy_outfit",
	["stalker_sv_cook"]			= "svoboda_heavy_outfit",
	["stalker_sv_max"]			= "svoboda_heavy_outfit",
	["stalker_svoboda_heavy"]		= "svoboda_heavy_outfit",
	["stalker_sv_hood_91"]			= "svoboda_gaz_outfit_m1",
	["stalker_sv_hood_9"]			= "svoboda_heavy_gaz_outfit_m1",
	["stalker_sv_nauchniy"]			= "freedom_scientific_outfit",
	["stalker_sv_exoskeleton"]		= "svoboda_exoskeleton",
	["stalker_sv_leader"]			= "outfit_svoboda_m1"
}

-- Если ничего не нашло по прямому соответствию, то будет поиск по части названия
-- Порядок следования в таблице имеет значение!! Сортировать её нельзя!
-- Бессмысленно сначала искать по "neytral", а потом - по "stalker_neytral"!
-- Можно только наоборот.
local sect_by_visual_part = {
	["stalker_bandit"]			= "bandit_outfit",
	["stalker_do"]				= "dolg_outfit",
	["stalker_ki"]				= "killer_outfit",
	["stalker_mo"]				= "monolit_outfit",
	["stalker_neytral_rukzak"]		= "outfit_stalker_m2",
	["stalker_neytral"]			= "stalker_outfit",
	["soldier_bandana"]			= "outfit_soldier_m1",
	["soldier_beret"]			= "outfit_soldier_m1",
	["stalker_sv_balon_1"]			= "svoboda_heavy_outfit"
}

local out_grades = {
	["bandit_outfit"]			= 1,
	["outfit_bandit_m1"]			= 1,
	["bandit_gaz_outfit_m1"]		= 1,
	["bandit_veteran_outfit"]		= 1,
	["bandit_master_outfit"]		= 1,
	["novice_outfit"]			= 1,
	["neytral_novice_outfit_m1"]		= 1,
	["neytral_novice_gaz_outfit_m1"]	= 1,

	["stalker_outfit"]			= 2,
	["killer_outfit"]			= 2,
	["outfit_soldier_m1"]			= 2,
	["svoboda_light_outfit"]		= 2,
	["svoboda_gaz_outfit_m1"]		= 2,

	["dolg_outfit"]				= 3,
	["dolg_gaz_outfit_m1"]			= 3,
	["ecolog_outfit"]			= 3,
	["outfit_dolg_m1"]			= 3,
	["outfit_killer_m1"]			= 3,
	["killer_gaz_outfit_m1"]		= 3,
	["specops_outfit"]			= 3,
	["outfit_specnaz_m1"]			= 3,
	["monolit_outfit"]			= 3,
	["monolit_gaz_outfit_m1"]		= 3,
	["stalker_guard_outfit"]		= 3,
	["outfit_stalker_m1"]			= 3,
	["outfit_stalker_m2"]			= 3,
	["neytral_gaz_outfit_m1"]		= 3,
	["neytral_gaz_outfit_m2"]		= 3,
	["svoboda_heavy_outfit"]		= 3,
	["svoboda_heavy_gaz_outfit_m1"]		= 3,
	["outfit_svoboda_m1"]			= 3,

	["dolg_scientific_outfit"]		= 4,
	["ecolog_outfit"]			= 4,
	["protection_outfit"]			= 4,
	["merc_scientific_outfit"]		= 4,
	["military_outfit"]			= 4,
	["militaryspec_outfit"]			= 4,
	["monolit_scientific_outfit"]		= 4,
	["scientific_outfit"]			= 4,
	["freedom_scientific_outfit"]		= 4
}

local grade_rnds = {
	[1]	= 650,
	[2]	= 550,
	[3]	= 450,
	[4]	= 350,
	[5]	= 250
}

local weap_conds = {
	bandit		= 40,
	killer		= 75,
	military	= 75,
	monolith	= 20,
	zombied		= 5
}

local math_ceil   = math.ceil
local math_random = math.random

function init_drop_settings()
	local mul_by_level = {}
	local death_ini = ini_file("misc\\death_generic.ltx")
        local community_list = { "stalker", "dolg", "freedom", "bandit", "military", "zombied", "ecolog", "killer", "monolith", "arena_enemy", "actor_dolg", "sniper", "green"  }

	local id, value = "", ""
	local n, result

    for k,v in pairs(community_list) do
        --' Необходимо заполнить таблицу
        item_by_community[v] = {}
        if death_ini:section_exist(v) then
                    n = death_ini:line_count(v)
                    for i=0,n-1 do
                            result, id, value        = death_ini:r_line(v,i,"","")
                                if tonumber(value) >= 0.4 then value = 0.2 end
                                item_by_community[v][id] = 1000 * tonumber(value)
                    end
        end
    end

    --' Заполняем таблицу зависимостей
        n = death_ini:line_count("item_dependence")
        for i=0,n-1 do
                result, id, value        = death_ini:r_line("item_dependence",i,"","")
                item_dependence[id] = {}
                local vvv = parse_names(value)
                for k,v in pairs(vvv) do
                        item_dependence[id][v] = true
                end
        end

        --' Множители и минимаксы для выпадения вещей в зависимости от уровня
    local level_name = level.name()

        if not death_ini:section_exist(level_name) then
                level_name = "default"
        end

    n = death_ini:line_count(level_name)
        for i=0,n-1 do
                result, id, value        = death_ini:r_line(level_name,i,"","")
        mul_by_level[id] = tonumber(value)
        end

    local item_count_section = "item_count_" .. level.get_game_difficulty()
    n = death_ini:line_count(item_count_section)
        for i=0,n-1 do
                result, id, value        = death_ini:r_line(item_count_section,i,"","")
        --' Нужно распарсить value в два значения
        local t = parse_nums(value)
                if t[1] == nil then
            abort("Error on [death_ini] declaration. Section [%s], line [%s]", item_count_section, tostring(id))
        end
        local min = t[1]
        local max = t[2]
        if max == nil then
            max = min
        end

        if mul_by_level[id] == nil then
            mul_by_level[id] = 0
        end

        min = tonumber(min) * mul_by_level[id]
        max = tonumber(max) * mul_by_level[id]

        count_by_level[id] = {min = min, max = max}
        end

         --' Предметы, которые нельзя удалять (квестовые например)
    n = death_ini:line_count("keep_items")
        for i=0,n-1 do
                result, id, value        = death_ini:r_line("keep_items",i,"","")
        if value == "true" then
            always_keep_item[id] = true
        end
    end
end

class "drop_manager"
function drop_manager:__init(npc)
	self.npc = npc
end

function drop_manager:create_release_item()
	local self_npc = self.npc
	if self_npc == nil then return end
	--' Спрашиваем у серверного объекта генерились ли предметы
	local se_obj = alife():object(self_npc:id())
	se_obj.death_droped = true

    --' Запускаем итератор на удаление предметов
    self_npc:iterate_inventory(keep_item, self_npc)

	local kond = weap_conds[self_npc:character_community()] or 60

    local item_in_slot = self_npc:item_in_slot(1)
    if item_in_slot then
		item_in_slot:set_ammo_elapsed(0)
                --' Тут надо уменьшить кондишн оружия
                item_in_slot:set_condition((math_random(90-kond)+kond)*item_in_slot:condition()/100)
    end
    item_in_slot = self_npc:item_in_slot(2)
    if item_in_slot then
		item_in_slot:set_ammo_elapsed(0)
                --' Тут надо уменьшить кондишн оружия
                item_in_slot:set_condition((math_random(95-kond)+kond)*item_in_slot:condition()/100)
    end

	-- оставляем фонарик в слоте
	item_in_slot = self_npc:item_in_slot(9)
	if item_in_slot then
		item_in_slot:set_condition(item_in_slot:condition())
	end

    --' Проверка на отсутствие спауна лута
    local ini = self_npc:spawn_ini()

    if ini and ini:section_exist("dont_spawn_loot") then
        return
    end

    --' Доспавниваем необходимое количество итемов:
    --' Необходимо составить список объектов которые могут быть заспавнены для персонажа
	local npc_pos, npc_lvid, npc_gvid, npc_id = self_npc:position(), self_npc:level_vertex_id(), self_npc:game_vertex_id(), self_npc:id()
    local spawn_items = item_by_community[self_npc:character_community()]    
    if spawn_items then
	local number
	for k,v in pairs(spawn_items) do
		--' По каждому объекту необходимо получить зависимости
		if item_dependence[k] == nil then
			number = math_ceil(math_random(count_by_level[k].min, count_by_level[k].max))
			--' Необходимо заспавнить нужное количество.
			for i=1,number do
				--' Проверяем вероятность появить каждый объект в отдельности
				if math_random(1000) <= v then
					alife():create(k, npc_pos, npc_lvid, npc_gvid, npc_id)
				end
			end
		elseif check_item_dependence(self_npc, k) then
			--' По каждому объекту необходимо получить количество
			number = math_ceil(math_random(count_by_level[k].min, count_by_level[k].max))
			--' Необходимо заспавнить нужное количество.
			if number > 0 then
				if ammo_section[k] == true then
					se_respawn.create_ammo(k, npc_pos, npc_lvid, npc_gvid, npc_id, number)
				else
					for i=1,number do
						--' Проверяем вероятность появить каждый объект в отдельности
						if math_random(1000) <= v then
							alife():create(k, npc_pos, npc_lvid, npc_gvid, npc_id)
						end
					end
				end
			end
		end
	end
    end

	local vis, sect, otf
	local npc_name = self_npc:name()
	if not string_find(self_npc:section(), "arena") and
	   self_npc:character_community() ~= "arena_enemy" and
	   npc_name ~= "yan_specnaz_dead" and
	   npc_name ~= "x16_stalker_ghost" then
		sect = out_by_name[npc_name]
		if not sect then
			local t = amk.read_stalker_params(se_obj)
			if t then
				vis = t.visual
				vis = amk.str_explode("\\", vis)
				vis = vis[3]
			end
			if vis then sect = visuals[vis] end
		end -- not sect
		if not sect and vis then
			for k,v in pairs(sect_by_visual_part) do
				if string_find(vis, k) then
					sect = v
					break
				end
			end -- pairs
		end -- not sect and vis
		if sect then
			local grade = out_grades[sect] or 5
			if math_random(1000) <= (grade_rnds[grade] or 250) then
				local otf = alife():create(sect, npc_pos, npc_lvid, npc_gvid, npc_id)
				if otf then
					amk.start_timer("amk.outfit_cond", 1, amk.pack_array_to_string({ grade, otf.id }))
				end
			end
		end -- sect
	end -- string_find("arena")

	local info = dead_portion_names[npc_name]
	if info and not has_info(info) then
		db_actor:give_info_portion(info)
	end
end

--' Функция вызывается для каждого предмета, если вернет false то предмет удалится.
function keep_item(npc, item)
	if not npc or not item then
		return
	end

	local item_id = item:id()
	local sobj = alife():object(item_id)
	if sobj == nil then return end

	local section = item:section()
	if section == "bolt" then
		return false
	end

	if always_offs_items[section] or ammo_section[section] then
		alife():release(sobj, true)
		return false
	end
    if always_keep_item[section] == true then
		item:set_condition(item:condition())
        return true
    end
end

--' Функция проверяет есть ли хоть один из зависимых объектов у персонажа
function check_item_dependence(npc, section)
    for k,v in pairs(item_dependence[section]) do
        local obj = npc:object(k)
        if obj ~= nil and npc:marked_dropped(obj) ~= true then
            return true
        end
    end

    return false
end

init_drop_settings()
