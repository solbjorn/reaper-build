local spec_list, bad_list, trader_list, barman_list, ecolog_list, dolg_list, freedom_list

function init_random_rewards()
	local ltx = ini_file("misc\\random_rewards.ltx")
	local iter

	bad_list = ltx:r_list("bad_list", "items") or { }

	for _, sect in ipairs({ "spec", "trader", "barman", "ecolog", "dolg", "freedom" }) do
		sect = sect .. "_list"
		this[sect] = linspiro.read_random(sect, ltx)
	end

	init_random_rewards = nil
end

local parent_by_story = {
  [003] = "trader",
  [500] = "barman",
  [902] = "ecolog",
  [507] = "dolg",
  [707] = "freedom",
  [006] = "wolf",
  [004] = "shustriy",
  [510] = "drunk_dolg",
  [504] = "hunter",
  [518] = "zastava_commander",
  [506] = "petrenko",
  [607] = "lisiy",
  [515] = "mercenary",
  [9613] = "green"
}
local story_by_parent = table.invert(parent_by_story)

local icon_task_by_type = {
	eliminate_lager	= true,
	eliminate_lair	= true,
	defend_lager	= true,
	kill_stalker	= true,
	artefact	= true,
	monster_part	= true,
	find_item	= true
}
for k, v in pairs(icon_task_by_type) do
	icon_task_by_type[k] = "ui_iconsTotal_" .. k
end

local is_find_task = table.tohash({ "artefact", "monster_part", "find_item" })

function relocate_good(victim, section)
	if quest_section[section] then
		transfer_good(victim, section, "out")
	else
		lost_good(section)
	end
end

local return_task_by_type = {
  eliminate_lager = "return_for_reward",
	eliminate_lair = "return_for_reward",
  defend_lager = "return_for_reward",
  kill_stalker = "return_for_reward",
  artefact = "return_for_reward_bring",
  monster_part = "return_for_reward_bring",
  find_item = "return_for_reward_bring"}

local return_location = {
	return_for_reward = "blue_location",
	return_for_reward_bring = "blue_location_2"
}

local task_status = {
	normal		= 0,
	selected	= 1,
	completed	= 2,
	refused		= 3,
	failed		= 4,
	rewarded	= 5
}

local table_insert = table.insert
local table_remove = table.remove
local string_byte = string.byte
local string_find = string.find
local string_len = string.len
local string_sub = string.sub
local math_random = math.random

local hash_to_id={}
local id_to_hash={}
-- хэш функция для строки (посмотреть литературу, на предмет оптимальной)
function stringhash(str)
  local mpl=1
  local hash=0
  for i=1,string_len(str),1 do
    local val=string_byte(string_sub(str,i,i))
    hash=hash+mpl*val
    mpl=mpl*2
    if mpl==512 then mpl=1 end
  end
  return bit_and(hash,65535)
end

class "CRandomTask"

--Функция lin_task (id квеста, торговец дающий квест)
function CRandomTask:lin_task(name, parent)
	local level = 0
	local item, qtype  = "",""

	--Делим квесты на группы в зависимости от типа
	if     string_find(name,"eliminate_camp") then
		qtype = "eliminate_camp"
	elseif string_find(name,"find_artefact")  then
		qtype = "find_artefact"
	elseif string_find(name,"kill_stalker")   then
		qtype = "kill_stalker"
	elseif string_find(name,"monster_part")   then
		qtype = "monster_part"
	elseif string_find(name,"defend_camp")    then
		qtype = "defend_camp"
	elseif string_find(name,"defend_lager")   then
		qtype = "defend_lager"
	elseif string_find(name,"eliminate_lager")then
		qtype = "eliminate_lager"
	end

	--Делим квесты на группы в зависимости от порядкового номера
	if 	   string_find(name,"1") or string_find(name,"2") then
		level = 1
	elseif string_find(name,"3") or string_find(name,"4") then
		level = 2
	elseif string_find(name,"5") or string_find(name,"6") then
		level = 3
	elseif string_find(name,"7") or string_find(name,"8") or string_find(name,"9") then
		level = 4
	end

	if not bad_list then init_random_rewards() end

	--Если квест дает Сидорович
	if parent == "trader" then
		--Если квест имеет тип - уничтожение лагеря
		if qtype == "eliminate_camp" then
			if     level == 1 then
				item = trader_list.eliminate_lager_lvl1[math_random(#trader_list.eliminate_lager_lvl1)]
			elseif  level ==2 then
			    item = trader_list.eliminate_lager_lvl2[math_random(#trader_list.eliminate_lager_lvl2)]
			else
				item = trader_list.eliminate_lager_lvl3[math_random(#trader_list.eliminate_lager_lvl3)]
			end
		--Если квест имеет тип - принести артефакт
		elseif qtype == "find_artefact" then
			if     level == 1 then
				item = trader_list.artefact_lvl1[math_random(#trader_list.artefact_lvl1)]
			else
				item = trader_list.artefact_lvl2[math_random(#trader_list.artefact_lvl2)]
			end
		--Если квест имеет тип - убить сталкера
		elseif qtype == "kill_stalker" then
			if 	   level == 1 then
				item = trader_list.kill_stalker_lvl1[math_random(#trader_list.kill_stalker_lvl1)]
			elseif level == 2 then
			    item = trader_list.kill_stalker_lvl2[math_random(#trader_list.kill_stalker_lvl2)]
			else
				item = trader_list.kill_stalker_lvl3[math_random(#trader_list.kill_stalker_lvl3)]
			end
		--Если квест имеет тип - принести часть тела монстра
		elseif qtype == "monster_part" then
			if  string_find(name, "1") then
				item = trader_list.kill_stalker_lvl1[math_random(#trader_list.kill_stalker_lvl1)]
			else
				item = trader_list.kill_stalker_lvl2[math_random(#trader_list.kill_stalker_lvl2)]
			end
		else
		--Если квест имеет другой тип оставить его награды по умолчанию
			item = "false"
		end
	--Если квест дает Бармен
	elseif parent == "barman" then
		--Если квест имеет тип - уничтожение лагеря
		if qtype == "eliminate_camp"   then
			if     level == 1 then
				item = barman_list.eliminate_lager_lvl1[math_random(#barman_list.eliminate_lager_lvl1)]
			elseif level == 2 then
			    item = barman_list.eliminate_lager_lvl2[math_random(#barman_list.eliminate_lager_lvl2)]
			else
				item = barman_list.eliminate_lager_lvl3[math_random(#barman_list.eliminate_lager_lvl3)]
			end
		--Если квест имеет тип - принести артефакт
		elseif qtype == "find_artefact" then
			if     level == 1 then
				item = barman_list.artefact_lvl1[math_random(#barman_list.artefact_lvl1)]
			else
				item = barman_list.artefact_lvl1[math_random(#barman_list.artefact_lvl1)]
			end
		--Если квест имеет тип - убить сталкера
		elseif qtype == "kill_stalker" then
			if     level == 1 then
				item = barman_list.kill_stalker_lvl1[math_random(#barman_list.kill_stalker_lvl1)]
			elseif level == 2 then
			    item = barman_list.kill_stalker_lvl2[math_random(#barman_list.kill_stalker_lvl2)]
			else
				item = barman_list.kill_stalker_lvl2[math_random(#barman_list.kill_stalker_lvl2)]
			end
		--Если квест имеет тип - принести часть тела монстра
		elseif qtype == "monster_part" then
			if  string_find(name, "1") then
				item = barman_list.eliminate_lager_lvl2[math_random(#barman_list.eliminate_lager_lvl2)] -- 1
			else
				item = barman_list.eliminate_lager_lvl3[math_random(#barman_list.eliminate_lager_lvl3)] -- 2
			end
		--Если квест имеет тип - защита лагеря
		elseif qtype == "defend_camp" then
			if string_find(name, "1") then
				item = barman_list.kill_stalker_lvl1[math_random(#barman_list.kill_stalker_lvl1)] -- 1
			else
				item = barman_list.kill_stalker_lvl2[math_random(#barman_list.kill_stalker_lvl2)] -- 2
			end
		--Если квест имеет другой тип оставить его награды по умолчанию
		else
			item = "false"
		end
	--Если квест дает Сахаров
	elseif parent == "ecolog" then
		--Если квест имеет тип - уничтожение лагеря
		if qtype == "eliminate_lager" then
			if    level == 1 then
				item = ecolog_list.eliminate_lager_lvl1[math_random(#ecolog_list.eliminate_lager_lvl1)] -- 1, 2
			else
				item = ecolog_list.eliminate_lager_lvl1[math_random(#ecolog_list.eliminate_lager_lvl1)] -- 1, 2
			end
		--Если квест имеет тип - принести часть тела монстра
		elseif qtype == "monster_part" then
			if     level == 1 then
				item = ecolog_list.monster_part_lvl1[math_random(#ecolog_list.monster_part_lvl1)] -- 1, 2
			elseif level == 2 then
				item = ecolog_list.monster_part_lvl2[math_random(#ecolog_list.monster_part_lvl2)] -- 3, 4
			else
				item = ecolog_list.monster_part_lvl3[math_random(#ecolog_list.monster_part_lvl3)] -- 5
			end
		--Если квест имеет тип - принести артефакт
		elseif qtype == "find_artefact" then
			if     level == 1 then
				item = ecolog_list.artefact_lvl1[math_random(#ecolog_list.artefact_lvl1)]
			elseif level == 2 then
				item = ecolog_list.artefact_lvl2[math_random(#ecolog_list.artefact_lvl2)]
			else
				item = ecolog_list.artefact_lvl2[math_random(#ecolog_list.artefact_lvl2)]
			end
		--Если квест имеет другой тип оставить его награды по умолчанию
		else
			item = "false"
		end
	--Если квест дает Воронин
	elseif parent == "dolg" then
		--Если квест имеет тип - уничтожение лагеря
		if qtype == "eliminate_lager" then
			--Квестов такого типа у Воронина дохрена поэтому поделил аж на четыре левела
			if 	   level == 1 then
				item = dolg_list.eliminate_lager_lvl1[math_random(#dolg_list.eliminate_lager_lvl1)] -- 1, 2
			elseif level == 2 then
				item = dolg_list.eliminate_lager_lvl2[math_random(#dolg_list.eliminate_lager_lvl2)] -- 3, 4
			elseif level == 3 then
				item = dolg_list.eliminate_lager_lvl3[math_random(#dolg_list.eliminate_lager_lvl3)] -- 5, 6
			elseif level == 4 then
				item = dolg_list.eliminate_lager_lvl4[math_random(#dolg_list.eliminate_lager_lvl4)] -- 7, 8, 9
			else
				item = dolg_list.eliminate_lager_lvl5[math_random(#dolg_list.eliminate_lager_lvl5)] -- 10, 11, 12, 13, 14
			end
		--Если квест имеет другой тип оставить его награды по умолчанию
		else
			item = "false"
		end
	elseif parent == "freedom" then
		--Если квест имеет тип - уничтожение лагеря
		if qtype == "eliminate_camp" then
			if 	   level == 1 then
				item = freedom_list.eliminate_lager_lvl1[math_random(#freedom_list.eliminate_lager_lvl1)] -- 1, 2
			elseif level == 2 then
				item = freedom_list.eliminate_lager_lvl2[math_random(#freedom_list.eliminate_lager_lvl2)] -- 3, 4
			elseif level == 3 then
				item = freedom_list.eliminate_lager_lvl3[math_random(#freedom_list.eliminate_lager_lvl3)] -- 5, 6
			else
				item = freedom_list.eliminate_lager_lvl4[math_random(#freedom_list.eliminate_lager_lvl4)] -- 7
			end
		--Если квест имеет тип - принести часть тела монстра
		elseif qtype == "monster_part" then
			if  string_find(name, "1") then
				item = freedom_list.eliminate_lager_lvl2[math_random(#freedom_list.eliminate_lager_lvl2)] -- 1
			else
				item = freedom_list.eliminate_lager_lvl2[math_random(#freedom_list.eliminate_lager_lvl2)] -- 1
			end
		--Если квест имеет тип - защита лагеря
		elseif qtype == "defend_lager" then
			if  string_find(name, "1") then
				item = freedom_list.defend_lager_lvl1[math_random(#freedom_list.defend_lager_lvl1)] -- 1
			else
				item = freedom_list.defend_lager_lvl2[math_random(#freedom_list.defend_lager_lvl2)] -- 2
			end
		--Если квест имеет тип - убить сталкера
		elseif qtype == "kill_stalker" then
			if 	level == 2 then
				item = freedom_list.kill_stalker_lvl2[math_random(#freedom_list.kill_stalker_lvl2)] -- 4
			else
				item = freedom_list.kill_stalker_lvl3[math_random(#freedom_list.kill_stalker_lvl3)] -- 5, 6
			end
		--Если квест имеет другой тип оставить его награды по умолчанию
		else
			item = "false"
		end
	--Если квест не дает никто из выше перечисленных персонажей то оставить его награды по умолчанию
	else
		item = "false"
	end

	--Если вам повезет то за любой квест вам могут дать ценный артефакт, а в случае неудачи вы получите палку колбасы :)
	if math_random(1,100) > 95 and item ~= "false" then
		--Повезло
		if math_random(1,100) > 60 then
			if 	   math_random(1,100) == 99 then
				item = spec_list.special_section_lvl3[math_random(#spec_list.special_section_lvl3)]
			elseif math_random(1,100) >  75 then
				item = spec_list.special_section_lvl2[math_random(#spec_list.special_section_lvl2)]
			else
				item = spec_list.special_section_lvl1[math_random(#spec_list.special_section_lvl1)]
			end
		--Не повезло
		else
			item = bad_list[math_random(#bad_list)]
		end
	end

	--Даем награду
	return item
end

--Функция count_item создает таблицу и заносит в нее переданные ей предметы при этом устанавливая случайное их кол-во
function CRandomTask:count_item(s)
	local cnt = 0
	local t = {}
	local v = tostring(s)

	--Установка количества предметов в зависимости от секции
	if string_find(s, "outfit") ~= nil or string_find(v, "addon") ~= nil or string_find(v, "wpn") ~= nil then
			cnt = 1
	--Если артефакт
	elseif string_find(v, "af") ~= nil then
		--Если сильно повезет то вы получите в два-три раза больше предметов от основного значения
		if math_random(1,100)>90 then
			cnt = math_random(3,6)
		else
			cnt = math_random(1,2)
		end
	--Если аммунация
	elseif string_find(v, "ammo") ~= nil then
		if math_random(1,100)>75 then
			cnt = math_random(2,8)
		else
		    cnt = math_random(2,4)
		end
	--Если часть монстра
	elseif string_find (v, "mutant") ~= nil then
		if math_random(1,100)>90 then
			cnt = math_random(3,6)
		else
			cnt = math_random(1,2)
		end
	else
		cnt = math_random(1,5)
	end

	--Цикл записи предмета в таблицу t, сколько раз будет прокручен цикл зависит от полученого значения cnt
	for j = 1, cnt, 1 do
		t[#t + 1] = s
    end

	--Возвращаем таблицу
	return t
end

function CRandomTask:__init()
  --' На конструкторе вычитываем LTX и создаем заготовки квестов.
	local ini = ini_file("misc\\task_manager.ltx")
  self.task_phrase_id = 100

	local function get_field_number(id, field, default)
		return (ini:line_exist(id, field) and ini:r_float(id, field)) or default
	end

  --' Итерируемся по всем настройкам фраз
  if not ini:section_exist("list") then
    abort("There is no section [list] in task_manager.ltx")
		return
  end

  --' начальная установка
  self.task_info = {}
	self.kill_targets = container:get("kill_targets", { })

	local curr_task_info

	ini:iterate_lines("list", function(result, id, value)
		if not ini:section_exist(id) then
			abort("There is no section [%s] in task_manager.ltx", id)
			return
		end

    local hash=stringhash(id)
    if hash_to_id[hash] then
      abort("Collision! Hash:%d id1:%s id2:%s",hash,hash_to_id[hash],id)
			return
    end
    hash_to_id[hash]=id
    id_to_hash[id]=hash

		curr_task_info = { }
		self.task_info[id] = curr_task_info

		if not ini:line_exist(id, "type") then
			abort("Task manager error: no type in section [%s]", id)
			return
		end

		curr_task_info.type			= ini:r_string(id, "type")
		curr_task_info.name			= id

		if ini:line_exist(id, "parent") then
			curr_task_info.parent		= ini:r_string(id, "parent")
			curr_task_info.complex_type = curr_task_info.type .. "_" .. self.task_info[id].parent
		else
			curr_task_info.parent		= "nil"
			curr_task_info.complex_type = curr_task_info.type
		end

		if ini:line_exist(id, "target") then
			curr_task_info.target		= ini:r_string(id, "target")
		end
		if ini:line_exist(id, "text") then
			curr_task_info.text			= ini:r_string(id, "text")
		end
		if ini:line_exist(id, "description") then
			curr_task_info.description	= ini:r_string(id, "description")
		end
		curr_task_info.time				= get_field_number(id, "time", 604800)

		curr_task_info.prior		= get_field_number(id, "prior", 0) --' Приоритет квеста, выдаются доступные квесты с наименьшим приоритетом

		local sss = (ini:line_exist(id, "reward_item") and ini:r_string(id, "reward_item")) or nil
		curr_task_info.reward_item = sss and string.parse_names(sss)

		if ini:line_exist(id, "reward_random") and ini:r_bool(id, "reward_random") ~= true then
			curr_task_info.norandom = true
		end

		-- Награда информацией
		curr_task_info.reward_info = ini:r_string_ex(id, "reward_info")
		if curr_task_info.reward_info then
			self:read_info_reward_section(ini, curr_task_info)
		end
    -- Диалог для квестовой жертвы
    curr_task_info.target_dialog = utils.cfg_get_string(ini, id, "target_dialog", nil, false,"")
    ----------------------

		curr_task_info.reward_reputation	= get_field_number(id, "reward_reputation")
		curr_task_info.reward_relation		= ini:line_exist(id, "reward_relation") and string.key_value_num(ini:r_string(id, "reward_relation")) or nil

		if ini:line_exist(id, "condlist") then
			curr_task_info.condlist			= xr_logic.parse_condlist(ini:r_string(id, "condlist"))
		else
			curr_task_info.condlist			= xr_logic.parse_condlist("true")
		end

		curr_task_info.init_phrase_id		= self:gen_phrase_id()
		curr_task_info.desc_phrase_id		= self:gen_phrase_id()
		curr_task_info.yes_phrase_id		= self:gen_phrase_id()
		curr_task_info.no_phrase_id			= self:gen_phrase_id()
    curr_task_info.completed_phrase_id = self:gen_phrase_id()
		curr_task_info.never_phrase_id = self:gen_phrase_id()

    --' По умолчанию квест доступен для выдачи
		curr_task_info.enabled				= true
    --' Доступен ли квест по своим свойствам. По умолчанию всегда недоступен.
    --' Этот параметр зависит от наличия целей для квестов и того срабатывает ли прекондишн квеста
		curr_task_info.enabled_props		= false

    --' Статус квеста, может быть: "normal", "selected", "completed", "refused", "failed", "rewarded"
		curr_task_info.status = task_status.normal

		if is_find_task[curr_task_info.type] then
			if condition_item(curr_task_info.target) then
				curr_task_info.has = has_good
				curr_task_info.relocate = relocate_good
			else
				curr_task_info.has = has
				curr_task_info.relocate = dialogs.relocate_item_section
			end
		end
	end)

	is_find_task = nil

  --' Создание дополнительных ассоциативных таблиц для облегчения поиска
	self.target_type = { }
  self.task_id_by_parent = {}
  self.task_id_by_yes_phrase_id = {}
  self.task_id_by_completed_phrase_id = {}
  self.task_id_by_desc_phrase_id = {}
	self.task_id_by_never_phrase_id = {}
  self.task_id_by_init_phrase_id = {}
  self.active_task_by_type = {}

	local target, value
	for k,v in pairs(self.task_info) do
		--' По типу квеста
		if not v.has and v.target then
			target = self.target_type[v.type]
			if not target then
				target = { }
				self.target_type[v.type] = target
			end

			value = target[v.target]
			if not value then
				value = { }
				target[v.target] = value
			end

			value[#value + 1] = v
		end

		--' По типу вендора
		value = self.task_id_by_parent[v.parent]
		if not value then
			value = { }
			self.task_id_by_parent[v.parent] = value
		end

		value[#value + 1] = k

		--' По id фразы согласия на квест
		self.task_id_by_yes_phrase_id[tostring(v.yes_phrase_id)] = k
		self.task_id_by_completed_phrase_id[v.completed_phrase_id] = k
		self.task_id_by_desc_phrase_id[v.desc_phrase_id] = k
		self.task_id_by_never_phrase_id[v.never_phrase_id] = k

		--' По id фразы выдачи квеста.
		self.task_id_by_init_phrase_id[tostring(v.init_phrase_id)] = k
	end

	self.protected_smarts = {}
end

--------- Награда информацией --------
function CRandomTask:read_info_reward_section(ini, tbl)
	local section = tbl.reward_info
	local rip = ini:r_string_ex(section, "info_portion")
	if rip == nil then
		abort("! [CRandomTask:read_info_reward_section] Error! Section [%s] not exist in task_manager.ltx or line 'info_portion' not exist in this", section)
		tbl.reward_info = nil
		return
	else
		tbl.reward_info_portion = rip:parse_names()
	end
	-- проверим, может инфо уже выдано
	local n = 0
	for i, v in ipairs(tbl.reward_info_portion) do
		if has_info(v) then
			n = n + 1
		end
	end
	if n == #tbl.reward_info_portion then
		tbl.reward_info_portion = nil
		tbl.reward_info = nil
		return
	end

	tbl.reward_info_dialog={}
	local phr=1
	while true do
		local phrase_id = ini:r_string_ex(section, "phrase_"..phr)
		if phrase_id == nil then break end
		tbl.reward_info_dialog[phr] = phrase_id
		phr = phr + 1
	end
end

-- Будем записывать не id задания а его хеш - семикратная экономия.
function CRandomTask:save(p)
	local tasks = { }

	--' Считаем количество записей
	for id, desc in pairs(self.task_info) do
		if desc.type ~= "storyline" then
			tasks[#tasks + 1] = desc
		end
	end
	p:w_u16(#tasks)

	local v, k, n
	for i = 1, #tasks do
		v = tasks[i]
		k = v.name

		if not id_to_hash[k] then
			abort("[CRandomTask:save] Cannot find hash for id %s!", k)
			return
		end
		p:w_u16(id_to_hash[k])

		n = v.status
		if v.enabled then n = bit_or(n, 8) end
		if v.enabled_props then n = bit_or(n, 16) end

		-- selected_target и defend_target сохраняем только если они есть
		-- активен ли таск - сохраняем тут же одним битом
		-- хрен-знает-сколькикратная экономия
		if v.selected_target then n = bit_or(n, 32) end
		if v.defend_target then n = bit_or(n, 64) end
		if self.active_task_by_type[v.complex_type] == k then
			n = bit_or(n, 128)
		end
		if v.given then n = bit_or(n, 256) end

		if v.since then
			if v.given or v.since <= time_game_ct then
				v.since = nil
			else
				n = bit_or(n, 512)
			end
		end

		p:w_u16(n)

		if v.selected_target then
			p:w_u16(v.selected_target)		-- id, u16
		end
		if v.defend_target then
			p:w_u32(v.defend_target)		-- story_id, u32
		end
		if v.since then
			p:w_CTime(v.since)
		end
	end
end

--' Загрузка
function CRandomTask:load(p)
	--' Считаем количество записей
	local i = p:r_u16()
	local n, id, hash
	for k = 1, i do
		hash = p:r_u16()
		id = hash_to_id[hash] or abort("[CRandomTask:load] Cannot find id for hash %d!", hash)
		local t = self.task_info[id] or abort("[CRandomTask:load] Cannot find task for id %s!", id)
		n = p:r_u16()
		t.enabled = bit_and(n, 8)~=0
		t.enabled_props = bit_and(n, 16)~=0

		if bit_and(n, 32) ~= 0 then
			t.selected_target = p:r_u16()
		end
		if bit_and(n, 64) ~= 0 then
			t.defend_target = p:r_u32()
		end
		if bit_and(n, 128) ~= 0 then
			if self.active_task_by_type[t.complex_type] ~= nil then
				abort("[CRandomTask:load] Error with load active task[%s]: task with type '%s' already loaded: %s",
					id, t.complex_type, self.active_task_by_type[t.complex_type])
			end
			self.active_task_by_type[t.complex_type] = id
		end
		t.given = bit_and(n, 256) ~= 0

		if bit_and(n, 512) ~= 0 then
			t.since = p:r_CTime()
		end

		n = bit_and(n, bit_not(8 + 16 + 32 + 64 + 128 + 256 + 512))
		t.status = n
	end
end

--' Генератор уникальных ID для фраз
function CRandomTask:gen_phrase_id()
	self.task_phrase_id = self.task_phrase_id + 1
	return tostring(self.task_phrase_id)
end
--' Возвращает идентификатор вендора, с которым мы говорим
function CRandomTask:get_parent(npc)
  local story_id = npc:story_id()
  if parent_by_story[story_id] == nil then
    abort("Task manager error: wrong parent story_id[%s]", story_id)
  end
  return parent_by_story[story_id]
end
--' Может ли вендор выдать квест
function CRandomTask:parent_can_task(actor, npc, p1, p2, p3)
  local parent = self:get_parent(npc)
  local avail = false
  self:task_avail(actor, npc, nil, nil, nil, "reset")
	for k,v in ipairs(self.task_id_by_parent[parent]) do
    if self:task_avail(actor, npc, nil, nil, self.task_info[v].init_phrase_id, true) then
      avail = true
    end
  end
  return avail
end

--' Есть ли у игрока хоть одно задание от данного вендора
function CRandomTask:active_parent_task(actor, npc)
	local parent = self:get_parent(npc)
	local ti

	for k, v in pairs(self.active_task_by_type) do
		ti = self.task_info[v]

		if ti.parent == parent and
		   (ti.status == task_status.selected or
		    ti.status == task_status.completed) then
			return true
		end
	end

	return false
end

--' Есть ли у игрока завершенные задания (которые осталось только сдать)
function CRandomTask:have_completed_job(actor, npc)
	local parent = self:get_parent(npc)
	local ti

	for k, v in pairs(self.active_task_by_type) do
		ti = self.task_info[v]

		if ti.parent == parent and ti.status == task_status.completed then
			if ti.has then
				return ti.has(ti.target)
			end

			return true
		end
	end

	return false
end

--' Выдача квеста игроку
function CRandomTask:action_give_task(actor, npc, p1, p2)
  local task = CGameTask()

  local task_id=self.task_id_by_yes_phrase_id[p2]
  local task_desc = self.task_info[task_id]

  task:load(task_desc.complex_type)
  task:set_title(task_desc.type)

  local oo = task:get_objective(0)
  oo:set_article_id(task_desc.description)

  local objective = SGameTaskObjective(task,1)
  objective:set_description(task_desc.name)

  --' Выбираем текущую цель квеста
  if task_desc.target_objects ~= nil then
		task_desc.selected_target = table.fastrand(task_desc.target_objects)
  end

	if task_desc.type == "eliminate_lager" or task_desc.type == "eliminate_lair" then
		objective:set_map_hint(task_desc.text)
		objective:set_map_location(task_desc.type .. "_location")
		objective:set_object_id(task_desc.selected_target)
  elseif task_desc.type == "defend_lager" then
    objective:set_map_hint(task_desc.text)
    objective:set_map_location("defend_lager_location")
    objective:set_object_id(task_desc.selected_target)

		local defend_object = server_object(task_desc.selected_target)
    local sm_ini = defend_object:spawn_ini()
    self.task_info[task_id].defend_target = utils.cfg_get_number(sm_ini, "random_task", "defend_target", nil, true)
  elseif task_desc.type == "kill_stalker" then
    objective:set_map_hint(task_desc.text)
    objective:set_map_location("kill_stalker_location")
    objective:set_object_id(task_desc.selected_target)
    -- Добавим id сталкера в список целей
    if task_desc.target_dialog then
      amk_add_target_id_to_kill_targets(task_desc.selected_target,task_desc.target_dialog,task_id)
    end
    -------------------------------------
  end
  objective:add_complete_func("task_manager.task_complete")
  task:add_objective(objective)

	objective = SGameTaskObjective(task,2)
	local return_type = return_task_by_type[task_desc.type]
	objective:set_description(return_type)
	local return_string = game.translate_string(return_type)
	local task_parent = story_object(tonumber(story_by_parent[task_desc.parent]))
	if task_parent and level.map_has_object_spot(task_parent.id, return_location[return_type]) == 0 then
		return_string = return_string.."\\n%c[255,160,160,160]"..game.translate_string(task_desc.name)
	end
	objective:set_map_hint(return_string)
	objective:set_map_location(return_location[return_type])

	if not task_parent then
		-- Квестодателя прибили.
		return
	end

	objective:set_object_id(task_parent.id)
	task:add_objective(objective)

  local time = 0
  if task_desc.time ~= nil then
    time = task_desc.time * 1000
  end
  Actor:give_task(task,time,false)

  --' дизаблим все остальные задания данного типа, так как игрок не может одновременно обладать двумя заданиями одного типа.
	self.task_info[self.task_id_by_yes_phrase_id[p2]].status = task_status.selected
  self.active_task_by_type[task_desc.complex_type] = self.task_id_by_yes_phrase_id[p2]
  for k,v in pairs(self.task_info) do
    if v.complex_type == task_desc.complex_type then
      v.enabled = false
    end
  end
end
--' Отказ игроком от квеста
function CRandomTask:action_refuse_task(actor, npc, p1, p2)
  local task_desc = self.task_info[self.task_id_by_yes_phrase_id[p2]]

  --' Делаем доступными все задания данного типа
	task_desc.status = task_status.refused
  -- Удаляем цель из списка
	amk_remove_target_id_from_kill_targets(task_desc.selected_target)
  -------------------------
	task_desc.selected_target = nil
  for k,v in pairs(self.task_info) do
    if v.complex_type == task_desc.complex_type then
      v.enabled = true
    end
  end
end
function CRandomTask:action_reject_task(actor, npc, p1, p2)
	local task_desc = self.task_info[self.task_id_by_never_phrase_id[p2]]
	if not task_desc then
		abort("Wrong random task %s %s", tostring(p1), tostring(p2))
		return
	end

	task_desc.since = time_game_ct + game.CTime():set_table({ hour = 24 })

	for k,v in pairs(self.task_info) do
		if v.complex_type == task_desc.complex_type then
			v.enabled = true
		end
	end
end
--' Проверяем, не выполнен ли таск
function CRandomTask:task_complete(p1, p2)
  if Actor == nil then
    return false
  end

  local sel_task = self.task_info[self.active_task_by_type[p1]]
  if sel_task == nil then
		abort("WRONG RANDOM TASK %s %s", tostring(p1), tostring(p2))
		return false
  end

  if p2 == 0 then
		if sel_task.status == task_status.rewarded then
			sel_task.given = true
      return true
    end
  end

  if p2 == 1 then
		if sel_task.type == "eliminate_lager" or sel_task.type == "eliminate_lair" then
			local oo = server_object(sel_task.selected_target)
			if oo and oo.gulag:get_population_comed() == 0 then
				sel_task.status = task_status.completed
				return true
			end
		elseif sel_task.type == "defend_lager" then
      --' Квест выполнен потому что рейд прекратился
      if xr_gulag.getGulagState(sel_task.defend_target) == 0 then
				sel_task.status = task_status.completed
        return true
      end
		elseif sel_task.type == "kill_stalker" then
			local oo = server_object(sel_task.selected_target)

      --' Проверка бага
      if oo == nil then
        abort("OBJ = nil for task %s", tostring(self.active_task_by_type[p1]))
      elseif oo.alive == nil then
        abort("OBJ.NAME = %s", obj:name())
      end

      if oo and oo:alive() == false then
        -- Сталкер убит. Удаляем его ид из списка  целей
        amk_remove_target_id_from_kill_targets(sel_task.selected_target)
        -------------------------------------------------
				sel_task.status = task_status.completed
        return true
      end
		elseif sel_task.has and sel_task.has(sel_task.target) then
			sel_task.status = task_status.completed
			return true
		end
	end

	return false
end

--' Проверяем, не профейлен ли таск
function CRandomTask:task_fail(p1, p2)
  if p2 == 0 then
    local sel_task = self.task_info[self.active_task_by_type[p1]]

    if sel_task == nil then
			abort("WRONG RANDOM TASK %s %s", tostring(p1), tostring(p2))
			return false
    end

    --' Проверяем что жив, выдавший квест.
		local parent = story_object(story_by_parent[sel_task.parent])
    if parent == nil or (parent.alive ~= nil and not parent:alive()) then
			sel_task.status = task_status.failed
			sel_task.given = true
      return true
    end

		if sel_task.status == task_status.refused or sel_task.status == task_status.failed then
			sel_task.given = true
      return true
    end
		if sel_task.type == "defend_lager" then
			if server_object(sel_task.selected_target).gulag:get_population_comed() == 0 then
				sel_task.status = task_status.failed
				sel_task.given = true
        return true
      end
    end
  end
  return false
end

--' Обнуление переменных при завершении или провале таска
function CRandomTask:task_callback(p1, p2, state)
  if p2 ~= 0 then
    return
  end

	local task_id = self.active_task_by_type[p1]
	if task_id == nil then
    return
  end

  -- Удаляем цель из списка
	local task_info = self.task_info[task_id]
  if task_info and task_info.selected_target then
    amk_remove_target_id_from_kill_targets(task_info.selected_target)
  end
  ----------------------------------

	if state == task.completed or state == task.fail then
		task_info.status = task_status.normal
		--' восстановление других заданий данного типа
		for i, v in ipairs(self.task_id_by_parent[task_info.parent]) do
			if self.task_info[v].complex_type == p1 then
				self.task_info[v].enabled = true
			end
		end
		self.active_task_by_type[p1] = nil
	end
end
--' Выводит список доступных квестов
function CRandomTask:action_task_show(npc, actor)
  local parent = self:get_parent(npc)
	for k,v in ipairs(self.task_id_by_parent[parent]) do
		local task_desc = self.task_info[v]
		if self:task_avail(actor, npc, nil, nil, task_desc.init_phrase_id, false) then
			local task_texture, task_rect = get_texture_info(icon_task_by_type[task_desc.type])
			Actor:give_talk_message(translate(task_desc.name).."\\n"..translate("st_task_time").." "..transform_number_to_date(task_desc.time), task_texture, task_rect,"iconed_answer_item")
    end
  end
end

--' Проверка доступен ли текущий таск для выдачи
function CRandomTask:task_avail(actor, npc, p1, p2, p3, calculate)
  local task_desc = self.task_info[self.task_id_by_init_phrase_id[p3]]
  --' Если calculate == true то нужно проверять check_task_props, инача просто вернуть значения.
  if calculate == "reset" then
    self.current_parent_type_prior = {}
    return
  elseif calculate == true then
    self:check_task_props(self.task_id_by_init_phrase_id[p3])

    local t = task_desc.enabled and task_desc.enabled_props

    --' Устанавливать обрезания по приоритетам тут.
    if t == true and (self.current_parent_type_prior[task_desc.complex_type] == nil or
       self.current_parent_type_prior[task_desc.complex_type] > task_desc.prior )
    then
      self.current_parent_type_prior[task_desc.complex_type] = task_desc.prior
    end

    return t
  end

  if self.current_parent_type_prior[task_desc.complex_type] ~= nil and
     self.current_parent_type_prior[task_desc.complex_type] < task_desc.prior then
    return false
  end

  return task_desc.enabled and
       task_desc.enabled_props
end
--' Проверка свойств таска
function CRandomTask:check_task_props(task_id)
	local task_desc = self.task_info[task_id]
  --' Проверка по активным заданиям данного типа у вендора.
	if self.active_task_by_type[task_desc.complex_type] ~= nil then
		task_desc.enabled_props = false
    return
  end

  --' Проверка по кондлисту
	if xr_logic.pick_section_from_condlist(Actor, task_desc.condlist) == nil then
		task_desc.enabled_props = false
    return
  end

  --' Проверка по таймауту
	if task_desc.given then
		task_desc.enabled_props = false
		return
	end
	if task_desc.since then
		if task_desc.since > time_game_ct then
			task_desc.enabled_props = false
			return
		else
			task_desc.since = nil
		end
	end

  --' проверка по таргету
	if task_desc.type == "eliminate_lager" or task_desc.type == "eliminate_lair" then
		if task_desc.target_objects == nil then
			task_desc.enabled_props = false
			return
		end
		for k,v in ipairs(task_desc.target_objects) do
			local gulag = server_object(v).gulag
			if gulag:get_population_comed() > 0 then
				task_desc.enabled_props = true
				return
			end
		end
		task_desc.enabled_props = false
		return
	elseif task_desc.type == "defend_lager" then
		if task_desc.target_objects == nil then
			task_desc.enabled_props = false
      return
    end
		for k,v in ipairs(task_desc.target_objects) do
			local defend_object = server_object(v)
      local sm_ini = defend_object:spawn_ini()
      local defend_target = utils.cfg_get_number(sm_ini, "random_task", "defend_target", nil, true)
      if xr_gulag.getGulagState(defend_target) == 1 then
				task_desc.enabled_props = true
        return
      end
    end
		task_desc.enabled_props = false
    return
	elseif task_desc.type == "kill_stalker" then
		if task_desc.target_objects == nil then
			task_desc.enabled_props = false
      return
    end
		for k,v in ipairs(task_desc.target_objects) do
			local obj = server_object(v)

      --' Проверка бага
      if obj ~= nil and obj.alive == nil then
        abort("OBJ.NAME = %s", obj:name())
      end

      if obj ~= nil and
         obj:alive() == true
      then
				task_desc.enabled_props = true
        return
      else
				table_remove(task_desc.target_objects, k)
      end
    end
		task_desc.enabled_props = false
    return
	else
		task_desc.enabled_props = true
		return
	end
end

--' Проверяется является ли текущий таск выданным игроку
function CRandomTask:active_task(actor, npc, p1, p2, p3)
	local status = self.task_info[self.task_id_by_init_phrase_id[p3]].status

	return status == task_status.selected or status == task_status.completed
end

function CRandomTask:make_task_failed(task_id)
	local ti = self.task_info[task_id]
	if ti then
		ti.status = task_status.failed
	end
end

-- Проверяется наличие квестовых предметов
function CRandomTask:completed_task(actor, npc, p1, p2, p3)
  if not p3 then return false end
  local tid=self.task_id_by_desc_phrase_id[p2]
  if not tid then return false end
  local task_desc=self.task_info[tid]

	if task_desc.status ~= task_status.completed then return false end

	if task_desc.has then
		return task_desc.has(task_desc.target)
	end

	return true
end

--' Создается диалог актера, в котором будут выдаваться задания.
function CRandomTask:init_task_dialog(dlg, parent)
	local phr = dlg:AddPhrase("tm_seek_new_job","0","",-10000)
	local phrase_script = phr:GetPhraseScript()

	phr = dlg:AddPhrase("tm_"..parent.."_list_job","1","0",-10000)
	phrase_script = phr:GetPhraseScript()
	phrase_script:AddAction("task_manager.action_task_show")
	phrase_script:AddPrecondition("task_manager.precondition_vendor_can_task")

	phr = dlg:AddPhrase("tm_"..parent.."_has_no_job","2","0",-10000)
	phrase_script = phr:GetPhraseScript()
	phrase_script:AddPrecondition("task_manager.precondition_vendor_cannot_task")

	for k,v in ipairs(self.task_id_by_parent[parent]) do
		local task_desc = self.task_info[v]
		phr = dlg:AddPhrase(task_desc.name, tostring(task_desc.init_phrase_id), "1", -10000)
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddPrecondition("task_manager.precondition_task_avail")

		phr = dlg:AddPhrase(task_desc.text, tostring(task_desc.desc_phrase_id), tostring(task_desc.init_phrase_id), -10000)
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddAction("task_manager.show_reward")

		phr = dlg:AddPhrase("tm_seek_job_yes", tostring(task_desc.yes_phrase_id), tostring(task_desc.desc_phrase_id), -10000)
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddAction("task_manager.action_give_task")

		phr = dlg:AddPhrase("tm_seek_job_no", tostring(task_desc.no_phrase_id), tostring(task_desc.desc_phrase_id), -10000)

		phr = dlg:AddPhrase("tm_seek_job_never", task_desc.never_phrase_id, task_desc.desc_phrase_id, -10000)
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddAction("task_manager.action_reject_task")
	end

	dlg:AddPhrase("tm_seek_job_abandon","3","1",-10000)
end
--' Функция, в которой будет выдаваться вещевая награда за выполненные квесты
function CRandomTask:task_reward(npc, actor, p1, p2)
	local parent = self:get_parent(npc)
	local v=self.task_id_by_completed_phrase_id[p2]

	local task_desc = self.task_info[v]
	if task_desc.status == task_status.completed and task_desc.parent == parent then
		--' Забираем у игрока квестовый предмет.
		local can_finish = true

		if task_desc.has then
			if task_desc.has(task_desc.target) then
				task_desc.relocate(npc, task_desc.target, "out")
			else
				can_finish = false
			end
		end

		if can_finish == true then
			task_desc.status = task_status.rewarded

			if get_value("option_reward", 0) > 0 and not task_desc.norandom then
				local sss = self:lin_task(task_desc.name, task_desc.parent)

				--В случае если функция обратила для sss значение false наполнить таблицу предметами по умолчанию
				if sss and sss ~= "false" then
					--Если функция lin_task вернула переменной sss значение отменное от нуля то создать таблицу с помощью count_item
					curr_task_info.reward_item = self:count_item(sss)
				end
			end

			if task_desc.reward_item ~= nil then
				for kk,vv in pairs(task_desc.reward_item) do
					got_random(vv)
				end
			end

			if task_desc.reward_reputation ~= nil then
				Actor:change_character_reputation(task_desc.reward_reputation)
			end

			if task_desc.reward_relation ~= nil then
				for kk,vv in pairs(task_desc.reward_relation) do
					relation_registry.change_community_goodwill (kk, 0, tonumber(vv))
				end
			end

			local desc = translate(task_desc.name)
			local char_name = reap.story_name(story_by_parent[task_desc.parent])
			if char_name then
				desc = "%c[255,160,160,160]" .. char_name .. "%c[default]: " .. desc
			end

			actor_stats.add_points("quests", desc, 1, 1)
			Actor:set_character_rank(Actor:character_rank() + 1)
		end
	end
end

--' Функция, в которой будет выдаваться вещевая награда за выполненные сторилайновые квесты
function CRandomTask:task_reward_storyline(task)
	local task_desc = self.task_info[task:get_id()]
	if not task_desc then
		actor_stats.add_points("quests", translate(task:get_title()), 1, 1)
		Actor:set_character_rank(Actor:character_rank() + 1)
		return
	end
	if task_desc.type ~= "storyline" then
		return
	end

  if task_desc.reward_reputation ~= nil then
		Actor:change_character_reputation(task_desc.reward_reputation)
  end

  if task_desc.reward_relation ~= nil then
    for kk,vv in pairs(task_desc.reward_relation) do
      relation_registry.change_community_goodwill (kk, 0, tonumber(vv))
    end
  end

	local desc = translate(task_desc.name)
	local char_name = task_desc.parent and reap.story_name(story_by_parent[task_desc.parent])
	if char_name then
		desc = "%c[255,160,160,160]" .. char_name .. "%c[default]: " .. desc
	end

	actor_stats.add_points("quests", desc, 1, 1)
	Actor:set_character_rank(Actor:character_rank() + 1)
end

--' Создается диалог актера, в котором будут приниматься задания
function CRandomTask:init_reward_dialog(dlg, parent)
	local phr = dlg:AddPhrase("tm_reward_job","0","",-10000)
	local phrase_script

	phr = dlg:AddPhrase("tm_"..parent.."_job_ask", "1", "0", -10000)

  -- Список возможных квестов трейдера.
	for k,v in ipairs(self.task_id_by_parent[parent]) do
		local task_desc = self.task_info[v]

		phr = dlg:AddPhrase(task_desc.name, tostring(task_desc.init_phrase_id), "1", -10000)
    phrase_script = phr:GetPhraseScript()
    phrase_script:AddPrecondition("task_manager.precondition_active_task")

		phr = dlg:AddPhrase("tm_"..parent.."_job_what", tostring(task_desc.desc_phrase_id), tostring(task_desc.init_phrase_id), -10000)

		phr = dlg:AddPhrase("tm_job_refuse", tostring(task_desc.yes_phrase_id), tostring(task_desc.desc_phrase_id), -10000)
    phrase_script = phr:GetPhraseScript()
    phrase_script:AddAction("task_manager.action_refuse_task")
    phrase_script:AddPrecondition("task_manager.precondition_notcompleted_task")

		phr = dlg:AddPhrase("tm_job_nothing", tostring(task_desc.no_phrase_id), tostring(task_desc.desc_phrase_id),-10000)
    phrase_script = phr:GetPhraseScript()
    phrase_script:AddPrecondition("task_manager.precondition_notcompleted_task")

		phr = dlg:AddPhrase("tm_job_completed", tostring(task_desc.completed_phrase_id), tostring(task_desc.desc_phrase_id),-10000)
    phrase_script = phr:GetPhraseScript()
    phrase_script:AddAction("task_manager.action_task_reward")
    phrase_script:AddPrecondition("task_manager.precondition_completed_task")

		if task_desc.reward_info then
			local phrcnt = #task_desc.reward_info_dialog
      if phrcnt==0 then
				for i = 1, #task_desc.reward_info_portion do
					phrase_script:AddGiveInfo(task_desc.reward_info_portion[i])
				end
      else
      -- Добавляем фразу. на случай наличия инфопорции. Иначе вылетит.
				phr = dlg:AddPhrase("...", self:gen_phrase_id(), tostring(task_desc.completed_phrase_id), -10000)
        phrase_script = phr:GetPhraseScript()
				for i = 1, #task_desc.reward_info_portion do
					phrase_script:AddHasInfo(task_desc.reward_info_portion[i])
				end

				local prid = tostring(task_desc.completed_phrase_id)
        local first=true
      -- Добавляем диалог
				for i,p in ipairs(task_desc.reward_info_dialog) do
          local cid=self:gen_phrase_id()
					phr = dlg:AddPhrase(p, cid, prid, -10000)
          prid=cid
          if first then
            first=false
            phrase_script = phr:GetPhraseScript()
						for i = 1, #task_desc.reward_info_portion do
							phrase_script:AddGiveInfo(task_desc.reward_info_portion[i])
							phrase_script:AddDontHasInfo(task_desc.reward_info_portion[i])
						end
          end
        end
      end
    end
  end
end

--' Регистрация целей для квестов.
function CRandomTask:protect_smart(name, task)
	local v = self.protected_smarts[name]
	if not v then
		v = { }
		self.protected_smarts[name] = v
	end

	v[#v + 1] = task
end

function CRandomTask:smart_is_protected(sm)
	local v = self.protected_smarts[sm:name()]
	if not v then return false end

	for _, task in ipairs(v) do
		if task.status == task_status.selected then
			return true
		end
	end

	return false
end

function CRandomTask:register_smart(obj)
	local name = obj:name()

	--' Возможно регистрируется цель для квеста "вынести лагерь"
	local t = self.target_type.eliminate_lager[name]
	if t then
		for tobj, task in ipairs(t) do
			tobj = task.target_objects
			if not tobj then
				tobj = { }
				task.target_objects = tobj
			end

			tobj[#tobj + 1] = obj.id
			self:protect_smart(name, task)
		end
	end

	--' Возможно регистрируется цель для квеста "вынести логово"
	t = self.target_type.eliminate_lair[name]
	if t then
		for tobj, task in ipairs(t) do
			tobj = task.target_objects
			if not tobj then
				tobj = { }
				task.target_objects = tobj
			end

			tobj[#tobj + 1] = obj.id
			self:protect_smart(name, task)
		end
	end

	--' Либо регистрируется цель для квеста "защитить лагерь"
	local sobj

	t = self.target_type.defend_lager[name]
	if t then
		--' Проверка что в кастом дате указано от кого защищать
		local defend = obj:spawn_ini():r_u32_ex("random_task", "defend_target")
		if not defend then
			abort(name .. ": no defend_target for task manager")
			return
		end

		for tobj, task in ipairs(t) do
			tobj = task.target_objects
			if not tobj then
				tobj = { }
				task.target_objects = tobj
			end

			tobj[#tobj + 1] = obj.id
			self:protect_smart(name, task)

			sobj = story_object(defend)
			if sobj then
				self:protect_smart(sobj:name(), task)
			end
		end
	end
end

function CRandomTask:register_stalker(obj)
	if not (obj.alive ~= nil and obj:alive() == true) then
		return
	end

	local t = self.target_type.kill_stalker[obj:profile_name()]
	if not t then return end

	for tobj, task in ipairs(t) do
		tobj = task.target_objects
		if not tobj then
			tobj = { }
			task.target_objects = tobj
		end

		tobj[#tobj + 1] = obj.id
	end
end

--' Отрегистрация целей для квестов.
function CRandomTask:unregister_stalker(obj)
	local t = self.target_type.kill_stalker[obj:profile_name()]
	if not t then return end

	local obj_id = obj.id

	for tobj, task in ipairs(t) do
		tobj = task.target_objects
		if tobj then
			for i = 1, #tobj do
				if tobj[i] == obj_id then
					table_remove(tobj, i)
					break
				end
			end
		end
	end
end

function init_trader_task_dialog(dlg)
	random_task:init_task_dialog(dlg, "trader")
end
function init_barman_task_dialog(dlg)
	random_task:init_task_dialog(dlg, "barman")
end
function init_ecolog_task_dialog(dlg)
	random_task:init_task_dialog(dlg, "ecolog")
end
function init_dolg_task_dialog(dlg)
	random_task:init_task_dialog(dlg, "dolg")
end
function init_freedom_task_dialog(dlg)
	random_task:init_task_dialog(dlg, "freedom")
end

function init_shustriy_task_dialog(dlg)
	random_task:init_task_dialog(dlg, "shustriy")
end
function init_lisiy_task_dialog(dlg)
	random_task:init_task_dialog(dlg, "lisiy")
end
function init_hunter_task_dialog(dlg)
	random_task:init_task_dialog(dlg, "hunter")
end
function init_drunk_dolg_task_dialog(dlg)
	random_task:init_task_dialog(dlg, "drunk_dolg")
end
function init_petrenko_task_dialog(dlg)
	random_task:init_task_dialog(dlg, "petrenko")
end
function init_wolf_task_dialog(dlg)
	random_task:init_task_dialog(dlg, "wolf")
end
function init_zastava_commander_task_dialog(dlg)
	random_task:init_task_dialog(dlg, "zastava_commander")
end
function init_mercenary_task_dialog(dlg)
	random_task:init_task_dialog(dlg, "mercenary")
end

function init_green_task_dialog(dlg)
	random_task:init_task_dialog(dlg, "green")
end

function init_trader_reward_dialog(dlg)
	random_task:init_reward_dialog(dlg, "trader")
end
function init_barman_reward_dialog(dlg)
	random_task:init_reward_dialog(dlg, "barman")
end
function init_ecolog_reward_dialog(dlg)
	random_task:init_reward_dialog(dlg, "ecolog")
end
function init_dolg_reward_dialog(dlg)
	random_task:init_reward_dialog(dlg, "dolg")
end
function init_freedom_reward_dialog(dlg)
	random_task:init_reward_dialog(dlg, "freedom")
end

function init_shustriy_reward_dialog(dlg)
	random_task:init_reward_dialog(dlg, "shustriy")
end
function init_lisiy_reward_dialog(dlg)
	random_task:init_reward_dialog(dlg, "lisiy")
end
function init_hunter_reward_dialog(dlg)
	random_task:init_reward_dialog(dlg, "hunter")
end
function init_drunk_dolg_reward_dialog(dlg)
	random_task:init_reward_dialog(dlg, "drunk_dolg")
end
function init_petrenko_reward_dialog(dlg)
	random_task:init_reward_dialog(dlg, "petrenko")
end
function init_wolf_reward_dialog(dlg)
	random_task:init_reward_dialog(dlg, "wolf")
end
function init_zastava_commander_reward_dialog(dlg)
	random_task:init_reward_dialog(dlg, "zastava_commander")
end
function init_mercenary_reward_dialog(dlg)
	random_task:init_reward_dialog(dlg, "mercenary")
end

function init_green_reward_dialog(dlg)
	random_task:init_reward_dialog(dlg, "green")
end

function has_active_vendor_task(actor, npc)
	return random_task:active_parent_task(actor, npc)
end
function precondition_task_avail(actor, npc, p1, p2, p3)
	return random_task:task_avail(actor, npc, p1, p2, p3, false)
end
function precondition_active_task(actor, npc, p1, p2, p3)
	return random_task:active_task(actor, npc, p1, p2, p3)
end
function precondition_completed_task(actor, npc, p1, p2, p3)
	return random_task:completed_task(actor, npc, p1, p2, p3)
end
function precondition_notcompleted_task(actor, npc, p1, p2, p3)
	return not random_task:completed_task(actor, npc, p1, p2, p3)
end

function precondition_vendor_can_task(npc, actor, p1, p2, p3)
	return random_task:parent_can_task(actor, npc, p1, p2, p3)
end
function precondition_vendor_cannot_task(npc, actor, p1, p2, p3)
	return not random_task:parent_can_task(actor, npc, p1, p2, p3)
end
function precondition_have_completed_job(npc, actor, p1, p2, p3)
	return random_task:have_completed_job(actor, npc)
end
function precondition_dont_have_completed_job(npc, actor, p1, p2, p3)
	return not random_task:have_completed_job(actor, npc)
end

function action_task_show(npc, actor)
	random_task:action_task_show(npc, actor)
end
function action_give_task(actor, npc, p1, p2)
	random_task:action_give_task(actor, npc, p1, p2)
end
function action_reject_task(actor, npc, p1, p2)
	random_task:action_reject_task(actor, npc, p1, p2)
end
function action_refuse_task(npc, actor, p1, p2)
	random_task:action_refuse_task(npc, actor, p1, p2)
end
function action_task_reward(actor, npc, p1, p2)
	random_task:task_reward(npc, actor, p1, p2)
end

function task_complete(p1, p2)
	return random_task:task_complete(p1, p2)
end
function task_fail(p1, p2)
	return random_task:task_fail(p1, p2)
end

function amk_add_target_id_to_kill_targets(id,dialog,task_id)
	random_task.kill_targets[#random_task.kill_targets + 1] = {id=id,dialog=dialog,task_id=task_id}
end

function amk_remove_target_id_from_kill_targets(id)
	for n = 1, #random_task.kill_targets do
		if random_task.kill_targets[n].id == id then
			table_remove(random_task.kill_targets, n)
			break
		end
	end
end

function amk_kill_targets()
	return random_task.kill_targets
end

function make_task_failed(task_id)
	random_task:make_task_failed(task_id)
end

function show_reward(actor,npc,p1,p2)
	local reward_text, task_details

	task_details = random_task.task_info[random_task.task_id_by_init_phrase_id[tostring(p2-1)]]
	if task_details == nil then return end

	if get_value("option_reward", 0) == 0 then
		reward_text = format_reward_text(task_details.reward_item)
	else
		reward_text = "Награда скрыта"
	end

	local task_texture, task_rect = get_texture_info("ui_iconsTotal_found_thing")
	if reward_text ~= nil and reward_text ~= "" then
		Actor:give_talk_message("Я тебе за это дам вот что:", "ui\\ui_iconstotal", Frect():set(0,0,10,10), "simple_answer_item")
		Actor:give_talk_message(reward_text, task_texture, task_rect,"iconed_trade_info")
	end
end

function format_reward_text(reward_list)
	local i,v, ii, vv
	local rwd = {}
	local reward_text = ""
	if reward_list == nil then return "" end
	for i,v in pairs(reward_list) do
		if rwd[v] == nil then
			rwd[v] = 1
		else
			rwd[v] = rwd[v] + 1
		end
	end
	for i,v in pairs(rwd) do
		if v == 1 then
			reward_text = reward_text .. game.translate_string(get_inv_name(i)) .. ", "
		else
			reward_text = reward_text .. string.format("%s",v) .. "x " .. game.translate_string(get_inv_name(i)) .. ", "
		end
	end
	if string_len(reward_text) >=2 then
		reward_text = string_sub (reward_text, 1, string_len(reward_text)-2)
	end
	return reward_text
end
