local idle_time_factor = 0
local random_task = nil

----Таблица наград настоящим везунчикам
local spec_list = {
	
	special_section_lvl1 = {
	"af_spirit_1",        
	"af_cry_1",
	"af_babka_1",
	"af_pudd_1",
	"af_dik_1",
	"af_kol_1",
	"af_armor_1"
	},
	
	special_section_lvl2 = {
	"af_spirit_2",         
	"af_cry_2",
	"af_babka_2",
	"af_pudd_2",
	"af_dik_2",
	"af_kol_2",
	"af_armor_2"
	},
	
	special_section_lvl3 = {
	"af_spirit_3",         
	"af_cry_3",
	"af_babka_3",
	"af_pudd_3",
	"af_dik_3",
	"af_kol_3",
	"af_armor_3",
	"af_simbion"
	}
 }
 
--Таблица наград наудачникам
local bad_list = {              
	"ammo_50ae_thv",
	"ammo_arbolt",
	"ammo_7.62x51",
	"ammo_338_lapua",
	"ammo_357sw_jhp",
	"ammo_357sw_jfp"         
 }
 
--Таблица наград Сидоровича
local trader_list = {
    
	eliminate_lager_lvl1 = {
	"af_drops",            
	"af_ameba_slime",
	"af_rusty_thorn",
	"af_electra_sparkler",
	"af_blood",
	"af_vyvert",
	"af_medusa",
	"af_armor_1"
	},
	
	eliminate_lager_lvl2 = {
	"af_cristall_flower",  
	"af_gravi",
	"af_mincer_meat",
	"af_electra_flash",
	"af_rusty_kristall",
	"af_ameba_slug",
	"af_fireball",
	"af_armor_2"
	},
	
	eliminate_lager_lvl3 = {
	"af_night_star",       
	"af_gold_fish",
	"af_soul",
	"af_electra_moonlight",
	"af_rusty_sea-urchin",
	"af_ameba_mica",
	"af_cristall", 
	"af_armor_3"
	},
	
	artefact_lvl1 = {
	"medkit",
	"medkit_army",
	"wpn_fort",
	"wpn_pm_m1",
	"grenade_rgd5"
	},
	
	artefact_lvl2 = {
	"wpn_mp5",
	"wpn_aps",
	"wpn_colt1911",
	"wpn_hpsa",
	"wpn_usp",
	"wpn_walther",
	"grenade_f1"
	},	
	
	kill_stalker_lvl1 = {
	"af_drops",            
	"af_ameba_slime",
	"af_rusty_thorn",
	"af_electra_sparkler",
	"af_blood",
	"af_vyvert",
	"af_medusa",
	"af_armor_1"
	},
	
	kill_stalker_lvl2 = {
	"af_cristall_flower",  
	"af_gravi",
	"af_mincer_meat",
	"af_electra_flash",
	"af_rusty_kristall",
	"af_ameba_slug",
	"af_fireball",
	"af_armor_2"
	},
	
	kill_stalker_lvl3 = {
	"af_night_star",       
	"af_gold_fish",
	"af_soul",
	"af_electra_moonlight",
	"af_rusty_sea-urchin",
	"af_ameba_mica",
	"af_cristall",
	"af_armor_3"
	}
}
 
--Таблица наград Бармена
 local barman_list = {
 
	eliminate_lager_lvl1 = {
	"af_drops",            
	"af_ameba_slime",
	"af_rusty_thorn",
	"af_electra_sparkler",
	"af_blood",
	"af_vyvert",
	"af_medusa",
	"af_armor_1",
	"ammo_16cal_skart",   
	"ammo_5.45x39_ap",
	"ammo_11.43x23_fmj",
	"ammo_9x39_pab9",
	"ammo_5.56x45_ss190",
	"grenade_f1",
	"grenade_gd-05"
	},
	
	eliminate_lager_lvl2 = {
	"af_spirit_1",
	"af_cry_1",
	"af_babka_1",
	"af_pudd_1",
	"af_dik_1",
	"af_kol_1",
	"af_armor_1",
	"ammo_16cal_fost",     
	"ammo_5.45x39_ap",
	"ammo_11.43x23_hydro",
	"ammo_9x39_sp5",
	"ammo_5.56x45_ap",
	"ammo_7.62x54_7h1",
	"wpn_lr300",
	"wpn_hpsa",
	"ammo_vog-25",  
	"ammo_m209"
	},
	
	eliminate_lager_lvl3 = { 
	"af_spirit_2",
	"af_cry_2",
	"af_babka_2",
	"af_pudd_2",
	"af_dik_2",
	"af_kol_2",
	"af_armor_2",
	"ammo_9x39_ap",        
	"ammo_5.56x45_ap",
	"ammo_7.62x54_7h14",
	"wpn_sig550",
	"wpn_beretta",
	"ammo_og-7b",
	"ammo_vog-25p", 
	"ammo_m209"
	},
	
	artefact_lvl1 = {
	"medkit",
	"medkit_army",
	"medkit_scientic",
	"wpn_bizon",
	"wpn_kriss_super_v",	   
	"wpn_mp7a3",	   
	"wpn_p90",
	"wpn_desert_eagle"
	},
	
	kill_stalker_lvl1 = {
	"af_cristall_flower",  
	"af_gravi",
	"af_mincer_meat",
	"af_electra_flash",
	"af_rusty_kristall",
	"af_ameba_slug",
	"af_fireball",
	"af_dummy_pellicle",
	"af_armor_1"
	},
	
	kill_stalker_lvl2 = {
	"af_night_star",       
	"af_gold_fish",
	"af_soul",
	"af_electra_moonlight",
	"af_rusty_sea-urchin",
	"af_ameba_mica",
	"af_cristall",
	"af_fuzz_kolobok",
	"af_armor_2"
	}
}

--Таблица наград Сахарова
local ecolog_list = {

	eliminate_lager_lvl1 = {
	"medkit_scientic",
	"af_spirit_1",
	"af_cry_1",
	"af_babka_1",
	"af_pudd_1",
	"af_dik_1",
	"af_kol_1",
	"af_armor_1",
	"af_buliz",
	"ammo_9x39_pab9",
	"ammo_7.62x54r",
	"grenade_f1"
	},
	
	monster_part_lvl1 = {
	"medkit",
	"af_drops",            
	"af_ameba_slime",
	"af_rusty_thorn",
	"af_electra_sparkler",
	"af_blood",
	"af_vyvert",
	"af_medusa",
	"ammo_og-7b",
	"ammo_vog-25p",    
	"ammo_vog-25",
	"ammo_m209",
	"grenade_f1",  
	"grenade_rgd5",
	"af_armor_1"
	},	
	
	monster_part_lvl2 = {
	"medkit_army",
	"af_cristall_flower",  
	"af_gravi",
	"af_mincer_meat",
	"af_electra_flash",
	"af_rusty_kristall",
	"af_ameba_slug",
	"af_fireball",
	"af_armor_1",
	"af_buliz",
	"ammo_9x39_sp5",
	"ammo_7.62x54r",
	"grenade_f1"
	},
	
	monster_part_lvl3 = {
	"medkit_scientic",
	"af_night_star",       
	"af_gold_fish",
	"af_soul",
	"af_electra_moonlight",
	"af_rusty_sea-urchin",
	"af_ameba_mica",
	"af_cristall",
	"af_armor_2",
	"af_buliz",
	"af_simbion",
	"ammo_9x39_ap",
	"ammo_7.62x54r",
	"grenade_f1"
	},
	
	artefact_lvl1 = {	
	"medkit_scientic",    
	"ammo_gauss",
	"ammo_9x39_ap",
	"wpn_spas12",
	"wpn_sig_m1",
	"wpn_val",
	"ecolog_outfit" 
	},
	
	artefact_lvl2 = {
	"medkit_scientic",    
	"ammo_gauss",
	"ammo_super_gauss",
	"ammo_9x39_ap",
	"wpn_spas12_m1",       
	"wpn_sig_m2",
	"wpn_val_m1",
	"scientific_outfit" 
	}	
}

--Таблица наград Воронина
local dolg_list = {

	eliminate_lager_lvl1 = {
	"medkit",    
	"af_armor_1",
	"ammo_7.62x51",
	"ammo_9x39_pab9",
	"ammo_12x76_zhekan",
	"ammo_16cal_skart",
	"ammo_vog-25",     
	"grenade_rgd5"
	},
	
	eliminate_lager_lvl2 = {
	"medkit",    
	"af_armor_1",
	"ammo_338_lapua",
	"ammo_9x39_sp5",
	"ammo_7.62x54_ap",
	"ammo_7.62x54r",
	"ammo_vog-25p",     
	"grenade_f1"
	},
	
	eliminate_lager_lvl3 = {
	"medkit_army",    
	"af_armor_2",
	"ammo_9x39_ap",
	"ammo_7.62x54r",
	"ammo_vog-25p",     
	"grenade_f1"
	},
	
	eliminate_lager_lvl4 = {
	"medkit_scientic",    
	"af_armor_3",
	"wpn_rpk74",
	"ammo_og-7b",
	"ammo_vog-25p",     
	"grenade_f1"
	},
	
	eliminate_lager_lvl5 = { 
	"medkit_scientic",    
	"af_armor_3",
	"wpn_svd_m1",
	"wpn_rg6",
	"ammo_og-7b",
	"ammo_vog-25p",     
	"grenade_f1"
	}
}

local freedom_list = {

	eliminate_lager_lvl1 = {
	"medkit_army",    
	"af_armor_1",
	"ammo_5.56x45_ap",
	"ammo_44mag_jhp",
	"ammo_357sw_jhp",
	"ammo_7.62x51",
	"ammo_5.7x28_ss190",
	"ammo_m209",
	"grenade_rgd5"
	},
	
	eliminate_lager_lvl2 = {
	"medkit_army",    
	"af_armor_1",
	"ammo_9x39_ap",
	"ammo_5.56x45_ap",
	"ammo_50ae_thv",
	"ammo_357sw_jfp",
	"ammo_338_lapua",
	"ammo_5.7x28_ap",
	"ammo_m209",
	"grenade_f1"
	},
	
	eliminate_lager_lvl3 = {
	"medkit_scientic",    
	"af_armor_2",
	"ammo_m209",
	"grenade_f1",
	"wpn_pkm",
	"wpn_lr300_m1",
	"wpn_sig_m1"
	},
	
	eliminate_lager_lvl4 = {
	"medkit_scientic",    
	"af_armor_3",
	"ammo_m209",
	"grenade_f1",
	"wpn_awm",
	"wpn_l85_m2",
	"wpn_sig_m2"
	},
	
	kill_stalker_lvl2 = {
	"af_spirit_1",
	"af_cry_1",
	"af_babka_1",
	"af_pudd_1",
	"af_dik_1",
	"af_kol_1",
	"af_armor_1"
	},
	
	kill_stalker_lvl3 = {
	"af_spirit_2",
	"af_cry_2",
	"af_babka_2",
	"af_pudd_2",
	"af_dik_2",
	"af_kol_2",
	"af_armor_2",
	"wpn_l85_m1",
	"exo_outfit"
	},
	
	defend_lager_lvl1 = {
	"af_cristall_flower",
	"af_gravi",
	"af_mincer_meat",
	"af_electra_flash",
	"af_rusty_kristall",
	"af_ameba_slug",
	"af_fireball"
	},
	
	defend_lager_lvl2 = {
	"af_night_star",
	"af_gold_fish",
	"af_soul",
	"af_electra_moonlight",
	"af_rusty_sea-urchin",
	"af_ameba_mica",
	"af_cristall"
	}
}

local parent_by_story = {
  [003] = "trader",
  [500] = "barman",
  [902] = "ecolog",
  [507] = "dolg",
  [707] = "freedom",
  [006] = "wolf",
  [004] = "shustriy",
  [510] = "drunk_dolg",
  [504] = "hunter",
  [518] = "zastava_commander",
  [506] = "petrenko",
  [607] = "lisiy",
  [515] = "mercenary",
  [9613] = "green"
}

local story_by_parent = {
  trader            = 003,
  barman            = 500,
  ecolog            = 902,
  dolg            = 507,
  freedom           = 707,
  wolf            = 006,
  shustriy          = 004,
  drunk_dolg          = 510,
  hunter            = 504,
  zastava_commander     = 518,
  petrenko          = 506,
  lisiy           = 607,
  mercenary         = 515,
  green    = 9613
}

local return_task_by_type = {
  eliminate_lager = "return_for_reward",
  defend_lager = "return_for_reward",
  kill_stalker = "return_for_reward",
  artefact = "return_for_reward_bring",
  monster_part = "return_for_reward_bring",
  find_item = "return_for_reward_bring"}

local return_location = {
	return_for_reward = "blue_location",
	return_for_reward_bring = "blue_location_2"
}

local game_version = -1

local table_insert = table.insert
local table_remove = table.remove
local string_find = string.find
local string_len = string.len
local string_sub = string.sub
local utils_w_CTime = utils.w_CTime
local utils_r_CTime = utils.r_CTime
local math_random = math.random

local hash_to_id={}
local id_to_hash={}
local ct_to_hash={}
local hash_to_ct={}
-- хэш функция для строки (посмотреть литературу, на предмет оптимальной)
function stringhash(str)
  local mpl=1
  local hash=0
  for i=1,string_len(str),1 do
    local val=string.byte(string_sub(str,i,i))
    hash=hash+mpl*val
    mpl=mpl*2
    if mpl==512 then mpl=1 end
  end
  return bit_and(hash,65535)
end

class "CRandomTask"
--Функция check_task получает id квеста и проверяет есть ли он в списке исключений для которых генерировать случайные награды не нужно
function CRandomTask:check_task(name)
	if     name == "tm_find_artefact_3"
		or name == "tm_kill_stalker_1"
		or name == "tm_kill_stalker_4"
		or name == "tm_kill_stalker_5"
	    or name == "barmen_find_artefact_3"
		or name == "barmen_find_artefact_5"
		or name == "ecolog_find_artefact_1"
		or name == "ecolog_find_artefact_5"
		or name == "dolg_kill_stalker_1"
	then
		return false
	else
		return true
	end
end

--Функция lin_task (id квеста, торговец дающий квест)
function CRandomTask:lin_task(name, parent)
	local level = 0
	local item, qtype  = "",""	
	
	--Проверяем  нету ли выбранного квеста в списке исключений
	if self:check_task(name) == false then
		item = "false"
		return item
	end
	
	--Делим квесты на группы в зависимости от типа
	if     string_find(name,"eliminate_camp") then
		qtype = "eliminate_camp"
	elseif string_find(name,"find_artefact")  then
		qtype = "find_artefact"
	elseif string_find(name,"kill_stalker")   then
		qtype = "kill_stalker"
	elseif string_find(name,"monster_part")   then
		qtype = "monster_part"
	elseif string_find(name,"defend_camp")    then
		qtype = "defend_camp"
	elseif string_find(name,"defend_lager")   then
		qtype = "defend_lager"
	elseif string_find(name,"eliminate_lager")then
		qtype = "eliminate_lager"
	end
	
	--Делим квесты на группы в зависимости от порядкового номера
	if 	   string_find(name,"1") or string_find(name,"2") then
		level = 1
	elseif string_find(name,"3") or string_find(name,"4") then
		level = 2
	elseif string_find(name,"5") or string_find(name,"6") then
		level = 3
	elseif string_find(name,"7") or string_find(name,"8") or string_find(name,"9") then
		level = 4
	end
	
	--Если квест дает Сидорович 
	if parent == "trader" then
		--Если квест имеет тип - уничтожение лагеря
		if qtype == "eliminate_camp" then
			if     level == 1 then
				item = trader_list.eliminate_lager_lvl1[math_random(#trader_list.eliminate_lager_lvl1)]
			elseif  level ==2 then
			    item = trader_list.eliminate_lager_lvl2[math_random(#trader_list.eliminate_lager_lvl2)]
			else 
				item = trader_list.eliminate_lager_lvl3[math_random(#trader_list.eliminate_lager_lvl3)]
			end
		--Если квест имеет тип - принести артефакт
		elseif qtype == "find_artefact" then
			if     level == 1 then 
				item = trader_list.artefact_lvl1[math_random(#trader_list.artefact_lvl1)]
			else 
				item = trader_list.artefact_lvl2[math_random(#trader_list.artefact_lvl2)]
			end
		--Если квест имеет тип - убить сталкера
		elseif qtype == "kill_stalker" then
			if 	   level == 1 then 
				item = trader_list.kill_stalker_lvl1[math_random(#trader_list.kill_stalker_lvl1)]
			elseif level == 2 then 
			    item = trader_list.kill_stalker_lvl2[math_random(#trader_list.kill_stalker_lvl2)]
			else 
				item = trader_list.kill_stalker_lvl3[math_random(#trader_list.kill_stalker_lvl3)]
			end
		--Если квест имеет тип - принести часть тела монстра
		elseif qtype == "monster_part" then
			if  string_find(name, "1") then 
				item = trader_list.kill_stalker_lvl1[math_random(#trader_list.kill_stalker_lvl1)]
			else 
				item = trader_list.kill_stalker_lvl2[math_random(#trader_list.kill_stalker_lvl2)]
			end
		else
		--Если квест имеет другой тип оставить его награды по умолчанию
			item = "false"
		end 
	--Если квест дает Бармен	
	elseif parent == "barman" then
		--Если квест имеет тип - уничтожение лагеря
		if qtype == "eliminate_camp"   then
			if     level == 1 then
				item = barman_list.eliminate_lager_lvl1[math_random(#barman_list.eliminate_lager_lvl1)]
			elseif level == 2 then
			    item = barman_list.eliminate_lager_lvl2[math_random(#barman_list.eliminate_lager_lvl2)]
			else 
				item = barman_list.eliminate_lager_lvl3[math_random(#barman_list.eliminate_lager_lvl3)]
			end
		--Если квест имеет тип - принести артефакт
		elseif qtype == "find_artefact" then
			if     level == 1 then
				item = barman_list.artefact_lvl1[math_random(#barman_list.artefact_lvl1)]
			else 
				item = barman_list.artefact_lvl1[math_random(#barman_list.artefact_lvl1)]
			end
		--Если квест имеет тип - убить сталкера
		elseif qtype == "kill_stalker" then
			if     level == 1 then
				item = barman_list.kill_stalker_lvl1[math_random(#barman_list.kill_stalker_lvl1)]
			elseif level == 2 then
			    item = barman_list.kill_stalker_lvl2[math_random(#barman_list.kill_stalker_lvl2)]
			else 
				item = barman_list.kill_stalker_lvl2[math_random(#barman_list.kill_stalker_lvl2)]
			end
		--Если квест имеет тип - принести часть тела монстра
		elseif qtype == "monster_part" then
			if  string_find(name, "1") then   
				item = barman_list.eliminate_lager_lvl2[math_random(#barman_list.eliminate_lager_lvl2)] -- 1
			else 
				item = barman_list.eliminate_lager_lvl3[math_random(#barman_list.eliminate_lager_lvl3)] -- 2
			end
		--Если квест имеет тип - защита лагеря
		elseif qtype == "defend_camp" then
			if string_find(name, "1") then
				item = barman_list.kill_stalker_lvl1[math_random(#barman_list.kill_stalker_lvl1)] -- 1
			else 
				item = barman_list.kill_stalker_lvl2[math_random(#barman_list.kill_stalker_lvl2)] -- 2
			end
		--Если квест имеет другой тип оставить его награды по умолчанию
		else
			item = "false"
		end 
	--Если квест дает Сахаров
	elseif parent == "ecolog" then
		--Если квест имеет тип - уничтожение лагеря
		if qtype == "eliminate_lager" then
			if    level == 1 then
				item = ecolog_list.eliminate_lager_lvl1[math_random(#ecolog_list.eliminate_lager_lvl1)] -- 1, 2
			else 
				item = ecolog_list.eliminate_lager_lvl1[math_random(#ecolog_list.eliminate_lager_lvl1)] -- 1, 2
			end
		--Если квест имеет тип - принести часть тела монстра
		elseif qtype == "monster_part" then
			if     level == 1 then
				item = ecolog_list.monster_part_lvl1[math_random(#ecolog_list.monster_part_lvl1)] -- 1, 2
			elseif level == 2 then
				item = ecolog_list.monster_part_lvl2[math_random(#ecolog_list.monster_part_lvl2)] -- 3, 4
			else 
				item = ecolog_list.monster_part_lvl3[math_random(#ecolog_list.monster_part_lvl3)] -- 5
			end
		--Если квест имеет тип - принести артефакт
		elseif qtype == "find_artefact" then
			if     level == 1 then
				item = ecolog_list.artefact_lvl1[math_random(#ecolog_list.artefact_lvl1)]
			elseif level == 2 then
				item = ecolog_list.artefact_lvl2[math_random(#ecolog_list.artefact_lvl2)]
			else 
				item = ecolog_list.artefact_lvl2[math_random(#ecolog_list.artefact_lvl2)]
			end
		--Если квест имеет другой тип оставить его награды по умолчанию
		else
			item = "false"
		end
	--Если квест дает Воронин
	elseif parent == "dolg" then
		--Если квест имеет тип - уничтожение лагеря
		if qtype == "eliminate_lager" then
			--Квестов такого типа у Воронина дохрена поэтому поделил аж на четыре левела
			if 	   level == 1 then
				item = dolg_list.eliminate_lager_lvl1[math_random(#dolg_list.eliminate_lager_lvl1)] -- 1, 2
			elseif level == 2 then
				item = dolg_list.eliminate_lager_lvl2[math_random(#dolg_list.eliminate_lager_lvl2)] -- 3, 4
			elseif level == 3 then
				item = dolg_list.eliminate_lager_lvl3[math_random(#dolg_list.eliminate_lager_lvl3)] -- 5, 6 
			elseif level == 4 then
				item = dolg_list.eliminate_lager_lvl4[math_random(#dolg_list.eliminate_lager_lvl4)] -- 7, 8, 9
			else
				item = dolg_list.eliminate_lager_lvl5[math_random(#dolg_list.eliminate_lager_lvl5)] -- 10, 11, 12, 13, 14
			end
		--Если квест имеет другой тип оставить его награды по умолчанию
		else
			item = "false"
		end
	elseif parent == "freedom" then
		--Если квест имеет тип - уничтожение лагеря
		if qtype == "eliminate_camp" then
			if 	   level == 1 then
				item = freedom_list.eliminate_lager_lvl1[math_random(#freedom_list.eliminate_lager_lvl1)] -- 1, 2
			elseif level == 2 then
				item = freedom_list.eliminate_lager_lvl2[math_random(#freedom_list.eliminate_lager_lvl2)] -- 3, 4
			elseif level == 3 then
				item = freedom_list.eliminate_lager_lvl3[math_random(#freedom_list.eliminate_lager_lvl3)] -- 5, 6 
			else
				item = freedom_list.eliminate_lager_lvl4[math_random(#freedom_list.eliminate_lager_lvl4)] -- 7
			end
		--Если квест имеет тип - принести часть тела монстра
		elseif qtype == "monster_part" then
			if  string_find(name, "1") then
				item = freedom_list.eliminate_lager_lvl2[math_random(#freedom_list.eliminate_lager_lvl2)] -- 1
			else 
				item = freedom_list.eliminate_lager_lvl2[math_random(#freedom_list.eliminate_lager_lvl2)] -- 1
			end
		--Если квест имеет тип - защита лагеря
		elseif qtype == "defend_lager" then
			if  string_find(name, "1") then   
				item = freedom_list.defend_lager_lvl1[math_random(#freedom_list.defend_lager_lvl1)] -- 1
			else 
				item = freedom_list.defend_lager_lvl2[math_random(#freedom_list.defend_lager_lvl2)] -- 2
			end
		--Если квест имеет тип - убить сталкера
		elseif qtype == "kill_stalker" then
			if 	level == 2 then
				item = freedom_list.kill_stalker_lvl2[math_random(#freedom_list.kill_stalker_lvl2)] -- 4
			else
				item = freedom_list.kill_stalker_lvl3[math_random(#freedom_list.kill_stalker_lvl3)] -- 5, 6
			end
		--Если квест имеет другой тип оставить его награды по умолчанию
		else
			item = "false"
		end
	--Если квест не дает никто из выше перечисленных персонажей то оставить его награды по умолчанию
	else
		item = "false"
	end
	
	--Если вам повезет то за любой квест вам могут дать ценный артефакт, а в случае неудачи вы получите палку колбасы :)
	if math_random(1,100) > 95 and item ~= "false" then
		--Повезло
		if math_random(1,100) > 60 then
			if 	   math_random(1,100) == 99 then
				item = spec_list.special_section_lvl3[math_random(#spec_list.special_section_lvl3)]
			elseif math_random(1,100) >  75 then
				item = spec_list.special_section_lvl2[math_random(#spec_list.special_section_lvl2)]
			else
				item = spec_list.special_section_lvl1[math_random(#spec_list.special_section_lvl1)]
			end
		--Не повезло
		else
			item = bad_list[math_random(#bad_list)]
		end
	end
	
	--Даем награду
	return item
end

--Функция count_item создает таблицу и заносит в нее переданные ей предметы при этом устанавливая случайное их кол-во
function CRandomTask:count_item(s)
	local cnt = 0
	local t = {}	
	local v = tostring(s)
	
	--Установка количества предметов в зависимости от секции
	if string_find(s, "outfit") ~= nil or string_find(v, "addon") ~= nil or string_find(v, "wpn") ~= nil then
			cnt = 1
	--Если артефакт
	elseif string_find(v, "af") ~= nil then
		--Если сильно повезет то вы получите в два-три раза больше предметов от основного значения
		if math_random(1,100)>90 then 
			cnt = math_random(3,6)
		else
			cnt = math_random(1,2)
		end
	--Если аммунация
	elseif string_find(v, "ammo") ~= nil then
		if math_random(1,100)>75 then
			cnt = math_random(2,8)
		else
		    cnt = math_random(2,4)
		end
	--Если часть монстра	
	elseif string_find (v, "mutant") ~= nil then
		if math_random(1,100)>90 then
			cnt = math_random(3,6)
		else
			cnt = math_random(1,2)
		end
	else 
		cnt = math_random(1,5)
	end
	  
	--Цикл записи предмета в таблицу t, сколько раз будет прокручен цикл зависит от полученого значения cnt
	for j = 1, cnt, 1 do
		t[#t + 1] = s
    end
	
	--Возвращаем таблицу 
	return t
end

function CRandomTask:AddPhrase(dlg, name, phrase_id, phr_id_2, offset)
	if game_version >= 7 then
		local phr2string;
		if phr_id_2 == -1 then
				phr2string = ""
		else
				phr2string = tostring(phr_id_2)
		end
		return dlg:AddPhrase(name, tostring(phrase_id), phr2string, offset)
	elseif game_version == 6 then
		return dlg:AddPhrase(name, phrase_id, phr_id_2, offset)
	else
		abort("Incompatible game_version:  %s",tostring(game_version))
	end
end

function CRandomTask:__init()
	game_version = _z.game_version()
  --' На конструкторе вычитываем LTX и создаем заготовки квестов.
	local ini = ini_file("misc\\task_manager.ltx")
	local result, id, value
  self.task_phrase_id = 100

	local function get_field_number(field, default)
		return (ini:line_exist(id, field) and ini:r_float(id, field)) or default
	end

  --' Итерируемся по всем настройкам фраз
  if not ini:section_exist("list") then
    abort("There is no section [list] in task_manager.ltx")
  end
  local n = ini:line_count("list")
  local category = ""

	if idle_time_factor == 0 then
		idle_time_factor = 10000
	end
	local idle_time_factor_seconds = idle_time_factor * 86400

  --' начальная установка
  self.task_info = {}
  
  for i=0,n-1 do
    result, id, value = ini:r_line("list",i,"","")
    local hash=stringhash(id)
    if hash_to_id[hash] then
      abort("Collision! Hash:%d id1:%s id2:%s",hash,hash_to_id[hash],id)
    end
    hash_to_id[hash]=id
    id_to_hash[id]=hash

    if not ini:section_exist(id) then
      abort("There is no section [%s] in task_manager.ltx", id)
    end   

		self.task_info[id]			= {}
		local curr_task_info					= self.task_info[id]
    if not ini:line_exist(id, "type") then
      abort("Task manager error: no type in section [%s]", id)
    end

		curr_task_info.type			= ini:r_string(id, "type")			

		curr_task_info.name			= id
		if ini:line_exist(id, "parent") then
			curr_task_info.parent		= ini:r_string(id, "parent")
			curr_task_info.complex_type = curr_task_info.type .. "_" .. self.task_info[id].parent
		else
			curr_task_info.parent		= "nil"
			curr_task_info.complex_type = curr_task_info.type
		end
    local ct=curr_task_info.complex_type
    local cthash=stringhash(ct)
    if hash_to_ct[cthash] and hash_to_ct[cthash]~=ct then
      abort("Collision! Hash:%d ct1:%s ct2:%s",hash,hash_to_id[hash],id)
    end
    hash_to_ct[cthash]=ct
    ct_to_hash[ct]=cthash
    
		if ini:line_exist(id, "target") then
			curr_task_info.target		= ini:r_string(id, "target")
		end
		if ini:line_exist(id, "text") then
			curr_task_info.text			= ini:r_string(id, "text")
		end
		if ini:line_exist(id, "description") then
			curr_task_info.description	= ini:r_string(id, "description")				
		end
		curr_task_info.time				= get_field_number("time")

		curr_task_info.idle_time	= get_field_number("idle_time", idle_time_factor_seconds) --' Время между выдачами задания (в игровых секундах)
		curr_task_info.prior		= get_field_number("prior", 0) --' Приоритет квеста, выдаются доступные квесты с наименьшим приоритетом

		if ini:line_exist(id, "init_condition") then
			curr_task_info.init_condition = xr_logic.parse_condlist_q(ini:r_string(id, "init_condition"))
		end

	curr_task_info.parent_quest = utils.cfg_get_string(ini, id, "parent", nil, false, "")
	local sss = self:lin_task(curr_task_info.name, curr_task_info.parent_quest) 
	
	--В случае если функция обратила для sss значение false наполнить таблицу предметами по умолчанию
	if sss == "false" then
		sss = utils.cfg_get_string(ini, id, "reward_item", nil, false, "")
		if sss ~= nil then
			curr_task_info.reward_item = se_respawn.parse_names(sss) 
		else
			curr_task_info.reward_item = nil
		end
	--Если функция lin_task вернула переменной sss значение отменное от нуля то создать таблицу с помощью count_item
	elseif sss ~= nil then
		curr_task_info.reward_item = self:count_item(sss)
	else
		curr_task_info.reward_item = sss
    end
	
	--Переменной money задается значение из строки reward_money после чего переменную уменьшаем в два раза
	local money = get_field_number("reward_money")
	if money ~= nil then
		curr_task_info.reward_money = math.floor(money/3)
	end
	

    -- Награда информацией
    local reward_info=utils.cfg_get_string(ini, id, "reward_info", nil, false,"")   
    if reward_info=="" then reward_info=nil end
    curr_task_info.reward_info = reward_info
    if reward_info then
       self:read_info_reward_section(ini,reward_info,curr_task_info)
    end
    -- Диалог для квестовой жертвы
    curr_task_info.target_dialog = utils.cfg_get_string(ini, id, "target_dialog", nil, false,"")
    ----------------------
  
		if ini:line_exist(id, "community") then
			curr_task_info.community = ini:r_string(id, "community")
		end		

		curr_task_info.reward_rank			= get_field_number("reward_rank", 0)
		curr_task_info.reward_reputation	= get_field_number("reward_reputation")
		curr_task_info.reward_relation		= parse_key_value(utils.cfg_get_string(ini, id, "reward_relation", nil, false, ""))
		
		if ini:line_exist(id, "condlist") then
			curr_task_info.condlist			= xr_logic.parse_condlist_q(ini:r_string(id, "condlist"))
		else
			curr_task_info.condlist			= xr_logic.parse_condlist_q("true")
		end		
	
		curr_task_info.need_return			= utils.cfg_get_bool(ini, id, "need_return", nil, false, true)

		curr_task_info.init_phrase_id		= self:gen_phrase_id()
		curr_task_info.desc_phrase_id		= self:gen_phrase_id()
		curr_task_info.yes_phrase_id		= self:gen_phrase_id()
		curr_task_info.no_phrase_id			= self:gen_phrase_id()
    curr_task_info.completed_phrase_id = self:gen_phrase_id()
	
    --' По умолчанию квест доступен для выдачи
		curr_task_info.enabled				= true
    --' Доступен ли квест по своим свойствам. По умолчанию всегда недоступен.
    --' Этот параметр зависит от наличия целей для квестов и того срабатывает ли прекондишн квеста
		curr_task_info.enabled_props		= false

    --' Статус квеста, может быть: "normal", "selected", "completed", "refused", "failed", "rewarded"
		curr_task_info.status				= "normal"
  end

  --' Создание дополнительных ассоциативных таблиц для облегчения поиска
  self.task_id_by_type = {}
  self.task_id_by_parent = {}
  self.task_id_by_yes_phrase_id = {}
  self.task_id_by_completed_phrase_id = {}
  self.task_id_by_desc_phrase_id = {}
  self.task_id_by_init_phrase_id = {}
  self.active_task_by_type = {}
  self.task_id_self_inited = {}
	for k,v in pairs(self.task_info) do
		--' По типу квеста
		value = self.task_id_by_type[v.type]
		if value == nil then
			value = {}
			self.task_id_by_type[v.type] = value
		end
		value[#value+1] = k

		--' По типу вендора
		value = self.task_id_by_parent[v.parent]
		if value == nil then
			value = {}
			self.task_id_by_parent[v.parent] = value
		end
		value[#value+1] = k

    --' По id фразы согласия на квест
    self.task_id_by_yes_phrase_id[v.yes_phrase_id] = k
    self.task_id_by_completed_phrase_id[v.completed_phrase_id] = k
    self.task_id_by_desc_phrase_id[v.desc_phrase_id] = k
    --' По id фразы выдачи квеста.
		self.task_id_by_init_phrase_id[v.init_phrase_id] = k
    --' По самовыдаваемости
    if v.init_condition ~= nil then
      self.task_id_self_inited[#self.task_id_self_inited+1] = k
    end
  end
end

--------- Награда информацией --------
function CRandomTask:read_info_reward_section(ini,sect,container)
--  amk.mylog("reading section "..sect)
  container.reward_info_portion=utils.cfg_get_string(ini,sect,"info_portion",nil,true,"")
  container.reward_info_dialog={}
  local phr=1
  while true do
    local phrase_id=utils.cfg_get_string(ini,sect,"phrase_"..phr,nil,false,"")
    phr=phr+1
    if phrase_id==nil or phrase_id=="" then break end
    container.reward_info_dialog[#container.reward_info_dialog + 1] = phrase_id
  end  
end
--------------------------------------

-- Что-то совершенно не нравится мне эта функция. Переделаю её. Тратить 5КБ из 7-ми на всякую ерунду - многовато
--[[
--' Сохранение
function CRandomTask:save(p)
  printf("^^^ SAVE")
  --' Считаем количество записей
  local i = 0
  for k,v in pairs(self.task_info) do
    i = i + 1
  end
  p:w_u8(i)
  for k,v in pairs(self.task_info) do
    p:w_stringZ(k) 
    p:w_bool(v.enabled) 
    p:w_bool(v.enabled_props)
    p:w_stringZ(v.status)
    p:w_u32(v.selected_target or -1)
    utils.w_CTime(p, v.last_task_time)
  end

  --' Та же самая процедура с активными тасками
  i = 0
  for k,v in pairs(self.active_task_by_type) do
    i = i + 1
  end
  p:w_u8(i)
  for k,v in pairs(self.active_task_by_type) do
    p:w_stringZ(k) 
    p:w_stringZ(v)
  end
end
]]

    --' Статус квеста, может быть: "normal", "selected", "completed", "refused", "failed", "rewarded"
-- Ну и замечательно. Запишем его числом. - семикратная экономия.
local status_to_num={normal=0, selected=1, completed=2, refused=3, 
  failed=4, rewarded=5}
local num_to_status={[0]="normal", [1]="selected", [2]="completed", [3]="refused", 
  [4]="failed", [5]="rewarded"}

-- Будем записывать не id задания а его хеш - семикратная экономия.
function CRandomTask:save(p)
  -- Отметка того, что это новая версия формата.
  p:w_u8(255)
  --' Считаем количество записей
  local i = 0
  for k,v in pairs(self.task_info) do
    i = i + 1
  end
  p:w_u8(i)
  for k,v in pairs(self.task_info) do
    if not id_to_hash[k] then
      abort("Cannot find hash for id %s!",k)
    end
    p:w_u16(id_to_hash[k]) 
    p:w_bool(v.enabled) 
    p:w_bool(v.enabled_props)
    if not status_to_num[v.status] then
      abort("Wrong status '%s' for task %s!",v.status,k)
    end
    p:w_u8(status_to_num[v.status])
    p:w_u32(v.selected_target or -1)
    utils_w_CTime(p, v.last_task_time)
  end

  --' Та же самая процедура с активными тасками
  i = 0
  for k,v in pairs(self.active_task_by_type) do
    i = i + 1
  end
  p:w_u8(i)
  for k,v in pairs(self.active_task_by_type) do
    if not ct_to_hash[k] then
      abort("Cannot find hash for complex type %s!",k)
    end
    p:w_u16(ct_to_hash[k]) 
    if not id_to_hash[v] then
      abort("Cannot find hash for task id %s!",v)
    end
    p:w_u16(id_to_hash[v])
  end
end

--' Загрузка
function CRandomTask:load(p)
  --' Считаем количество записей
  local rt0=p:r_tell()
  local i = p:r_u8()
  if i~=255 then
    for k = 1,i do
      local id = p:r_stringZ() 
      self.task_info[id].enabled = p:r_bool()
      self.task_info[id].enabled_props = p:r_bool()
      self.task_info[id].status = p:r_stringZ()

      local selected_target = p:r_u32()
      if selected_target ~= -1 then
        self.task_info[id].selected_target = selected_target
      end
      self.task_info[id].last_task_time = utils_r_CTime(p)
    end
    --' Та же самая процедура с активными тасками
    local i = p:r_u8()  
    for k = 1,i do
      local id = p:r_stringZ()
      self.active_task_by_type[id] = p:r_stringZ()  
    end
  else
    i=p:r_u8()
    for k = 1,i do
      local hash = p:r_u16() 
      local id=hash_to_id[hash]
      if not id then
        abort("Cannot find id for hash %d!",hash)
      end
      self.task_info[id].enabled = p:r_bool()
      self.task_info[id].enabled_props = p:r_bool()
      self.task_info[id].status = num_to_status[p:r_u8()]

      local selected_target = p:r_u32()
      if selected_target ~= -1 then
        self.task_info[id].selected_target = selected_target
      end
      self.task_info[id].last_task_time = utils_r_CTime(p)
    end
    --' Та же самая процедура с активными тасками
    i = p:r_u8()  
    for k = 1,i do
      local cthash = p:r_u16()
      local id=hash_to_ct[cthash]
      if not id then
        abort("Cannot find complex type for hash %d!",cthash)
      end
      local hash=p:r_u16()
      self.active_task_by_type[id] = hash_to_id[hash]
      if not self.active_task_by_type[id] then
        abort("Cannot find task id for hash %d!",hash)
      end
    end
  end
end
--' Генератор уникальных ID для фраз
function CRandomTask:gen_phrase_id()
	self.task_phrase_id = self.task_phrase_id + 1
	return self.task_phrase_id
end
--' Возвращает идентификатор вендора, с которым мы говорим
function CRandomTask:get_parent(npc)
  local story_id = npc:story_id()
  if parent_by_story[story_id] == nil then
    abort("Task manager error: wrong parent story_id[%s]", story_id)
  end
  return parent_by_story[story_id]
end
--' Может ли вендор выдать квест
function CRandomTask:parent_can_task(actor, npc, p1, p2, p3)
  local parent = self:get_parent(npc)
  local avail = false
  self:task_avail(actor, npc, nil, nil, nil, "reset")
  for k,v in pairs(self.task_id_by_parent[parent]) do
    if self:task_avail(actor, npc, nil, nil, self.task_info[v].init_phrase_id, true) then
      avail = true
    end
  end
  return avail
end
--' Есть ли у игрока хоть одно задание от данного вендора
function CRandomTask:active_parent_task(actor, npc)
  local parent = self:get_parent(npc)
  for k,v in pairs(self.active_task_by_type) do

    if self.task_info[v].parent == parent and
      (self.task_info[v].status == "selected" or
       self.task_info[v].status == "completed")
    then
      return true
    end       
  end
  return false
end
function CRandomTask:is_find_task(sel_task)
	if string_find(sel_task.type, "artefact") ~= nil then
		return true
	elseif string_find(sel_task.type, "monster_part") ~= nil then
		return true
	elseif string_find(sel_task.type, "find_item") ~= nil then
		return true
	end
	return false
end
--' Есть ли игрока завершенные задания (которые осталось только сдать)
function CRandomTask:have_completed_job(actor, npc)
  local parent = self:get_parent(npc)
  for k,v in pairs(self.active_task_by_type) do
    if self.task_info[v].parent == parent and
       self.task_info[v].status == "completed"
    then
			if not self:is_find_task(self.task_info[v]) then return true end
			return actor:object(self.task_info[v].target) ~= nil
    end       
  end
  return false
end
--' Выдача квеста игроку
function CRandomTask:action_give_task(actor, npc, p1, p2)
  local task = CGameTask()

  local task_id=self.task_id_by_yes_phrase_id[p2]
  local task_desc = self.task_info[task_id]
  
  task:load(task_desc.complex_type)
  task:set_title(task_desc.type)

  local oo = task:get_objective(0)
  oo:set_article_id(task_desc.description)
  
  local objective = SGameTaskObjective(task,1)
  objective:set_description(task_desc.name)

  --' Выбираем текущую цель квеста
  if task_desc.target_objects ~= nil then
    self.task_info[task_id].selected_target = task_desc.target_objects[math_random(#task_desc.target_objects)]
  end

  if task_desc.type == "eliminate_lager" then
    objective:set_map_hint(task_desc.text)
    objective:set_map_location("eliminate_lager_location")
    objective:set_object_id(task_desc.selected_target)
  elseif task_desc.type == "defend_lager" then
    objective:set_map_hint(task_desc.text)
    objective:set_map_location("defend_lager_location")
    objective:set_object_id(task_desc.selected_target)

    local defend_object = alife():object(task_desc.selected_target)
    local sm_ini = defend_object:spawn_ini()
    self.task_info[task_id].defend_target = utils.cfg_get_number(sm_ini, "random_task", "defend_target", nil, true)
  elseif task_desc.type == "kill_stalker" then
    objective:set_map_hint(task_desc.text)
    objective:set_map_location("kill_stalker_location")
    objective:set_object_id(task_desc.selected_target)
    -- Добавим id сталкера в список целей
    if task_desc.target_dialog then
      amk_add_target_id_to_kill_targets(task_desc.selected_target,task_desc.target_dialog,task_id)
    end
    -------------------------------------
  elseif task_desc.type == "find_item" then
    objective:set_map_hint(task_desc.text)
    objective:set_map_location("find_item_location")
    objective:set_object_id(task_desc.selected_target)
  end
  objective:add_complete_func("task_manager.task_complete")
  task:add_objective(objective)

	if task_desc.need_return then
		objective = SGameTaskObjective(task,2)
		local return_type = return_task_by_type[task_desc.type]
		objective:set_description(return_type)
		local return_string = game.translate_string(return_type)
		local task_parent = alife():story_object(tonumber(story_by_parent[task_desc.parent]))
		if task_parent and level.map_has_object_spot(task_parent.id, return_location[return_type]) == 0 then
			return_string = return_string.."\\n%c[255,160,160,160]"..game.translate_string(task_desc.name)
		end
		objective:set_map_hint(return_string)
		objective:set_map_location(return_location[return_type])
    if not task_parent then
    -- Квестодателя прибили.
      return 
    end
		objective:set_object_id(task_parent.id)
		task:add_objective(objective)
	end

  local time = 0
  if task_desc.time ~= nil then
    time = task_desc.time * 1000
  end
  db_actor:give_task(task,time,false)

  --' дизаблим все остальные задания данного типа, так как игрок не может одновременно обладать двумя заданиями одного типа.
  self.task_info[self.task_id_by_yes_phrase_id[p2]].status = "selected"
  self.active_task_by_type[task_desc.complex_type] = self.task_id_by_yes_phrase_id[p2]
  for k,v in pairs(self.task_info) do
    if v.complex_type == task_desc.complex_type then
      v.enabled = false
    end
  end
end
--' Отказ игроком от квеста
function CRandomTask:action_refuse_task(actor, npc, p1, p2)
  local task_desc = self.task_info[self.task_id_by_yes_phrase_id[p2]]

  --' Делаем доступными все задания данного типа
  self.task_info[self.task_id_by_yes_phrase_id[p2]].status = "refused"
  -- Удаляем цель из списка 
  amk_remove_target_id_from_kill_targets(self.task_info[self.active_task_by_type[task_desc.complex_type]].selected_target)
  -------------------------
  self.task_info[self.active_task_by_type[task_desc.complex_type]].selected_target = nil
  for k,v in pairs(self.task_info) do
    if v.complex_type == task_desc.complex_type then
      v.enabled = true
    end
  end
end
--' Проверяем, не выполнен ли таск
function CRandomTask:task_complete(p1, p2)
  if db_actor == nil then
    return false
  end

  local sel_task = self.task_info[self.active_task_by_type[p1]]
  if sel_task == nil then
    return false
  end

  if p2 == 0 then
    if not sel_task.need_return and sel_task.status == "completed" then
      self.task_info[self.active_task_by_type[p1]].last_task_time = game.get_game_time()
      return true
    end
    if sel_task.status == "rewarded" then
      self.task_info[self.active_task_by_type[p1]].last_task_time = game.get_game_time()
      return true
    end
  end

  if p2 == 1 then
    if string_find(p1, "eliminate_lager") ~= nil then
      local oo = alife():object(sel_task.selected_target)
      if oo and oo.gulag:get_population_comed() == 0 then
        self.task_info[self.active_task_by_type[p1]].status = "completed"
        return true
      end
    elseif string_find(p1, "defend_lager") ~= nil then
      --' Квест выполнен потому что рейд прекратился
      if xr_gulag.getGulagState(sel_task.defend_target) == 0 then
        self.task_info[self.active_task_by_type[p1]].status = "completed"
        return true
      end
    elseif string_find(p1, "kill_stalker") ~= nil then
      local oo = alife():object(sel_task.selected_target)

      --' Проверка бага
      if oo == nil then
        abort("OBJ = nil for task %s", tostring(self.active_task_by_type[p1]))
      elseif oo.alive == nil then 
        abort("OBJ.NAME = %s", obj:name())        
      end   

      if oo and oo:alive() == false then
        -- Сталкер убит. Удаляем его ид из списка  целей
        amk_remove_target_id_from_kill_targets(sel_task.selected_target)
        -------------------------------------------------
        self.task_info[self.active_task_by_type[p1]].status = "completed"
        return true
      end
		elseif self:is_find_task(sel_task) and actor:object(sel_task.target) ~= nil then
			--artefact, monster_part, find_item
			self.task_info[self.active_task_by_type[p1]].status = "completed"
			return true
		end
  end
  
  return false
end
--' Проверяем, не профейлен ли таск
function CRandomTask:task_fail(p1, p2)
  if p2 == 0 then
    local sel_task = self.task_info[self.active_task_by_type[p1]]
    
    if sel_task == nil then
      return false
    end

    --' Проверяем что жив, выдавший квест.
    local parent = alife():story_object(story_by_parent[sel_task.parent])
    if parent == nil or (parent.alive ~= nil and not parent:alive()) then
      self.task_info[self.active_task_by_type[p1]].status = "failed"
      self.task_info[self.active_task_by_type[p1]].last_task_time = game.get_game_time()
      return true   
    end

    if sel_task.status == "refused" or sel_task.status == "failed" then
      self.task_info[self.active_task_by_type[p1]].last_task_time = game.get_game_time()
      return true
    end
    if string_find(p1, "defend_lager") ~= nil then
      if alife():object(sel_task.selected_target).gulag:get_population_comed() == 0 then
        self.task_info[self.active_task_by_type[p1]].status = "failed"
        self.task_info[self.active_task_by_type[p1]].last_task_time = game.get_game_time()
        return true
      end
    end
  end
  return false
end
--' Обнуление переменных при завершении или провале таска
function CRandomTask:task_callback(p1, p2, state)
  if p2 ~= 0 then
    return
  end

  if self.active_task_by_type[p1] == nil then
    return
  end

  -- Удаляем цель из списка
  local task_info=self.task_info[self.active_task_by_type[p1]]
  if task_info and task_info.selected_target then
    amk_remove_target_id_from_kill_targets(task_info.selected_target)
  end
  ----------------------------------

  if state == task.completed then
    self.task_info[self.active_task_by_type[p1]].status = "normal"
    --' восстановление других заданий данного типа
    for k,v in pairs(self.task_info) do
      if v.complex_type == self.task_info[self.active_task_by_type[p1]].complex_type then
        v.enabled = true
      end
    end
    self.active_task_by_type[p1] = nil  

  elseif state == task.fail then
    self.task_info[self.active_task_by_type[p1]].status = "normal"

    --' восстановление других заданий данного типа
    for k,v in pairs(self.task_info) do
      if v.complex_type == self.task_info[self.active_task_by_type[p1]].complex_type then
        v.enabled = true
      end
    end
    self.active_task_by_type[p1] = nil  
  end
end
--' Выводит список доступных квестов
function CRandomTask:action_task_show(npc, actor)
  local parent = self:get_parent(npc) 
  for k,v in pairs(self.task_id_by_parent[parent]) do   
    if self:task_avail(actor, npc, nil, nil, self.task_info[v].init_phrase_id, false) then
      local task_texture, task_rect = get_texture_info("ui_icons_task_"..self.task_info[v].type, "ui_iconsTotal_locations")
      db_actor:give_talk_message(game.translate_string(self.task_info[v].name), task_texture, task_rect,"iconed_trade_info")
    end
  end
end
--' Проверка доступен ли текущий таск для выдачи
function CRandomTask:task_avail(actor, npc, p1, p2, p3, calculate)
  local task_desc = self.task_info[self.task_id_by_init_phrase_id[p3]]
  --' Если calculate == true то нужно проверять check_task_props, инача просто вернуть значения.
  if calculate == "reset" then    
    self.current_parent_type_prior = {}
    return
  elseif calculate == true then
    self:check_task_props(self.task_id_by_init_phrase_id[p3])

    local t = task_desc.enabled and task_desc.enabled_props and task_desc.init_condition == nil

    --' Устанавливать обрезания по приоритетам тут.
    if t == true and (self.current_parent_type_prior[task_desc.complex_type] == nil or
       self.current_parent_type_prior[task_desc.complex_type] > task_desc.prior )
    then
      self.current_parent_type_prior[task_desc.complex_type] = task_desc.prior
    end

    return t
  end

--' printf("@@@prior %s -> %s [%s]", task_desc.complex_type, task_desc.prior, tostring(calculate))
--' print_table(self.current_parent_type_prior)

  if self.current_parent_type_prior[task_desc.complex_type] ~= nil and
     self.current_parent_type_prior[task_desc.complex_type] < task_desc.prior then
    return false
  end

  return task_desc.enabled and 
       task_desc.enabled_props and
       task_desc.init_condition == nil
end
--' Проверка свойств таска
function CRandomTask:check_task_props(task_id)
  --' Проверка по активным заданиям данного типа у вендора.
  if self.active_task_by_type[self.task_info[task_id].complex_type] ~= nil then
    self.task_info[task_id].enabled_props = false
    return
  end

  --' Проверка по кондлисту
  if xr_logic.pick_section_from_condlist(db_actor, db_actor, self.task_info[task_id].condlist) == nil then
    self.task_info[task_id].enabled_props = false
    return
  end
  
  --' Проверка по таймауту
  if self.task_info[task_id].last_task_time ~= nil and
    game.get_game_time():diffSec(self.task_info[task_id].last_task_time) < self.task_info[task_id].idle_time
  then
    self.task_info[task_id].enabled_props = false
    return
  end

  --' проверка по таргету
  if self.task_info[task_id].type == "eliminate_lager" then
    if self.task_info[task_id].target_objects == nil then
      self.task_info[task_id].enabled_props = false
      return
    end
    for k,v in pairs(self.task_info[task_id].target_objects) do
      local gulag = alife():object(v).gulag
      if gulag:get_population_comed() > 0 then
        self.task_info[task_id].enabled_props = true
        return 
      end
    end
    self.task_info[task_id].enabled_props = false
    return
  elseif self.task_info[task_id].type == "defend_lager" then
    if self.task_info[task_id].target_objects == nil then
      self.task_info[task_id].enabled_props = false
      return
    end
    for k,v in pairs(self.task_info[task_id].target_objects) do
      local defend_object = alife():object(v)
      local sm_ini = defend_object:spawn_ini()
      local defend_target = utils.cfg_get_number(sm_ini, "random_task", "defend_target", nil, true)
      if xr_gulag.getGulagState(defend_target) == 1 then
        self.task_info[task_id].enabled_props = true
        return
      end
    end
    self.task_info[task_id].enabled_props = false
    return
  elseif self.task_info[task_id].type == "kill_stalker" then
    if self.task_info[task_id].target_objects == nil then
      self.task_info[task_id].enabled_props = false
      return
    end
    for k,v in pairs(self.task_info[task_id].target_objects) do
      local obj = alife():object(v)
    
      --' Проверка бага
      if obj ~= nil and obj.alive == nil then 
        abort("OBJ.NAME = %s", obj:name())        
      end     

      if obj ~= nil and
         obj:alive() == true 
      then
        self.task_info[task_id].enabled_props = true
        return
      else
        table_remove(self.task_info[task_id].target_objects, k)
      end
    end
    self.task_info[task_id].enabled_props = false
    return
  elseif self.task_info[task_id].type == "find_item" then
		if self.task_info[task_id].target_objects == nil or #self.task_info[task_id].target_objects == 0 then
      self.task_info[task_id].enabled_props = false
      return
    end
    for k,v in pairs(self.task_info[task_id].target_objects) do
      local obj = alife():object(v)
      if obj ~= nil then
        --' Нужно игнорировать предметы, которые находяться у вендоров.
        if obj.parent_id ~= nil then
          for kk,vv in pairs(parent_by_story) do
            local parent = alife():story_object(kk)
            if parent ~= nil and obj.parent_id == parent.id then
              --' Игнорим предмет
              self.task_info[task_id].enabled_props = false
              return              
            end
          end
        end

        self.task_info[task_id].enabled_props = true
        return
      end 
      self.task_info[task_id].enabled_props = false
      return
    end
  else
    self.task_info[task_id].enabled_props = true
    return    
  end
end
--' Проверяем можем ли мы сейчас выдать какой либо самоинициализующийся таск
function CRandomTask:actor_update()
  for k,v in pairs(self.task_id_self_inited) do
    if self.task_info[v].status == "normal" then
      self:check_task_props(v)
      if self.task_info[v].enabled_props == true and
         self.task_info[v].enabled == true and
         xr_logic.pick_section_from_condlist(db_actor, db_actor, self.task_info[v].init_condition) ~= nil
      then
        --' Нужно автоматически выдать квест
        self:action_give_task(db_actor, nil, nil, self.task_info[v].yes_phrase_id)
      end
    end
  end
end
--' Проверяется является ли текущий таск выданным игроку
function CRandomTask:active_task(actor, npc, p1, p2, p3)
  return self.task_info[self.task_id_by_init_phrase_id[p3]].status == "selected" or
          self.task_info[self.task_id_by_init_phrase_id[p3]].status == "completed"
end

function CRandomTask:make_task_failed(task_id)
  if self.task_info and self.task_info[task_id] then
    self.task_info[task_id].status="failed"
  end
end

-- Проверяется наличие квестовых предметов
function CRandomTask:completed_task(actor, npc, p1, p2, p3)
  if not p3 then return false end
  local tid=self.task_id_by_desc_phrase_id[p2]
  if not tid then return false end
  local task_desc=self.task_info[tid]
  if task_desc.status~="completed" then return false end
  local can_finish = true
  if self:is_find_task(task_desc) then
    if db_actor:object(task_desc.target) == nil then
      can_finish = false
    end
  end
  return can_finish
end

--' Создается диалог актера, в котором будут выдаваться задания.
function CRandomTask:init_task_dialog(dlg, parent)
	local phr = self:AddPhrase(dlg,"tm_seek_new_job",0,-1,-10000)
	local phrase_script = phr:GetPhraseScript()

	phr = self:AddPhrase(dlg,"tm_"..parent.."_list_job",1,0,-10000)
	phrase_script = phr:GetPhraseScript()
	phrase_script:AddAction("task_manager.action_task_show")
	phrase_script:AddPrecondition("task_manager.precondition_vendor_can_task")

	phr = self:AddPhrase(dlg,"tm_"..parent.."_has_no_job",2,0,-10000)
	phrase_script = phr:GetPhraseScript()
	phrase_script:AddPrecondition("task_manager.precondition_vendor_cannot_task")

	for k,v in pairs(self.task_id_by_parent[parent]) do
		phr = self:AddPhrase(dlg,self.task_info[v].name, self.task_info[v].init_phrase_id, 1, -10000)
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddPrecondition("task_manager.precondition_task_avail")

		phr = self:AddPhrase(dlg,self.task_info[v].text, self.task_info[v].desc_phrase_id, self.task_info[v].init_phrase_id, -10000)
		--phrase_script = phr:GetPhraseScript()
		--phrase_script:AddAction("task_manager.show_reward")

		phr = self:AddPhrase(dlg,"tm_seek_job_yes", self.task_info[v].yes_phrase_id, self.task_info[v].desc_phrase_id, -10000)
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddAction("task_manager.action_give_task")

		phr = self:AddPhrase(dlg,"tm_seek_job_no", self.task_info[v].no_phrase_id, self.task_info[v].desc_phrase_id, -10000)
	end

	self:AddPhrase(dlg,"tm_seek_job_abandon",3,1,-10000)
end
--' Функция, в которой будет выдаваться вещевая награда за выполненные квесты
function CRandomTask:task_reward(npc, actor, p1, p2)
  local parent = self:get_parent(npc) 
  local v=self.task_id_by_completed_phrase_id[p2]

  if true then
    local task_desc = self.task_info[v]
    if task_desc.status == "completed" and task_desc.parent == parent then
      --' Забираем у игрока квестовый предмет.
      local can_finish = true
			if self:is_find_task(task_desc) then --artefact, monster_part, find_item
				can_finish = actor:object(task_desc.target) ~= nil
				if can_finish then
					dialogs.relocate_item_section(npc, task_desc.target, "out")
				end
			end
  
      if can_finish == true then
        self.task_info[v].status = "rewarded"
        
        if task_desc.reward_money ~= nil then
          dialogs.relocate_money(npc, task_desc.reward_money, "in")
        end
        
        if task_desc.reward_item ~= nil then
          for kk,vv in pairs(task_desc.reward_item) do
			dialogs.relocate_item_section(npc, vv, "in")
          end
        end

        if task_desc.reward_reputation ~= nil then
					db_actor:change_character_reputation(task_desc.reward_reputation)
        end

        if task_desc.reward_relation ~= nil then
          for kk,vv in pairs(task_desc.reward_relation) do
            relation_registry.change_community_goodwill (kk, db_actor_id, tonumber(vv))
          end
        end

        if task_desc.reward_rank ~= nil then
					local desc = game.translate_string(task_desc.name)
					local story = story_by_parent[task_desc.parent]
					if story then
						local npc = level_object_by_sid(tonumber(story))
						if npc and npc.character_name then
							desc = "%c[255,160,160,160]"..npc:character_name().."%c[default]: "..desc
						end
					end

          actor_stats.add_points("quests", desc, 1, 1)
          db_actor:set_character_rank(db_actor:character_rank() + 1)
        end
      end
    end 
  end
end
--' Функция, в которой будет выдаваться вещевая награда за выполненные сторилайновые квесты
function CRandomTask:task_reward_storyline(task)
  local task_desc = self.task_info[task:get_id()]
  if task_desc == nil or task_desc.type ~= "storyline" then
    return
  end

  if task_desc.reward_reputation ~= nil then
		db_actor:change_character_reputation(task_desc.reward_reputation)
  end

  if task_desc.reward_relation ~= nil then
    for kk,vv in pairs(task_desc.reward_relation) do
      relation_registry.change_community_goodwill (kk, db_actor_id, tonumber(vv))
    end
  end

  if task_desc.reward_rank ~= nil then
		local desc = game.translate_string(task_desc.name)
		local story = story_by_parent[task_desc.parent]
		if story then
			local npc = level_object_by_sid(tonumber(story))
			if npc and npc.character_name then
				desc = "%c[255,160,160,160]"..npc:character_name().."%c[default]: "..desc
			end
		end

    actor_stats.add_points("quests", desc, 1, 1)
    db_actor:set_character_rank(db_actor:character_rank() + 1)
  end
end
--' Создается диалог актера, в котором будут приниматься задания
function CRandomTask:init_reward_dialog(dlg, parent)
	local phr = self:AddPhrase(dlg,"tm_reward_job",0,-1,-10000)
	local phrase_script = phr:GetPhraseScript()

  phr = self:AddPhrase(dlg, "tm_"..parent.."_job_ask", 2, 0, -10000)
  phrase_script = phr:GetPhraseScript()

  -- Список возможных квестов трейдера.
  for k,v in pairs(self.task_id_by_parent[parent]) do
    phr = self:AddPhrase(dlg, self.task_info[v].name, self.task_info[v].init_phrase_id, 2, -10000)
    phrase_script = phr:GetPhraseScript()   
    phrase_script:AddPrecondition("task_manager.precondition_active_task")
    
    phr = self:AddPhrase(dlg, "tm_"..parent.."_job_what", self.task_info[v].desc_phrase_id, self.task_info[v].init_phrase_id, -10000)
    
    phr = self:AddPhrase(dlg, "tm_job_refuse", self.task_info[v].yes_phrase_id, self.task_info[v].desc_phrase_id, -10000)
    phrase_script = phr:GetPhraseScript()
    phrase_script:AddAction("task_manager.action_refuse_task")
    phrase_script:AddPrecondition("task_manager.precondition_notcompleted_task")
      
    phr = self:AddPhrase(dlg, "tm_job_nothing", self.task_info[v].no_phrase_id, self.task_info[v].desc_phrase_id,-10000)
    phrase_script = phr:GetPhraseScript()
    phrase_script:AddPrecondition("task_manager.precondition_notcompleted_task")

    phr = self:AddPhrase(dlg, "tm_job_completed", self.task_info[v].completed_phrase_id, self.task_info[v].desc_phrase_id,-10000)
    phrase_script = phr:GetPhraseScript()
    phrase_script:AddAction("task_manager.action_task_reward")
    phrase_script:AddPrecondition("task_manager.precondition_completed_task")

    if self.task_info[v].reward_info then
      local phrcnt = #self.task_info[v].reward_info_dialog
      if phrcnt==0 then
        phrase_script:AddGiveInfo(self.task_info[v].reward_info_portion)
        phrase_script:AddAction("amk_dialogs.info_received")
      else
      -- Добавляем фразу. на случай наличия инфопорции. Иначе вылетит.
        phr = self:AddPhrase(dlg, "...",self:gen_phrase_id(),self.task_info[v].completed_phrase_id,-10000)
        phrase_script = phr:GetPhraseScript()
        phrase_script:AddHasInfo(self.task_info[v].reward_info_portion)        
        
        local prid=self.task_info[v].completed_phrase_id
        local first=true
      -- Добавляем диалог
        for i,p in ipairs(self.task_info[v].reward_info_dialog) do
          local cid=self:gen_phrase_id()
          phr=self:AddPhrase(dlg, p,cid,prid,-10000)
          prid=cid
          if first then
            first=false
            phrase_script = phr:GetPhraseScript()
            phrase_script:AddGiveInfo(self.task_info[v].reward_info_portion)
            phrase_script:AddAction("amk_dialogs.info_received")
            phrase_script:AddDontHasInfo(self.task_info[v].reward_info_portion)        
          end
        end
      end
    end
  end
end
--' Регистрация целей для квестов.
function CRandomTask:register_target(obj, obj_clsid)
	if not obj_clsid then obj_clsid = obj:clsid() end
  if obj_clsid == clsid_script_stalker then
    --' Возможно регистрируется цель для квеста "убить сталкера"
    for k,v in pairs(self.task_id_by_type["kill_stalker"]) do 
      if obj.alive ~= nil and obj:alive() == true and
        obj:profile_name() == self.task_info[v].target 
      then
        if self.task_info[v].target_objects == nil then
          self.task_info[v].target_objects = {}
        end
        table_insert(self.task_info[v].target_objects, obj.id)
      end
    end

  elseif obj_clsid == clsid_smart_terrain then
    --' Возможно регистрируется цель для квеста "вынести лагерь"
    for k,v in pairs(self.task_id_by_type["eliminate_lager"]) do
      if obj:name() == self.task_info[v].target then
        if self.task_info[v].target_objects == nil then
          self.task_info[v].target_objects = {}
        end
        table_insert(self.task_info[v].target_objects, obj.id)
      end
    end
    --' Либо регистрируется цель для квеста "защитить лагерь"
    for k,v in pairs(self.task_id_by_type["defend_lager"]) do
      if obj:name() == self.task_info[v].target then
        --' Проверка что в кастом дате указано от кого защищать
        local sm_ini = obj:spawn_ini()
        local defend_target = utils.cfg_get_number(sm_ini, "random_task", "defend_target", nil, true)
        if self.task_info[v].target_objects == nil then
          self.task_info[v].target_objects = {}
        end
        table_insert(self.task_info[v].target_objects, obj.id)
      end
    end

  else
    --' Возможно регистрируется цель для квеста "найти предмет"
    for k,v in pairs(self.task_id_by_type["find_item"]) do
      if obj:section_name() == self.task_info[v].target then
        if self.task_info[v].target_objects == nil then
          self.task_info[v].target_objects = {}
        end
        table_insert(self.task_info[v].target_objects, obj.id)
      end       
    end
  end
end
--' ОТРегистрация целей для квестов.
function CRandomTask:unregister_target(obj, obj_clsid)
	if not obj_clsid then obj_clsid = obj:clsid() end
  if obj_clsid == clsid_script_stalker then
    --' Возможно регистрируется цель для квеста "убить сталкера"
    for k,v in pairs(self.task_id_by_type["kill_stalker"]) do 
      if self.task_info[v].target_objects ~= nil then
        for kk,vv in pairs(self.task_info[v].target_objects) do
          if vv == obj.id then
            table_remove(self.task_info[v].target_objects, vv)
          end
        end     
      end
    end
  else
    --' Возможно регистрируется цель для квеста "найти предмет"
    for k,v in pairs(self.task_id_by_type["find_item"]) do
      if self.task_info[v].target_objects ~= nil then
        for kk,vv in pairs(self.task_info[v].target_objects) do
          if vv == obj.id then
            table_remove(self.task_info[v].target_objects, vv)
          end
        end     
      end
    end
  end
end

function get_random_task()
  if random_task == nil then
    random_task = CRandomTask()
  end
  return random_task
end


function init_trader_task_dialog(dlg)
  get_random_task():init_task_dialog(dlg, "trader")
end
function init_barman_task_dialog(dlg)
  get_random_task():init_task_dialog(dlg, "barman")
end
function init_ecolog_task_dialog(dlg)
  get_random_task():init_task_dialog(dlg, "ecolog")
end
function init_dolg_task_dialog(dlg)
  get_random_task():init_task_dialog(dlg, "dolg")
end
function init_freedom_task_dialog(dlg)
  get_random_task():init_task_dialog(dlg, "freedom")
end


function init_shustriy_task_dialog(dlg)
  get_random_task():init_task_dialog(dlg, "shustriy")
end
function init_lisiy_task_dialog(dlg)
  get_random_task():init_task_dialog(dlg, "lisiy")
end
function init_hunter_task_dialog(dlg)
  get_random_task():init_task_dialog(dlg, "hunter")
end
function init_drunk_dolg_task_dialog(dlg)
  get_random_task():init_task_dialog(dlg, "drunk_dolg")
end
function init_petrenko_task_dialog(dlg)
  get_random_task():init_task_dialog(dlg, "petrenko")
end
function init_wolf_task_dialog(dlg)
  get_random_task():init_task_dialog(dlg, "wolf")
end
function init_zastava_commander_task_dialog(dlg)
  get_random_task():init_task_dialog(dlg, "zastava_commander")
end
function init_mercenary_task_dialog(dlg)
  get_random_task():init_task_dialog(dlg, "mercenary")
end

function init_green_task_dialog(dlg)
  get_random_task():init_task_dialog(dlg, "green")
end



function init_trader_reward_dialog(dlg)
  get_random_task():init_reward_dialog(dlg, "trader")
end
function init_barman_reward_dialog(dlg)
  get_random_task():init_reward_dialog(dlg, "barman")
end
function init_ecolog_reward_dialog(dlg)
  get_random_task():init_reward_dialog(dlg, "ecolog")
end
function init_dolg_reward_dialog(dlg)
  get_random_task():init_reward_dialog(dlg, "dolg")
end
function init_freedom_reward_dialog(dlg)
  get_random_task():init_reward_dialog(dlg, "freedom")
end



function init_shustriy_reward_dialog(dlg)
  get_random_task():init_reward_dialog(dlg, "shustriy")
end
function init_lisiy_reward_dialog(dlg)
  get_random_task():init_reward_dialog(dlg, "lisiy")
end
function init_hunter_reward_dialog(dlg)
  get_random_task():init_reward_dialog(dlg, "hunter")
end
function init_drunk_dolg_reward_dialog(dlg)
  get_random_task():init_reward_dialog(dlg, "drunk_dolg")
end
function init_petrenko_reward_dialog(dlg)
  get_random_task():init_reward_dialog(dlg, "petrenko")
end
function init_wolf_reward_dialog(dlg)
  get_random_task():init_reward_dialog(dlg, "wolf")
end
function init_zastava_commander_reward_dialog(dlg)
  get_random_task():init_reward_dialog(dlg, "zastava_commander")
end
function init_mercenary_reward_dialog(dlg)
  get_random_task():init_reward_dialog(dlg, "mercenary")
end

function init_green_reward_dialog(dlg)
  get_random_task():init_reward_dialog(dlg, "green")
end


function has_active_vendor_task(actor, npc)
  return get_random_task():active_parent_task(actor, npc)
end
function precondition_task_avail(actor, npc, p1, p2, p3)
  return get_random_task():task_avail(actor, npc, p1, tonumber(p2), tonumber(p3), false)
end
function precondition_active_task(actor, npc, p1, p2, p3)
  return get_random_task():active_task(actor, npc, p1, tonumber(p2), tonumber(p3))
end
function precondition_completed_task(actor, npc, p1, p2, p3)
  return get_random_task():completed_task(actor, npc, p1, tonumber(p2), tonumber(p3))
end
function precondition_notcompleted_task(actor, npc, p1, p2, p3)
  return not get_random_task():completed_task(actor, npc, p1, tonumber(p2), tonumber(p3))
end

function precondition_vendor_can_task(npc, actor, p1, p2, p3)
  return get_random_task():parent_can_task(actor, npc, p1, tonumber(p2), tonumber(p3))
end
function precondition_vendor_cannot_task(npc, actor, p1, p2, p3)
  return not get_random_task():parent_can_task(actor, npc, p1, tonumber(p2), tonumber(p3))
end
function precondition_have_completed_job(npc, actor, p1, p2, p3)
  return get_random_task():have_completed_job(actor, npc)
end
function precondition_dont_have_completed_job(npc, actor, p1, p2, p3)
  return not get_random_task():have_completed_job(actor, npc)
end

function action_task_show(npc, actor)
  get_random_task():action_task_show(npc, actor)
end
function action_give_task(actor, npc, p1, p2)
  get_random_task():action_give_task(actor, npc, p1, tonumber(p2))
end
function action_refuse_task(npc, actor, p1, p2)
  get_random_task():action_refuse_task(npc, actor, p1, tonumber(p2))
end
function action_task_reward(actor, npc, p1, p2)
  get_random_task():task_reward(npc, actor, p1, tonumber(p2))
end
function reward_by_task(task) 
  get_random_task():task_reward_storyline(task)
end

function task_complete(p1, p2)
  return get_random_task():task_complete(p1, p2)
end
function task_fail(p1, p2)
  return get_random_task():task_fail(p1, p2)
end
function task_callback(p1, p2, state)
  return get_random_task():task_callback(p1, p2, state)
end

function actor_update()
  get_random_task():actor_update()
end


function save(p)
  get_random_task():save(p)
end
function load(p)
  get_random_task():load(p)
end
function clear_task_manager()
 random_task  = nil
end

function amk_add_target_id_to_kill_targets(id,dialog,task_id)
  local targets=amk.unpack_array_from_string(amk.load_variable("kill_targets",""))
  targets[#targets + 1] = {id=id,dialog=dialog,task_id=task_id}
  amk.save_variable("kill_targets",amk.pack_array_to_string(targets))
end

function amk_remove_target_id_from_kill_targets(id)
  local targets=amk.unpack_array_from_string(amk.load_variable("kill_targets",""))
  for n,v in pairs(targets) do
    if v.id==id then
      table_remove(targets,n)
      break
    end
  end
  amk.save_variable("kill_targets",amk.pack_array_to_string(targets))
end

function amk_kill_targets()
  return amk.unpack_array_from_string(amk.load_variable("kill_targets",""))  
end

function make_task_failed(task_id)
  get_random_task():make_task_failed(task_id)  
end

--[[function show_reward(actor,npc,p1,p2)
	local reward_text, reward_money --task_details
	
	if random_task == nil then
		random_task = task_manager.CRandomTask()
	end
	
	task_details = random_task.task_info[random_task.task_id_by_init_phrase_id[p2-1]]
	
--[[	if task_details == nil then return end
	
	reward_text = format_reward_text(task_details.reward_item)
	reward_money = task_details.reward_money
	
	local task_texture, task_rect = get_texture_info("ui_iconsTotal_find_item")
	if reward_text ~= nil and reward_text ~= "" then
		db_actor:give_talk_message("Я тебе за это дам вот что:", "ui\\ui_iconstotal", Frect():set(0,0,10,10), "simple_answer_item")
		db_actor:give_talk_message(reward_text, task_texture, task_rect,"iconed_trade_info")
	end
	
	if reward_money ~= nil then 
		task_texture, task_rect = get_texture_info("ui_iconsTotal_found_money")
		if task_details.need_return and reward_text == "" then
			db_actor:give_talk_message(reward_money .. " RU (" .. game.translate_string("return_for_reward") .. ")", task_texture, task_rect, "iconed_trade_info")
		else
			db_actor:give_talk_message(reward_money .. " RU", task_texture, task_rect,"iconed_trade_info")
		end
	end
	
end

function format_reward_text(reward_list)
	local i,v, ii, vv
	local rwd = {}
	local reward_text = ""
	if reward_list == nil then return "" end
	for i,v in pairs(reward_list) do
		if rwd[v] == nil then
			rwd[v] = 1
		else
			rwd[v] = rwd[v] + 1
		end
	end
	for i,v in pairs(rwd) do
		if v == 1 then
			reward_text = reward_text .. game.translate_string(news_manager.get_inv_name(i)) .. ", "
		else
			reward_text = reward_text .. string.format("%s",v) .. "x " .. game.translate_string(news_manager.get_inv_name(i)) .. ", "
		end
	end
	if string_len(reward_text) >=2 then
		reward_text = string_sub (reward_text, 1, string_len(reward_text)-2)
	end
	return reward_text
end]]--
