--[[
  TAG фенечка 1.2 стр.240, 369-387
]]

function init    (obj)
  xr_motivator.AddToMotivator(obj)
end

function actor_init    (npc)
  npc:bind_object(actor_binder(npc))
end

local game_difficulty_by_num = {
  [0] = "gd_novice",
  [1] = "gd_stalker",
  [2] = "gd_veteran",
  [3] = "gd_master"
  }

local weapon_hide = false

----------------------------------------------------------------------------------------------------------------------
class "actor_binder" (object_binder)
----------------------------------------------------------------------------------------------------------------------
function actor_binder:__init (obj) super(obj)
  self.bCheckStart = false
  self.actor_detector = xr_detector.actor_detector()
  self.freeplay_stats = xr_statistic_freeplay.get_freeplay_statistic()
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:net_spawn(data)
  spawn_level_changer.remove_old_teleport()

  level.show_indicators()

  self.bCheckStart = true
  self.weapon_hide = false -- спрятано или нет оружие при разговоре.
  weapon_hide = false -- устанавливаем глобальный дефолтовый флаг.

  if object_binder.net_spawn(self,data) == false then
    return false
  end

  db.add_actor(self.object)
	if self.actor_detector.init_time ~= -1 then
		self.actor_detector:actor_enter()
	end

  if self.st.disable_input_time == nil then
    level.enable_input()
  end

  if(actor_stats.add_to_ranking~=nil)then
    actor_stats.add_to_ranking(self.object:id())
  end

  --' Загружаем настройки дропа
	if not death_manager then abort("death_manager.script is not valid!") end
	sa_callbacks.actor_net_spawn()

  -- added by xStream for AMK miniSDK
  if xrs_ai then 
  xrs_ai.actor_net_spawn(self)
  end
  amk.on_game_load(obj)
  sak.add_tail()
  braad_test.false_info()
  -- end of addition
  return true
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:net_destroy()
  -- added by xStream for AMK miniSDK
  amk.on_game_save(obj)
  -- end of addition

  if(actor_stats.remove_from_ranking~=nil)then
    actor_stats.remove_from_ranking(self.object:id())
  end
  db.del_actor(self.object)

    sr_light.clean_up ()

  self.object:set_callback(callback.inventory_info, nil)
  self.object:set_callback(callback.article_info, nil)
  self.object:set_callback(callback.on_item_take, nil)
  self.object:set_callback(callback.on_item_drop, nil)
  self.object:set_callback(callback.task_state, nil)
  self.object:set_callback(callback.level_border_enter, nil)
  self.object:set_callback(callback.level_border_exit, nil)
  self.object:set_callback(callback.take_item_from_box, nil)
	self.object:set_callback(callback.death, nil)
	self.object:set_callback(callback.hit, nil)
	self.object:set_callback(callback.on_item_belt, nil)
	self.object:set_callback(callback.on_item_ruck, nil)
	self.object:set_callback(callback.hit_effector, nil)
	self.object:set_callback(callback.before_hit, nil)

  if sr_psy_antenna.psy_antenna then
    sr_psy_antenna.psy_antenna:destroy()
    sr_psy_antenna.psy_antenna = false
  end

  xr_sound.stop_all_sound_object()

  object_binder.net_destroy(self)
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:reinit()
  object_binder.reinit(self)
  
  local npc_id = self.object:id()

  db.storage[npc_id] = { }

  self.st = db.storage[npc_id]
  self.st.pstor = nil

  self.next_restrictors_update_time = -10000

  self.object:set_callback(callback.inventory_info, self.info_callback, self)
  self.object:set_callback(callback.article_info, self.article_callback, self)
  self.object:set_callback(callback.on_item_take, self.on_item_take, self)
  self.object:set_callback(callback.on_item_drop, self.on_item_drop, self)
  self.object:set_callback(callback.task_state, self.task_callback, self)
  self.object:set_callback(callback.level_border_enter, self.level_border_enter, self)
  self.object:set_callback(callback.level_border_exit, self.level_border_exit, self)
  self.object:set_callback(callback.take_item_from_box, self.take_item_from_box, self)
	self.object:set_callback(callback.death, self.on_death, self)
	self.object:set_callback(callback.hit, self.hit_callback, self)
	self.object:set_callback(callback.on_item_belt, self.on_item_belt, self)
	self.object:set_callback(callback.on_item_ruck, self.on_item_ruck, self)
	self.object:set_callback(callback.hit_effector, self.hit_effector_callback, self)
	self.object:set_callback(callback.before_hit, self.before_hit_callback, self)
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:on_death(object, who)
	_z.kill_online_controllers()
	level.enable_input()
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:take_item_from_box(box, item)
  amk_offline_alife.take_item_from_box(box, item)
  
  local story_id = box:story_id()
  if story_id == nil then
    return
  end

  treasure_manager.take_item_from_box(box, story_id)

	--AMK UTILS--
	amk.on_item_take_from_box(box,item)
	amk_utils.actor_item_from_box(box, item)
	--AMK UTILS--

	--' Необходимо уменьшить счетчик в респавнере
	local respawner = se_respawn.get_respawner_by_parent(story_id)
	if respawner then
		respawner:remove_spawned(item:id())
	end
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:level_border_enter(npc, info_id)
  self.actor_detector:actor_enter()
  
  --AMK UTILS--
  amk_utils.actor_level_border_enter(npc, info_id)
  --AMK UTILS--
  
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:level_border_exit(npc, info_id)
  self.actor_detector:actor_exit()
  
   --AMK UTILS--
   amk_utils.actor_level_border_exit(npc, info_id)
   --AMK UTILS--
   
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:info_callback(npc, info_id)
  --' Сюжет
  level_tasks.proceed()
  -- Отметки на карте
  level_tasks.process_info_portion(info_id)
  
  --AMK UTILS--
  amk.on_info(npc,info_id)
  amk_utils.actor_info(npc, info_id)
  --AMK UTILS--
  inventory.on_inventory_info(info_id)
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:article_callback(npc, group, name)
  if device().precache_frame >1 then return end
  
  if group == "Diary" then
    news_manager.send_encyclopedy(group, "diary")
  else
    news_manager.send_encyclopedy(group, "encyclopedy")
  end

  --AMK UTILS--
  amk.on_info(npc,info_id)
  amk_utils.actor_article(npc, group, name)
  --AMK UTILS--

	sa_main.pda_news(group, name)
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:on_item_take (obj)
	amk_offline_alife.on_item_take(obj)
    self.freeplay_stats:check_found_item(obj)

	local obj_clsid = obj:clsid()
	if obj_clsid == clsid_equ_stalker_s then
		local actor_outfit = db_actor:item_in_slot(6)
		if actor_outfit and obj:id() ~= actor_outfit:id() then
			db_actor:transfer_item(actor_outfit, db_actor)
		end
	end

    level_tasks.proceed()
  local item = obj
  --AMK UTILS--
  amk.on_item_take(obj)
  amk_utils.actor_item_take(obj)
	sak.check_used_item(obj)
	braad_test.checking_use_item(obj)
	if xrs_ai then xrs_ai.actor_item_take(obj)
	end 

  --AMK UTILS--
  inventory.on_item_take(item)
spawn_zombi.checking_taken_item(obj)
spawn_zombi.checking_taken_item2(obj)
spawn_zombi.checking_taken_item3(obj)
spawn_zombi.checking_taken_item4(obj)
spawn_zombi.checking_taken_item5(obj)
spawn_zombi.checking_taken_item6(obj)
spawn_zombi.checking_taken_item7(obj)
spawn_zombi.checking_taken_item8(obj)
spawn_zombi.checking_taken_item9(obj)
spawn_zombi.checking_taken_item10(obj)
spawn_zombi.checking_taken_item11(obj)
spawn_zombi.checking_taken_item12(obj)
spawn_zombi.checking_taken_item13(obj)
spawn_zombi.checking_taken_item14(obj)
spawn_zombi.checking_taken_item15(obj)
spawn_zombi.checking_taken_item16(obj)
spawn_zombi.checking_taken_item17(obj)
spawn_zombi.checking_taken_item18(obj)
spawn_teleport.checking_taken_item19(obj)
spawn_teleport.checking_taken_item20(obj)
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:on_item_drop (obj)
	amk_offline_alife.on_item_drop(obj)
    level_tasks.proceed()

  local item = obj
  --AMK UTILS--
  amk.on_item_drop(obj)
  amk_utils.actor_item_drop(obj)
  --AMK UTILS--
  sak.check_droped_item(obj)
  inventory.on_item_drop(item)
------------- TAG ----------
  tag_spb.refresh_zombie_team (self.object,obj)
spawn_level_changer.checking_droped_item(obj)
spawn_level_changer.checking_droped_item2(obj)
spawn_level_changer.checking_droped_item3(obj)
spawn_level_changer.checking_droped_item4(obj)
end

----------------------------------------------------------------------------------------------------------------------
function actor_binder:hit_callback(obj, amount, local_direction, who, bone_index)
	sa_callbacks.actor_hit(obj, amount, local_direction, who, bone_index)
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:on_item_belt(obj)
	sa_callbacks.item_belt(obj)
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:on_item_ruck(obj)
	sa_callbacks.item_ruck(obj)
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:hit_effector_callback(mob_type, side)
	sa_callbacks.hit_effector(mob_type, side)
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:before_hit_callback(hit_data, ignore_flags)
	sa_callbacks.hit_effector(hit_mob_types.generic)
end
----------------------------------------------------------------------------------------------------------------------

function actor_binder:task_callback(_task, _objective, _state)
  task_manager.task_callback(_task:get_id(), _objective:get_idx(), _state)
  if _objective:get_idx() == 0 then
    if _state == task.fail then
      news_manager.send_task(db_actor, "fail", _task, _objective)
    elseif _state == task.completed then
      task_manager.reward_by_task(_task)
      news_manager.send_task(db_actor, "complete", _task, _objective)
    else
      news_manager.send_task(db_actor, "new", _task, _objective)
    end
  else
    if _task:get_objective(0):get_state() == task.in_progress then
      news_manager.send_task(db_actor, "update", _task, _objective)
    end
  end
  
  --AMK UTILS--
  amk_utils.actor_task(_task, _objective, _state)
  --AMK UTILS--
  
end
----------------------------------------------------------------------------------------------------------------------
local object_binder_update = object_binder.update
local xr_sound_update_actor = xr_sound.update_actor
local corspoff = true

function actor_binder:update(delta)
  if corspoff then
    sak_off_corpses.off_corpses()
    corspoff = false
  end
  object_binder_update(self, delta)

  local time = time_global()

  -- $DreamMod  апдейт схемы сна
  if sleep_manager.is_sleep_active() and xr_conditions.actor_dead() then
    xr_logic.issue_event(db_actor, db.storage[db_actor_id]["ar_sleep"], "update")
  end

  -- апдейт звуковой схемы актера
  xr_sound_update_actor()
  
-- ----------------------------------------------------- ARENA_EXTENSION_MOD--------------------------------------------------------
	aem_manager.get_aem():update()

	--'for debug only
	--aem_grenade.scan_dif()
-- ----------------------------------------------------- ARENA_EXTENSION_MOD--------------------------------------------------------

  -- Апдейт прятание оружия игрока во время диалога
  if weapon_hide == true or self.object:is_talking() then
    if self.weapon_hide == false then
      self.object:hide_weapon()
      self.weapon_hide = true
    end
  else
    if self.weapon_hide == true then
      self.object:restore_weapon()
      self.weapon_hide = false
    end
  end 

  -- обновление рестрикторов, которые под логикой, срабатывает через интервалы времени
  if self.next_restrictors_update_time < time then
    bind_restrictor.actor_update(delta)
  -- Апдейтим наш телепорт
	bind_mteleport.actor_update(delta)
    self.next_restrictors_update_time = time + 200

		-- апдейт схемы детектора
		self.actor_detector:update()

		-- Обновление отключения ввода с клавиатуры.
		if self.st.disable_input_time ~= nil and
			 game.get_game_time():diffSec(self.st.disable_input_time) >= self.st.disable_input_idle
		then
			level.enable_input()
			self.st.disable_input_time = nil
		end

		--' Вывод сообщения о большой радиации
		local rad_danger = "cs_radiation_danger"
		local hud = get_hud()
		local custom_static = hud:GetCustomStatic(rad_danger)
		if self.object.radiation >= 0.7 then
			if custom_static == nil then
				custom_static = hud:AddCustomStatic(rad_danger, true)
				custom_static:wnd():SetTextST("st_radiation_danger")
			end
		else
			if custom_static ~= nil then
				hud:RemoveCustomStatic(rad_danger)
			end
		end
  end

  -- обновление пси-антенны
  if sr_psy_antenna.psy_antenna then
    sr_psy_antenna.psy_antenna:update(delta)
  end

    inventory.update()

    -- TAG Хлеб и колбаса портятся от радиации
    if self.object.radiation>0.4 and (self.object:object("bread") or self.object:object("kolbasa")) then
       local need_say = false
       self.object:iterate_inventory(function (dummy,item)  
                                  if item:section()=="bread" and math.random() <= self.object.radiation then
                                      need_say = true 
                                      amk.remove_item(item)  
                                      amk.spawn_item_in_inv("bread_a")
                                  elseif item:section()=="kolbasa" and self.object.radiation>0.6 and math.random() <= (self.object.radiation - 0.2) then
                                      need_say = true 
                                      amk.remove_item(item)  
                                      amk.spawn_item_in_inv("kolbasa_a")
                                  end 
                                  end, nil)
      if need_say then 
          amk.send_tip ("В рюкзаке еда испортилась...",nil,nil,5)    
      end 
    end

  if self.freeplay_stats ~= nil then
        self.freeplay_stats:check_actor_money()
        self.freeplay_stats:check_actor_rank()
  end

  if self.bCheckStart then
    if not has_alife_info("storyline_actor_start") and
       (level.name() == "l01_escape")
    then
      self.object:give_info_portion("storyline_actor_start")
    end

    if not has_alife_info("global_dialogs") then
      self.object:give_info_portion("global_dialogs")
    end

    level_tasks.add_lchanger_location()

		local actor_outfit = db_actor:item_in_slot(6)
		if actor_outfit then db_actor:transfer_item(actor_outfit, db_actor) end

    self.bCheckStart = false    
  end   
  
  
  --AMK UTILS--
  amk.on_actor_upade(delta)
  amk_utils.actor_update(delta)
  amk_offline_alife.actor_update(delta)
  --AMK UTILS--
  sak.out_teleport() 
  sak.nepis_umer()
  braad_test.dead_npc()
  
  -- added by Red75. Контроль за переполнением 
  if self.warning then
    self.warning=nil
    get_hud():AddCustomStatic("hud_save_warning")
    local wnd=get_hud():GetCustomStatic("hud_save_warning"):wnd()
    if self.critical==1 then
      wnd:SetTextST(game.translate_string("amk_warn_trans"))
      self.critical=nil
    elseif self.critical==2 then
      wnd:SetTextST(game.translate_string("amk_warn_trans_critical"))
      self.critical=nil
    else
      wnd:SetTextST(game.translate_string("amk_warn_attention"))
    end
  elseif self.wt and self.wt<time_global() then
    self.wt=nil
    if get_hud():GetCustomStatic("hud_save_warning") then
      get_hud():RemoveCustomStatic("hud_save_warning")
    end
  end
	if xrs_ai then xrs_ai.actor_update(delta)
	end
  -- end of addition
  if biodetector then biodetector.update() end

	sa_callbacks.actor_update(delta)
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:save(packet)
  local pk1=fake_net_packet.fake_net_packet()
  self:save_old(pk1)
  amk.mylog("Packet size is "..pk1:w_tell())
  if pk1:w_tell()>7500 then
    self.warning=true
    self.critical=1
    self.wt=time_global()+60000
    amk.emergency_cleanup()
    self:save_old(packet)
    amk.mylog("Actor packet size is "..packet:w_tell().."!")
    amk.emergency_restore()
  elseif pk1:w_tell()>6000 then
    self.warning=true
    self.wt=time_global()+60000
    self:save_old(packet)
  else
    self:save_old(packet)
    self.wt=time_global()
  end
end

function actor_binder:save_old(packet)
	object_binder.save(self, packet)

	--' Сохраняем уровень сложности
	packet:w_u8(level.get_game_difficulty() + 160)

	--' Сохраняем данные об отключенном вводе
	if self.st.disable_input_time == nil then
		packet:w_bool(false)
	else
		packet:w_bool(true)
		utils.w_CTime(packet, self.st.disable_input_time)
	end

	xr_logic.pstor_save_all(self.object, packet, self.st)

	sr_psy_antenna.save( packet )

	treasure_manager.save(packet)

	task_manager.save(packet)
	self.actor_detector:save(packet)

    self.freeplay_stats:save(packet)

	sa_callbacks.actor_save(packet)
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:load(reader)
	object_binder.load(self, reader)

	--' Загружаем уровень сложности
	local game_difficulty = reader:r_u8()
        local game_diff = game_difficulty

	local load_treasure_manager = false      

        if game_difficulty >= 160 then           
		game_difficulty = game_difficulty - 160
		load_treasure_manager = true           

        else
	   	if game_difficulty >= 150 then           
			game_difficulty = game_difficulty - 150
			load_treasure_manager = true           
		else                                      
		  	if game_difficulty >= 128 then           
				game_difficulty = game_difficulty - 128
				load_treasure_manager = true           
			end
		end                                      
	end

	get_console():execute("g_game_difficulty "..game_difficulty_by_num[game_difficulty])

	if reader:r_eof() then
		abort("SAVE FILE IS CORRUPT")
	end

	local stored_input_time = reader:r_bool()
	if stored_input_time == true then
		self.st.disable_input_time = utils.r_CTime(reader)
		self.st.disable_input_idle = xr_effects.punch_recovery_time
	end

	xr_logic.pstor_load_all(self.object, reader, self.st)

	sr_psy_antenna.load(reader)

	if load_treasure_manager == true then
		treasure_manager.load(reader)
	end


	task_manager.load(reader)
	self.actor_detector:load(reader)

        self.freeplay_stats:load(reader, game_diff)
  
  if xr_logic.pstor_retrieve(self.object,"emerg",false) then -- нельзя использовать amk.load_varible(), так как db.actor ещё не определён
    self.warning=true
    self.critical=2
    self.wt=time_global()+60000
  end

	sa_callbacks.actor_load(reader)
end
----------------------------------------------------------------------------------------------------------------------

-- Weapon functions
function hide_weapon()
  weapon_hide = true
end
function restore_weapon()
  weapon_hide = false
end
