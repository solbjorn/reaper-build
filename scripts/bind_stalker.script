--/amk_rel_1/
--[[------------------------------------------------------------------------------------------------------------------
автор: Диденко Руслан (Stohe)

порядок вызова методов биндера:
reload
reinit
load
net_spawn
--------------------------------------------------------------------------------------------------------------------]]

local amk_particle_amk_particle = amk_particle.amk_particle
local table_remove = table.remove
local xr_sound_update = xr_sound.update

local db_storage = db.storage
local particles={}

----------------------------------------------------------------------------------------------------------------------
class "motivator_binder" (object_binder)

function motivator_binder:__init (obj) super(obj)
  self.loaded = false
	self.update_time = 1000
	self.death_recorded = false
	self.can_talk = false
        self.prev_ammo = -1

    self.first_update = false
        self.particles = {}
end

function motivator_binder:extrapolate_callback(cur_pt)
	if self.object == nil then
		return false
	end

  if self.st.active_section then
    xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "extrapolate_callback")
    self.st.move_mgr:extrapolate_callback(self.object)
  end

  if patrol(self.object:patrol()):flags(cur_pt):get() == 0 then
    return true
  end
  return false
end

local def_ini_file = ini_file("[logic]\nactive = nil")

function motivator_binder:reinit()
	if self.object == nil then
		return
	end
    object_binder.reinit(self)

----------------------------------------------------------------------------------------------------------------------
-- Общие скрипты
----------------------------------------------------------------------------------------------------------------------
	self.st = { followers = {} }
	db_storage[self.object:id()] = self.st

    --' Создание менеджера контроля положений тела
  self.st.state_mgr = state_mgr.bind_manager(self.object)

  self.st.move_mgr = move_mgr.move_mgr(self.object)
  self.st.move_mgr:initialize()
end
----------------------------------------------------------------------------------------------------------------------
local stalker_ids_property_anomaly = stalker_ids.property_anomaly
local callback_hit = callback.hit
local callback_death = callback.death
local callback_use_object = callback.use_object
local game_object_enemy = game_object.enemy
local look_direction = look.direction

function motivator_binder:net_spawn(sobject)
  if not object_binder.net_spawn(self, sobject) then
    return false
  end

	local self_object = self.object

	local zombies = container:get("zombies", { })
	local id = self_object:id()
	local entry = zombies[id]
	if entry then
		local master = server_object(entry.master)
		if not (master and master:alive()) and amk_mod.dezombify(id, entry) then
			zombies[id] = nil
		end
	end

  db.add_obj(self_object)
	-- регистрация в схеме биорадара
	biodetector.add_obj(self_object)

  -- Все CALLBACK-и ставить здесь:
  self_object:set_patrol_extrapolate_callback(motivator_binder.extrapolate_callback, self)
  self_object:set_callback(callback_hit, motivator_binder.hit_callback, self)
  self_object:set_callback(callback_death, motivator_binder.death_callback, self)
  self_object:set_callback(callback_use_object, motivator_binder.use_callback, self)

    --' Загрузка историй для лагеря.
  if self.loaded == false then
		xr_info.loadInfo(self_object, self_object:spawn_ini() or def_ini_file)
  end

  if not self_object:alive() then
    return true
  end

  --' Для зомбированных чуваков говорим что аномалий не существует
	local manager = self_object:motivation_action_manager()
	manager:remove_evaluator	(stalker_ids_property_anomaly)
	manager:add_evaluator		(stalker_ids_property_anomaly, property_evaluator_const(false))

    --' загрузка озвучки
	sound_theme.load_sound(self_object)

  xr_gulag.setup_gulag_and_logic_on_spawn( self_object, self.st, sobject, modules.stype_stalker, self.loaded )

  -- added by xStream for AMK miniSDK
  amk.on_npc_spawn(self_object)

	amk.on_net_spawn(self_object)
  -- end of addition

	local particle_param = config:r_string_cache(self_object:section(), "bones_particles")
	if particle_param and config:section_exist(particle_param) then
		local tmp = amk.parse_ini_section_to_array(config, particle_param)

		for k,v in pairs(tmp) do
			local t = amk.parse_ini_section_to_array(config, v)
			t.obj = self_object
			if not t.stop_on_death or self_object:alive() then
				play_particle(self_object, t)
			end
		end
	end

  return true
end

function motivator_binder:net_destroy()
	local self_object = self.object

	xrs_ai.npc_net_destroy(self_object)

	local self_particles = self.particles
	if #self_particles > 0 then
		for kk,vv in pairs(self_particles) do
			if not vv:is_finished() then
				vv:stop()
				self_particles[kk]=nil
			end
		end
	end

  -- added by xStream for AMK miniSDK
  amk.on_npc_go_offline(self_object)
  -- end of addition

	if self_object == nil then return end

	local obj_id = self_object:id()
  local st = db_storage[obj_id]
  if st.active_scheme then
    xr_logic.issue_event(self_object, st[st.active_scheme], "net_destroy", self_object)
  end

  db.del_obj(self_object)
	-- отрегистрация в схеме биорадара
	biodetector.remove_obj(self_object)

  self:clear_callbacks()
  self_object:set_callback(callback.use_object, nil)

  object_binder.net_destroy(self)

	-- АМК. Очистка рестрикторов
	local sobj = server_object(obj_id)
	if sobj then
                local tbl=amk.read_stalker_params(sobj)
                tbl.crvu32u16u2={}
                amk.write_stalker_params(tbl,sobj)
	end
end

function motivator_binder:clear_callbacks()
	if self.object == nil then return end
  self.object:set_patrol_extrapolate_callback(nil)
	self.object:set_callback(callback_hit, nil)
	self.object:set_callback(callback_death, nil)
end

function motivator_binder:hit_callback(obj, amount, local_direction, who, bone_index)
	local self_object = self.object
	local self_st = self.st

	if self_object == nil then
		return
	end
  -- FIXME: коллбеки неплохо было бы регистрировать в общем storage, а не посхемно...
  -- просто всегда ставить их при включении схемы и снимать при отключении.

  if self_st.active_section then
    xr_logic.issue_event(self_object, self_st[self_st.active_scheme], "hit_callback", obj, amount, local_direction, who, bone_index)
  end
  if self_st.combat_ignore then
    xr_logic.issue_event(self_object, self_st.combat_ignore, "hit_callback", obj, amount, local_direction, who, bone_index)
  end
  if self_st.combat then
    xr_logic.issue_event(self_object, self_st.combat, "hit_callback", obj, amount, local_direction, who, bone_index)
  end
  if self_st.hit then
    xr_logic.issue_event(self_object, self_st.hit, "hit_callback", obj, amount, local_direction, who, bone_index)
  end
  if amount > 0 then
		if sr_territory.territory then
			sr_territory.issue_event(self_object, "hit_callback", obj, amount, local_direction, who, bone_index)
		end
    xr_wounded.hit_callback(self_object:id())
    if blowout_scheme then
      blowout_scheme.hit_callback(obj)
    end
		local be = self_object:best_enemy()
		if not be or ((be:id() ~= who:id() or who:id() == 0) and self_object:relation(who) == game_object_enemy) then
			self_object:set_sight(look_direction, who:position():sub(self_object:position()), false)
		end
  end

  -- added by xStream for AMK miniSDK
  amk.on_npc_hit(obj, amount, local_direction, who, bone_index)
  -- end of addition
end

function motivator_binder:death_callback(victim, who)
	local self_object = self.object
	if self_object == nil then
		return
	end

	xrs_ai.npc_death_callback(self_object)
	sa_callbacks.npc_death(victim, who)

  if who:id() == 0 then
    xr_statistic.addKillCount(self_object)
		freeplay_stats:check_stalker_killed_count()
  end

  if self.st.death then
    xr_logic.issue_event(self_object, self.st.death, "death_callback", victim, who)
  end
  if self.st.active_section then
    xr_logic.issue_event(self_object, self.st[self.st.active_scheme], "death_callback", victim, who)
  end
	if sr_territory.territory then
		sr_territory.issue_event(self_object, "death_callback", victim, who)
	end

	local se_obj = AI:object(self_object:id())
	se_obj.death_light = sr_light.check_light(self_object)

  smart_terrain.on_death( self_object:id() )

  -- added by xStream for AMK miniSDK
  amk.on_death(victim, who)
  -- end of addition

  death_manager.drop_manager(self_object):create_release_item()
	freeplay_stats:give_item_on_death(victim, who)
  self:clear_callbacks()

  --' Наносим небольшой импульс вперед.
  local h = hit()
  h.draftsman = self_object
  h.type = hit.fire_wound
  h.direction = who:position():sub(self_object:position())
  h:bone("pelvis")
  h.power = 1
  h.impulse = 10
  self_object:hit(h)

	local self_particles = self.particles
	if #self_particles > 0 then
		for kk,vv in pairs(self_particles) do
			vv:on_death()
		end
	end

	if self_object:story_id() <= 65535 then
    local community = self_object:character_community()
    if community == "zombied" or
       community == "monolith" or
       community == "arena_enemy"
    then
      return
    end
    actor_stats.remove_from_ranking(self_object:id())
	end
end

function motivator_binder:use_callback(obj, who)
	if self.object == nil then return end

  if self.object:alive() then
    xr_use.notify_on_use(obj, who)
    if self.st.active_section then
      xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "use_callback", obj, who)
    end
	else
		Treasure:use(self.object)
	amk_offline_alife.actor_check_body(self.object)
  end
	if self.object ~= nil then
		if string.find(self.object:section(),"zombie") ~= nil then
			sak.zombie_checkup()
		end
	end

  -- added by xStream for AMK miniSDK
  amk.on_use(obj, who)
  -- end of addition

	sa_callbacks.npc_use(obj, who)
end

function motivator_binder:update(delta)
	if amk.oau_watchdog~=0 then
		abort("Watchdog "..amk.oau_watchdog..".Reason "..amk.oau_reason)
		return
	end
	local self_object = self.object
	if self_object == nil then return end
	local self_object_id = self_object:id()

	object_binder.update(self, delta)

	local self_particles = self.particles
	if particles[self_object_id] and #particles[self_object_id] > 0 then
		for kk, vv in pairs(particles[self_object_id]) do
			self_particles[#self_particles + 1] = amk_particle_amk_particle(vv)
			table_remove(particles[self_object_id], kk)
		end
	end
	if #self_particles > 0 then
		for kk, vv in pairs(self_particles) do
			if vv then
				if vv:is_finished() then
					self_particles[kk] = nil
				else
					vv:update(delta)
				end
			end
		end
	end

	if self.death_recorded then return end

	local npc_alive = self_object:alive()
    if self.first_update == false then
		if not npc_alive and AI:object(self_object:id()).death_droped ~= true then
			death_manager.drop_manager(self_object):create_release_item()
		elseif npc_alive then
			trade_manager.first_update(self_object)
		end
        self.first_update = true
    end

	local npc_state_mgr = self.st.state_mgr
	if npc_state_mgr then
		if npc_alive then
			npc_state_mgr:update()
		else
			self.st.state_mgr = nil
		end
	end

	if time_real_ms > self.update_time then
                        if amk.get_npc_relation(self_object,Actor)=="enemy" and self_object:alive() and self_object.health>0.01 then
                                        if self_object:see(Actor) then
                                                amk.enemy_see_actor(self_object,"npc")
                                        end
                                        if Actor:see(self_object) then
                                                amk.actor_see_enemy(self_object,"npc")
                                        end
                        end

		-- Ray Twitty aka Shadows: если НПС зажмурился, то нас уже не интересуют условия, важно лишь состояние фонарика в момент смерти
		if npc_alive then
			sr_light.check_light(self_object)
			self.update_time = time_real_ms + 1000
		else
			local se_obj = AI:object(self_object:id())
			if se_obj.death_light then
				local torch = self_object:item_in_slot(9)
				if torch then
					torch:enable_attachable_item(true)
					torch:switch_torch(true)
				end
			end
			self.death_recorded = true
		end
	end

	local active_item = self_object:active_item()
	local ammo = active_item and active_item:is_weapon() and active_item:get_ammo_in_magazine() or nil
	if ammo ~= nil then
                        local enemy = self_object:best_enemy()
                        if enemy and enemy:id()==0 and self_object:see(Actor) and self.prev_ammo>ammo then
                                amk.npc_shot_actor(self_object)
                        end

		self.prev_ammo = ammo
	end

	--' Апдейт саундменеджера
	if npc_alive then
		xr_sound_update(self_object)
		if self.can_talk then
			if not self_object:is_talk_enabled() then
				self_object:set_tip_text("")
				self.can_talk = false
			end
		else
			if self_object:is_talk_enabled() then
				self_object:set_tip_text("character_use")
				self.can_talk = true
			end
		end
	else
		self_object:set_tip_text_default()
	end

	xrs_ai.npc_update(self)
end

function motivator_binder:reload(section)
  object_binder.reload(self, section)
end

function motivator_binder:net_save_relevant()
  return true
end

function motivator_binder:save(packet)
  object_binder.save(self, packet)

  xr_logic.save_obj(self.object, packet)
  dialog_manager.save(self.object, packet)
end

function motivator_binder:load(reader)
	if self.object == nil then
		return
	end

  self.loaded = true

  object_binder.load(self, reader)

	if reader:r_eof() then
		abort("bind_stalker.script, motivator_binder:load(): - SAVE FILE IS CORRUPT")
	end

  xr_logic.load_obj(self.object, reader)
	dialog_manager.load(self.object, reader)
end

function init(npc)
	npc:bind_object(motivator_binder(npc))
end

local wp_meet_false = world_property(xr_evaluators_id.stohe_meet_base + 1,false)
local wp_wounded_false = world_property(xr_evaluators_id.sidor_wounded_base + 0, false)
local wp_heli_hunter_false = world_property(xr_evaluators_id.chugai_heli_hunter_base, false)
local wp_abuse_false = world_property(xr_evaluators_id.abuse_base, false)
local wp_evid_outside_false = world_property(blowout_scheme.evid_outside, false)
local wp_evid_blowout_false = world_property(blowout_scheme.evid_blowout, false)
local wp_evid_preblowout_false = world_property(blowout_scheme.evid_preblowout, false)
local wp_evid_anomaly_false = world_property(blowout_scheme.evid_anomaly, false)
local wp_evid_see_stuff_false = world_property(watcher_act.evid_see_stuff, false)

-- Эвалюаторы, которые имеют высший приоритет, и, соответственно, перебивают остальные скрипты собой
function addCommonPrecondition(action)
	action:add_precondition (wp_meet_false)
	action:add_precondition (wp_wounded_false)
	action:add_precondition (wp_heli_hunter_false)
	action:add_precondition (wp_abuse_false)
	action:add_precondition(wp_evid_outside_false)
	action:add_precondition(wp_evid_blowout_false)
	action:add_precondition(wp_evid_preblowout_false)
	action:add_precondition(wp_evid_anomaly_false)
	action:add_precondition(wp_evid_see_stuff_false)

	xrs_ai.addCommonPrecondition(action)
end

function play_particle(obj,params)
	if obj then
		local id = obj:id()
		if not particles[id] then
			particles[id]={}
		end
		particles[id][#particles[id]+1] = params
	end
end
