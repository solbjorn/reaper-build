----------------------------------------------------------------------------------------------------------------------
--'	Схема кемпер. Чудак с бальшой пушкой ходит и отстреливает живность.
--'	автор: Диденко Руслан (Stohe)
--'	TODO:
----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------
-- EVALUATORS
----------------------------------------------------------------------------------------------------------------------

local operator_patrol = xr_actions_id.stohe_camper_base + 1
local prop_end = xr_evaluators_id.stohe_camper_base + 1
local prop_can_fight = xr_evaluators_id.sidor_wounded_base + 1
local prop_close_combat = xr_evaluators_id.stohe_camper_base + 2

local xr_actions_id_alife = xr_actions_id.alife

local stalker_ids_action_combat_planner  = stalker_ids.action_combat_planner
local stalker_ids_property_enemy  = stalker_ids.property_enemy
local stalker_ids_property_danger  = stalker_ids.property_danger
local stalker_ids_sound_alarm  = stalker_ids.sound_alarm

--' Условие завершения скрипта
class "evaluator_end" (property_evaluator)
function evaluator_end:__init(name, storage) super (nil, name)
	self.a = storage
end
function evaluator_end:evaluate()
	return (self.a.section ~= db.storage[self.object:id()].active_section)
end

--' Обычный комбат или кемперский
class "evaluator_close_combat" (property_evaluator)
function evaluator_close_combat:__init(name, manager, storage) super (nil, name)
	self.a = storage
	self.is_enemy_eval = manager:evaluator(stalker_ids_property_enemy)
	self.can_fight_eval = manager:evaluator(prop_can_fight) -- is not wounded
	self.is_danger_eval = manager:evaluator(stalker_ids_property_danger)
	self.close_combat = false
end
function evaluator_close_combat:evaluate()
	if self.a.section ~= db.storage[self.object:id()].active_section then
		return true
	end

	if not self.is_enemy_eval:evaluate() then
		return false
	end

	-- если мы не можем воевать вообще - вернуть false
	if not self.can_fight_eval:evaluate() then
		return false
	end

	-- Если видим гранату - автоматом отпускаем в close_combat (возвращаем true)
	if self.is_danger_eval:evaluate() then
		return true
	end

	if self.object:best_enemy() == nil then
		return self.close_combat  -- Тут возможно нужно просто устанавливать FALSE и возвращать FALSE
	end

	if self.close_combat == false then
		self.close_combat = self.object:position():distance_to(self.object:memory_position(self.object:best_enemy())) < self.a.radius
	end

	if self.close_combat == true then
		local a = self.object:memory_time(self.object:best_enemy())
		if a then
			if time_global() - a > 20000 then
				self.close_combat = false
			end
		else
			self.close_combat = false
		end
	end

	return self.close_combat
end

----------------------------------------------------------------------------------------------------------------------
-- ACTIONS
----------------------------------------------------------------------------------------------------------------------
--' Патрулировать территорию по патрульному пути

class "action_patrol" (action_base)
function action_patrol:__init (npc,action_name,storage) super (nil,action_name)
	self.a = storage
	self.move_mgr = db.storage[npc:id()].move_mgr
	self.a.scan_table = {}
end
function action_patrol:initialize()
	action_base.initialize(self)
	self.object:set_desired_position()
	self.object:set_desired_direction()

	self:reset_scheme()
	self.enemy_position = nil
end
function action_patrol:reset_scheme()
	state_mgr.set_state(self.object, "patrol")
	self.a.signals = {}
	self.a.scan_table = {}
	if self.a.sniper == true then
		self.move_mgr:reset(self.a.path_walk,
			utils.path_parse_waypoints(self.a.path_walk),
			nil,
			nil,
			nil,self.a.suggested_state,{obj=self,func=self.process_point})

		-- тут вставить парсинг углов для скана
		local path = patrol(self.a.path_look)
		if path ~= nil then
			for k = 0, path:count() - 1 do
				for i = 0, 31 do
					if path:flag(k, i) then
						if self.a.scan_table[i] == nil then
							self.a.scan_table[i] = {}
						end
						table.insert(self.a.scan_table[i], {key = k, pos = path:point(k)})
					end
				end
			end
		end
	else
		self.move_mgr:reset(self.a.path_walk,
			utils.path_parse_waypoints(self.a.path_walk),
			self.a.path_look,
			utils.path_parse_waypoints(self.a.path_look),
			nil,self.a.suggested_state,{obj=self,func=self.process_point})
	end
	self.a.last_look_point = nil
	self.a.cur_look_point = nil
	self.a.scan_begin = nil
end
function action_patrol:activate_scheme()
    self:reset_scheme()
end
function action_patrol:can_shoot()
    if self.a.shoot == "always" then
		return true
	end
    if self.a.shoot == "none" then
		return false
	end
    if self.a.shoot == "terminal" then
		if self.move_mgr:standing_on_terminal_waypoint() then
			return true
		else
			return false
		end
	end
	abort("Camper: unrecognized shoot type [%s] for [%s]", tostring(self.a.shoot), self.object:name())
	return true
end
function action_patrol:execute()
	action_base.execute (self)

	if xr_logic.try_switch_to_another_section (self.object, self.a, db_actor) then
		return
	end

	self.enemy = self.object:best_enemy()

	if self.enemy ~= nil then
		self.a.mem_enemy = self.object:memory_time(self.enemy)

		--'Забывание врага по времени.
		if self.a.mem_enemy == nil or
		   time_global()- self.a.mem_enemy > self.a.idle
		then
			self.enemy = nil
			self.a.mem_enemy = nil
			self.move_mgr:continue()
		end
	else
		if self.a.mem_enemy ~= nil then
			self.a.mem_enemy = nil
			self.move_mgr:continue()
		end
	end

	-- Три типа действия:
	-- Есть враг
	if self.enemy ~= nil then
		if self.object:see(self.enemy) == true and self:can_shoot() then
			-- отстрел врага
			if self.a.sniper == true then
				if self.a.suggested_state.campering_fire then
					state_mgr.set_state(self.object, self.a.suggested_state.campering_fire, nil, nil, {look_object = self.enemy, look_position = self.enemy:position()}, {animation = true}, nil, {yaw_delta = 0.2})
				else
					state_mgr.set_state(self.object, "hide_sniper_fire", nil, nil, {look_object = self.enemy, look_position = self.enemy:position()}, {animation = true}, nil, {yaw_delta = 0.2})
				end
			else
				if self.a.suggested_state.campering_fire then
					state_mgr.set_state(self.object, self.a.suggested_state.campering_fire, nil, nil, {look_object = self.enemy, look_position = self.enemy:position()}, {animation = true}, nil, {yaw_delta = 0.2})
				else
					state_mgr.set_state(self.object, "hide_fire", nil, nil, {look_object = self.enemy, look_position = self.enemy:position()}, {animation = true}, nil, {yaw_delta = 0.2})
				end
			end
			xr_sound.set_sound(self.object, self.a.attack_sound)

		else
			--' Анализируем последнюю известную позицию врага.
			local memory_position = self.object:memory_position(self.enemy)
			if self.enemy_position == nil or
			   self.enemy_position.x ~= memory_position.x or
			   self.enemy_position.y ~= memory_position.y or
			   self.enemy_position.z ~= memory_position.z
			then
				self.enemy_position = memory_position
				--' Занести место поиска врага в scan_table
				if self.a.sniper == true then
					self.position = self.object:position()

					self.direction = vector():set(self.enemy_position.x - self.position.x,
												0,
												self.enemy_position.z - self.position.z)
					self.direction:normalize()
					local wide_sight = self.position:distance_to(self.enemy_position)*math.tan(self.a.enemy_disp)


					self.point_0 = vector():set(self.enemy_position.x + wide_sight*self.direction.z,
												self.enemy_position.y,
												self.enemy_position.z - wide_sight*self.direction.x)

					self.point_2 = vector():set(self.enemy_position.x - wide_sight*self.direction.z,
												self.enemy_position.y,
												self.enemy_position.z + wide_sight*self.direction.x)

					self.a.scan_table[-1] = {}
					table.insert(self.a.scan_table[-1], {key = 0, pos =self.point_0})
					table.insert(self.a.scan_table[-1], {key = 1, pos =self.enemy_position})
					table.insert(self.a.scan_table[-1], {key = 2, pos =self.point_2})
				end
			end

			xr_sound.set_sound(self.object, nil)
			if self.a.sniper == true then
				-- поиск врага (сканирование врага)
				-- сканируем
				if time_global() - self.a.mem_enemy < self.a.post_enemy_wait then
					local position
					if self.enemy_position then
						position = {look_position = self.enemy_position}
					end
					if self.a.suggested_state.campering then
						state_mgr.set_state(self.object, self.a.suggested_state.campering, nil, nil, position)
					else
						state_mgr.set_state(self.object, "hide_na", nil, nil, position)
					end
				else
					self:scan(-1)
				end
			else
				-- если норетрит или мы на месте - ныкаться, иначе идти на точку
				if self:on_place() then
					local position
					if self.enemy_position then
						position = {look_position = self.enemy_position}
					end
					if self.a.suggested_state.campering then
						state_mgr.set_state(self.object, self.a.suggested_state.campering, nil, nil, position)
					else
						state_mgr.set_state(self.object, "hide", nil, nil, position)
					end
				else
					-- идем дальше
					self.move_mgr:continue()
					self.move_mgr:update()
				end
			end
		end
		return
	end

	local danger = self:process_danger()
	if danger then
		xr_sound.set_sound(self.object, nil)
		self.danger = true
		return
	end

	if self.danger == true then
		self.danger = false
		self.move_mgr:continue()
	end

	-- если нет ни врага ни денжера.
	if self.a.sniper == true then
		-- Сканирование местности в узловых точках
		-- если мы на точке - запустить счетчик сканирования и посканировать определенное время.
		if self:on_place() then
			if self.scantime == nil then
				self.scantime = time_global()
			end
			-- сканируем
			self:scan(self.a.wp_flag)
			-- если мы стоим на финальной точке - не ресетить.
			if self.move_mgr:standing_on_terminal_waypoint() then
				return
			end
			-- проверка на завершение сканирования.
			if self.scantime ~= nil and time_global() - self.scantime >= self.a.scantime_free then
				self.move_mgr:continue()
			end
		else
			self.scantime = nil
			self.move_mgr:update()
		end
	else
		-- Перемещение по move_mgr
		self.move_mgr:update()
	end

end
function action_patrol:process_danger()
	local best_danger = self.object:best_danger()
	if best_danger == nil then
		return false
	end

	local passed_time = time_global() - best_danger:time()
	-- Отсеиваем по инерции
	if xr_danger.check_danger_inertion_time(self.object, best_danger, passed_time) == false then
		return false
	end

	-- Отсеиваем реакцию на денжеры своих чуваков
	local bd_type = best_danger:type()
	local danger_obj = best_danger:object()
	if bd_type == danger_object.attack_sound then
		if danger_obj and danger_obj:character_community() == self.object:character_community() then
			return false
		end
	end

	-- Отсеиваем по расстоянию
	if xr_danger.check_danger_distance(self.object, best_danger) == false then
		return false
	end

	local position = {look_position = best_danger:position()}
	local emerg = nil
	if self.danger ~= true then
		emerg = {animation = true}
		self.object:play_sound(stalker_ids_sound_alarm, 1, 0, 1, 0)
	end

	-- Если денжер опасный - стрельнуть в позицию его инициатора, если нет - повернуться и смотреть туда.
	-- Опасный денжер - хит или очень близкий рикошет.
	local urgent_danger = (danger_obj ~= nil) and
						  (bd_type == danger_object.attacked) and
						  (time_global() - best_danger:time() < 5000)

	if urgent_danger == true then
		local danger_object_position = {look_position = danger_obj:position()}
		if self.a.suggested_state.campering_fire then
			state_mgr.set_state(self.object, self.a.suggested_state.campering_fire, nil, nil, danger_object_position, {animation = true}, nil, {yaw_delta = 0.2})
		else
			state_mgr.set_state(self.object, "hide_fire", nil, nil, danger_object_position, {animation = true}, nil, {yaw_delta = 0.2})
		end
	else
		if self.a.suggested_state.campering then
			state_mgr.set_state(self.object, self.a.suggested_state.campering, nil, nil, position, emerg)
		else
			if self.a.sniper == true then
				state_mgr.set_state(self.object, "hide_na", nil, nil, position, emerg)
			else
				state_mgr.set_state(self.object, "hide", nil, nil, position, emerg)
			end
		end
	end
	return true
end
function action_patrol:scan(flag)
	if self.a.scan_table[flag] == nil then
		return
	end

	if self.flag ~= flag then
		self.flag = flag
		self.a.scan_begin = nil
		self.a.cur_look_point = nil
		self.a.last_look_point = nil
	end

	if self.a.scan_begin == nil or
	   time_global() - self.a.scan_begin > self.a.time_scan_delta then

		self.next_point = self:get_next_point(flag)
		if self.a.cur_look_point == nil then
			self.a.cur_look_point = 1
		end
		if self.a.last_look_point == nil then
			self.a.last_look_point = self.next_point
		end

		self.look_position = self.a.last_look_point.pos
		self.dest_position = self.next_point.pos
		self.look_point = vector():set(self.look_position.x + self.a.cur_look_point * (self.dest_position.x - self.look_position.x)/self.a.scandelta,
									   self.look_position.y + self.a.cur_look_point * (self.dest_position.y - self.look_position.y)/self.a.scandelta,
									   self.look_position.z + self.a.cur_look_point * (self.dest_position.z - self.look_position.z)/self.a.scandelta)
		if self.a.suggested_state.campering then
			state_mgr.set_state(self.object, self.a.suggested_state.campering, nil, nil, {look_position = self.look_point}, nil, nil, {yaw_delta = 0.2})
		else
			state_mgr.set_state(self.object, "hide_na", nil, nil, {look_position = self.look_point}, nil, nil, {yaw_delta = 0.2})
		end

		if self.a.cur_look_point >= self.a.scandelta then
			self.a.cur_look_point = nil
			self.a.last_look_point = self.next_point
		else
			if self.a.scan_begin ~= nil then
				self.a.cur_look_point = self.a.cur_look_point + (time_global() - self.a.scan_begin)/self.a.time_scan_delta
			else
				self.a.cur_look_point = self.a.cur_look_point + 1
			end
		end
		self.a.scan_begin = time_global()
	end
end
function action_patrol:get_next_point(flag)
	local next = false

	if self.a.last_look_point == nil then
		table.sort(self.a.scan_table[flag], function(a,b) return a.key < b.key end)
	end
	for k,v in pairs(self.a.scan_table[flag]) do
		if self.a.last_look_point == nil then
			return v
		end
		if next == true then
			return v
		end
		if self.a.last_look_point.key == v.key then
			next = true
		end
	end
	if next == true then
		if self.a.last_look_point.key == 0 then
			table.sort(self.a.scan_table[flag], function(a,b) return a.key < b.key end)
		else
			table.sort(self.a.scan_table[flag], function(a,b) return a.key > b.key end)
		end
	end
	return self.a.last_look_point
end
function action_patrol:process_point(mode, number)
	return false
end
function action_patrol:finalize()
	self.move_mgr:finalize()
	action_base.finalize (self)
end
function action_patrol:on_place()
    if self.a.no_retreat == true then return false end

	local path = patrol(self.a.path_walk)
	if path ~= nil then
		for k = 0, path:count() - 1 do
			if utils.stalker_at_waypoint(self.object, patrol(self.a.path_walk), k) then
				for i = 0, 31 do
					if path:flag(k, i) then
						self.a.wp_flag = i
						return true
					end
				end
				self.a.wp_flag = nil
				return false
			end
		end
		self.a.wp_flag = nil
		return false
	end
end

----------------------------------------------------------------------------------------------------------------------
-- BINDER
----------------------------------------------------------------------------------------------------------------------
local wp_prop_end_false = world_property(prop_end, false)
local wp_prop_end_true = world_property(prop_end, true)
local wp_prop_close_combat_false = world_property(prop_close_combat, false)
local wp_prop_close_combat_true = world_property(prop_close_combat, true)
local wp_prop_can_fight_true = world_property(prop_can_fight, true)
local wp_stalker_ids_property_alive_true = world_property(stalker_ids.property_alive, true)
local wp_stalker_ids_property_danger_false = world_property(stalker_ids_property_danger, false)
local wp_stalker_ids_property_anomaly_false = world_property(stalker_ids.property_anomaly,false)
local wp_stalker_ids_property_enemy_false = world_property(stalker_ids_property_enemy, false)

function add_to_binder_q(object, storage)
	local manager = object:motivation_action_manager()

	manager:add_evaluator (prop_end, evaluator_end("camper_end", storage))
	manager:add_evaluator (prop_close_combat, evaluator_close_combat("camper_close_combat", manager, storage))

	local action = action_patrol (object,"action_camper_patrol", storage) -- removed "this."
	action:add_precondition (wp_stalker_ids_property_alive_true)
	action:add_precondition (wp_prop_end_false)
	action:add_precondition (wp_prop_close_combat_false)
	action:add_precondition (wp_prop_can_fight_true)
	action:add_precondition (wp_stalker_ids_property_danger_false)
	action:add_precondition (wp_stalker_ids_property_anomaly_false)
	xr_motivator.addCommonPrecondition(action)
	action:add_effect (wp_prop_end_true)
	action:add_effect (wp_stalker_ids_property_enemy_false)
	manager:add_action (operator_patrol, action)
	storage.actions[ action ] = true

	action = manager:action (xr_actions_id_alife)
	action:add_precondition	(wp_prop_end_true)

	action = manager:action (stalker_ids_action_combat_planner)
	action:add_precondition (wp_prop_close_combat_true)
	action:add_effect (wp_prop_close_combat_false)
	action:add_effect (wp_prop_end_true)
end

function set_scheme(npc, ini, scheme, section, gulag_name)
	local function get_field_string(field, default)
		return (ini:line_exist(section, field) and ini:r_string(section, field)) or default
	end

	local st = xr_logic.assign_storage_and_bind(npc, ini, scheme, section)
	st.logic = xr_logic.cfg_get_switch_conditions(ini, section, npc)

	if section and ini:section_exist(section) then
		if not ini:line_exist(section, "path_walk") or not ini:line_exist(section, "path_look") then
			abort("xr_camper scheme %s, section %s: missing path_walk or path_look field", scheme, section)
			return
		end
		if gulag_name and gulag_name ~= "" then
			gulag_name = gulag_name .. "_"
			st.path_walk  = gulag_name .. ini:r_string(section, "path_walk")
			st.path_look  = gulag_name .. ini:r_string(section, "path_look")
		else
			st.path_walk  = ini:r_string(section, "path_walk")
			st.path_look  = ini:r_string(section, "path_look")
		end
		st.sniper = (ini:line_exist(section, "sniper") and ini:r_bool(section, "sniper")) or false
		st.no_retreat = (ini:line_exist(section, "no_retreat") and ini:r_bool(section, "no_retreat")) or false
		st.shoot = get_field_string("shoot", "always")
		if st.sniper == true and st.no_retreat == true then
			abort("ERROR: NPC [%s] Section [%s]. No_retreat not available for SNIPER.", npc:name(), section)
			return
		end

		st.radius = (ini:line_exist(section, "radius") and ini:r_float(section, "radius")) or 20
		st.suggested_state = {}
		st.suggested_state.standing = get_field_string("def_state_standing")
		st.suggested_state.moving = get_field_string("def_state_moving")
		st.suggested_state.moving1 = st.suggested_state.moving
		st.suggested_state.moving2 = st.suggested_state.moving
		st.suggested_state.moving3 = st.suggested_state.moving
		st.suggested_state.moving_fire = get_field_string("def_state_moving_fire")
		st.suggested_state.campering = get_field_string("def_state_campering")
		st.suggested_state.campering_fire = get_field_string("def_state_campering_fire")
		st.scantime_free = (ini:line_exist(section, "scantime_free") and ini:r_float(section, "scantime_free")) or 60000
		st.attack_sound = get_field_string("attack_sound", "fight_attack")

		if st.attack_sound == "false" then
			st.attack_sound = nil
		end

		-- Время забывания врага
		st.idle = (ini:line_exist(section, "enemy_idle") and ini:r_float(section, "enemy_idle")) or 60000
	else 
			abort("xr_camper scheme %s has bad or missing section: %s", scheme, tostring(section))
			return
	end

	st.post_enemy_wait = 5000 -- время, которое мы ждем врага, смотря в его последнюю позицию.
	st.enemy_disp = 7/57.2957 -- Угол в пределах которого снайпер ведет поиск потерянного врага.

	st.scandelta = 30
	st.timedelta = 4000
	st.time_scan_delta = st.timedelta/st.scandelta
end
