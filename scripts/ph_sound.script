local math_random = math.random

class "snd_source"
function snd_source:__init (obj, storage)
  self.object = obj
  self.st = storage
  self.destructed = false
end
function snd_source:reset_scheme(loading)
  self.last_update = 0
  self.st.signals = {}
  self.played_sound = nil

  self.first_sound = true
    self.st.pause_time = 0
    self.st.sound_set = true
    if loading == false then
     self.destructed = false
  else
     self.destructed = xr_logic.pstor_retrieve (self.object, "destr")
  end
end

function snd_source:save ()
  xr_logic.pstor_store (self.object, "destr",  self.destructed)
end

function snd_source:hit_callback(obj, amount, local_direction, who, bone_index)
    if self.st.no_hit == true then return end

    if self.played_sound ~= nil then
       self.played_sound:stop ()
       self.played_sound = nil
    end
    self.destructed = true
end

local is_siren = {
	esc_matugalnik                     = 100,
	arg_nii_rupor                      = 100,
	dolg_megafon                       = 100,
	mil_physic_destroyable_object_0046 = 100,
	pri_ambient_battle_sound_zone_0000 = 100,
	pri_ambient_battle_sound_zone_0001 = 100,
	pri_ambient_battle_sound_zone_0002 = 100,
	pri_ambient_battle_sound_zone_0003 = 100,

	bar_radio         = 5,
	esc_radio_doctor  = 5,
	gar_radio_kulinar = 5,
	prapor_mafon      = 5,
	val_gila_radio    = 5,
	barov_radio       = 5,
	sak_radio         = 5,
	pri_doctor_radio  = 5,
	bar_radio_dolg    = 5
}

function snd_source:update(delta)
  if self.destructed == true then return end

	local time_ = time_real_ms
	local blt = get_value("blowout", 0)
	if blt>0 and (not self.amk_override) and
		(is_siren[self.object:name()])
	then
		if self.played_sound then self.played_sound:stop() end
		self.amk_override=true
		self.st.pause_time=0
		self.rnd_snd = is_siren[self.object:name()]
	elseif blt==0 and self.amk_override then
		if self.played_sound then self.played_sound:stop() end
		self:reset_scheme(false)
		self.amk_override=false
		self.st.pause_time=time_+math_random(30000, 60000)
		self.rnd_snd = nil
		self.siren = nil
	end

	if xr_logic.try_switch_to_another_section(self.object, self.st) then
    return
  end

  if self.st.pause_time > time_ then
      return
  end

  if self.st.sound_set == true then
      self.st.sound_set = false

		if self.amk_override then
			local snd
			if math_random(1, self.rnd_snd)<10 then
				snd = sound_object([[script_replics\megafon\music\megafon_music_]]..math_random(1,15))
			else
				self.siren = true
				snd = sound_object([[ambient\siren2]])
			end
			self.played_sound = snd
		else
			if self.st.random then
				self.played_sound = xr_sound.get_sound_object(self.st.theme, "random")
			elseif self.st.looped then
				self.played_sound = xr_sound.get_sound_object(self.st.theme, "looped")
			else
				self.played_sound = xr_sound.get_sound_object(self.st.theme, "seq")
			end
		end

		if self.played_sound ~= nil then
			local f
			if self.amk_override then
				f = sound_object.s3d
				if self.siren then f = f + sound_object.looped end
			else
				f = self.st.looped and 1 or 0
			end
			self.played_sound:play_at_pos(self.object, self.object:position(), 0, f)
		else
			self.st.signals["theme_end"] = true
		end
		self.first_sound = false
	end

  if self.last_update == 0 then
     self.last_update = time_ + 50
  else
     if time_ > self.last_update then
        self.last_update = 0
     else
        return
     end
  end

  if self.played_sound ~= nil then
    if self.played_sound:playing () == false then
      if self.first_sound == false then
        self.st.signals["sound_end"] = true
      end

      self.st.sound_set = true
      if (self.st.pause_min ~= 0 or self.st.pause_max ~= 0) and (not self.amk_override) then
        self.st.pause_time = time_ + math_random(self.st.pause_min, self.st.pause_max)
      end
      self.first_sound = false
    else
      self.played_sound:set_position (self.object:position ())
			if self.st.volume then
				self.played_sound.volume = self.st.volume
			end
    end
  end
end

function snd_source:use_callback(obj, actor)
	self.destructed = false
	if self.st.on_use then
		return xr_logic.switch_to_section(self.object, self.st, xr_logic.pick_section_from_condlist(self.object, self.st.on_use.condlist))
	end
	return false
end

function snd_source:net_destroy()
	self:deactivate()
end

function snd_source:deactivate ()
    if self.played_sound ~= nil then
       self.played_sound:stop ()
       self.played_sound = nil
    end
	self.object:set_tip_text("")
end

function add_to_binder(npc, storage)
	storage.actions[ snd_source(npc, storage) ] = true
end

function set_scheme(npc, ini, scheme, section, gulag_name)
	local function get_field_bool(field, default)
		if ini:line_exist(section, field) then return ini:r_bool(section, field) end
		return default or false
	end
	local function get_field_number(field, default)
		return (ini:line_exist(section, field) and ini:r_float(section, field)) or default
	end
	local st    = xr_logic.assign_storage_and_bind(npc, ini, scheme, section)
	st.logic    = xr_logic.cfg_get_switch_conditions(ini, section, npc)
	local tips
	if section and ini:section_exist(section) then
		st.theme    = (ini:line_exist(section, "snd") and ini:r_string(section, "snd")) or nil
		st.looped   = get_field_bool("looped", false)
		st.random   = get_field_bool("random", true)
		st.pause_min = get_field_number("min_idle", 0)
		st.pause_max = get_field_number("max_idle", 0)
		st.volume = ini:r_float_ex(section, "volume")
		st.no_hit   = get_field_bool("no_hit", true)

		st.on_use = xr_logic.cfg_get_condlist(ini, section, "on_use", npc)
		tips = ini:r_string_ex(section, "tips", "")
	else
		abort("ph_sound.set_scheme: missing valid section - object: %s, scheme: %s, section %s", npc, scheme, tostring(section))
		return
	end
	if st.pause_max < st.pause_min then
		abort("ph_sound.set_scheme: invalid time range (pause_max<pause_min) - object: %s, scheme: %s, section %s", npc, scheme, tostring(section))
		return
	end

	npc:set_tip_text(tips)
end
