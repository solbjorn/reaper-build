--[[------------------------------------------------------------------------------------------------------------------
Respawner. Схема обновления популяции всего всего всего в симуляции.
by Stohe (Диденко Руслан)
--------------------------------------------------------------------------------------------------------------------]]

local often_min  = 16
local often_max  = 24
local medium_min = 32
local medium_max = 48
local seldom_min = 72
local seldom_max = 96

local idle_spawn_preset = {
	seldom = seldom_min * 3600,
	medium = medium_min * 3600,
	often  =  often_min * 3600,
	once   =       -100 * 3600
}

local idle_spawn_preset_max = {
	seldom = seldom_max * 3600,
	medium = medium_max * 3600,
	often  =  often_max * 3600,
	once   =       -100 * 3600
}

-- Список респавнеров, для сбора статистики
local respawners = {}
local respawners_by_parent = {}

local amk_respawner_control = {}
local amk_named_respawner_control = {}

local smart_terrain_CTime_0 = smart_terrain.CTime_0
local utils_w_CTime = utils.w_CTime
local utils_r_CTime = utils.r_CTime

local math_random =  math.random
local string_gfind = string.gfind
local table_remove = table.remove
----------------------------------------------------------------------------------------------------------------------
-- Разные полезные функции
----------------------------------------------------------------------------------------------------------------------
function r_bool( spawn_ini, section, line, default )
  if spawn_ini:line_exist( section, line ) then
    return spawn_ini:r_bool( section, line )
  else
    return default
  end
end

function r_str( spawn_ini, section, line, default )
  if spawn_ini:line_exist( section, line ) then
    return spawn_ini:r_string( section, line )
  else
    return default
  end
end

function r_2nums( spawn_ini, section, line, def1, def2 )
  if spawn_ini:line_exist( section, line ) then
    -- если default-ов больше, чем значений в ini, то забить недостающие последним значением из ini
    local t = parse_names( spawn_ini:r_string( section, line ) )
    local n = #t

    if n == 0 then
      return def1, def2
    elseif n == 1 then
      return t[1], def2
    else
      return t[1], t[2]
    end
  else
    return def1, def2
  end
end

function parse_names( s )
    local t = {}
    for name in string_gfind( s, "([%w_%-.\\]+)%p*" ) do
        t[#t+1] = name
    end
    return t
end

function r_spawns( namelist, sectSpawnProps, item_spawn)
	local t = parse_names( namelist )
	local n = #t

	local ret_table = {}
	local k = 1
	while k <= n do
		local spawn = {}
		local spawn_section = t[k]
		spawn.section = spawn_section
		-- Проверяем что это не последняя запись
		if t[k+1] ~= nil then
			local p = tonumber(t[k+1])
			-- проверяем что вторым числом задана вероятность, а не другая секция спавну
			if p then
				-- забиваем число
				spawn.prob = p
				k = k + 2
			else
				-- забиваем дефолт 1
				spawn.prob = 1
				k = k + 1
			end
		else
			spawn.prob = 1
			k = k + 1
		end
		ret_table[#ret_table+1] = spawn

		-- Вычитываем настройки секций респавна и кешируем их.
		if not item_spawn and sectSpawnProps[spawn_section] == nil then
			local respawn_ini = system_ini()

			local community = respawn_ini:line_exist(spawn_section, "community") and respawn_ini:r_string(spawn_section, "community") or "nil"
			local rank = respawn_ini:line_exist(spawn_section, "spec_rank") and respawn_ini:r_string(spawn_section, "spec_rank") or "nil"
			local check = true
			local custom_data = respawn_ini:line_exist(spawn_section, "custom_data") and respawn_ini:r_string(spawn_section, "custom_data") or nil
			if custom_data ~= nil then
				local custom_data_ltx = ini_file(custom_data)
				if custom_data_ltx:section_exist("smart_terrains") then
					if custom_data_ltx:line_exist("smart_terrains", "none") then
						if custom_data_ltx:r_string("smart_terrains", "none") == "true" then
							check = false
						end
					end
					if custom_data_ltx:line_exist("smart_terrains", "respawn_check") then
						if custom_data_ltx:r_string("smart_terrains", "respawn_check") == "false" then
							check = false
						end
					end
				end
			end

			sectSpawnProps[spawn_section] = {community = community, rank = rank, check = check}
		end
	end
	return ret_table
end

----------------------------------------------------------------------------------------------------------------------
-- Серверный объект спавнера
----------------------------------------------------------------------------------------------------------------------
class "se_respawn" ( cse_alife_smart_zone )
function se_respawn:__init( section ) super( section )
  self.spawned_obj = {}
  -- Таблица для кеширования свойств секций респавна.
  self.sectSpawnProps = {}

	self.respawn_time = smart_terrain_CTime_0
end
-- сохранение
function se_respawn:STATE_Write( packet )
  cse_alife_smart_zone.STATE_Write( self, packet )

  local table_size = #self.spawned_obj

	if table_size > 255 then
		abort("Too many spawns ("..tostring(table_size)..") for "..self:name() )
		table_size = 255
	end
	packet:w_u8(table_size)
	utils_w_CTime(packet, self.respawn_time or smart_terrain_CTime_0)

	for i=1,table_size do
		packet:w_u16(self.spawned_obj[i])
	end
end

-- восстановление
function se_respawn:STATE_Read( packet, size )
  cse_alife_smart_zone.STATE_Read( self, packet, size )

	local table_size = packet:r_u8()
	self.respawn_time = utils_r_CTime( packet )
	for i=1,table_size do
		self.spawned_obj[i] = packet:r_u16()
	end
end

-- инициализация объекта.
-- вызывается симулятором.
function se_respawn:on_register()
  cse_alife_smart_zone.on_register( self )
	init_respawn_params(self)
end

function init_respawn_params(obj, reset)
	amk_respawner_control[obj:name()] = obj

	-- Вычитываем настройки спауна
	local ini = obj:spawn_ini()
	local section_name = "respawn"
	if not ini:section_exist(section_name) then
		return
	end

	local function r_field_num( line, default )
		if ini:line_exist( section_name, line ) then
			return ini:r_float( section_name, line )
		else
			return default
		end
	end

	obj.item_spawn = r_bool(ini, section_name, "item_spawn", false)
	if ini:line_exist( section_name, "respawn_section" ) then
		obj.respawn_section = r_spawns(ini:r_string( section_name, "respawn_section" ), obj.sectSpawnProps, obj.item_spawn)
	else
		obj.respawn_section = nil
	end
	if obj.respawn_section == nil then
		abort("RESPAWN: [%s] field 'respawn_section' doesn't exist.", obj:name())
		return
	end

  obj.spawned_goes_online = r_bool(ini, section_name, "spawned_goes_online", nil)

  obj.spawn_once = r_bool(ini, section_name, "spawn_once", false)

  obj.amk_name = r_str(ini, section_name, "amk_name", nil)
	if obj.amk_name then amk_named_respawner_control[obj.amk_name] = obj end

	obj.min_count = r_field_num("min_count", 0)
	obj.max_count = r_field_num("max_count", 255)
	if obj.max_count < 0 or obj.max_count > 255 then obj.max_count = 255 end
	if obj.min_count > obj.max_count then
		abort("RESPAWN: [%s] min_count > max_count", obj:name())
		obj.min_count = obj.max_count
	end

	obj.max_spawn = r_field_num("max_spawn", 1)
	obj.idle_spawn_min, obj.idle_spawn_max = r_2nums(ini, section_name, "idle_spawn")
	if obj.idle_spawn_min == nil then
		abort("RESPAWN: [%s] field 'idle_spawn' doesn't exist.", obj:name())
		obj.idle_spawn_min = "seldom"
	end
	if obj.idle_spawn_max == nil then
		obj.idle_spawn_max = obj.idle_spawn_min
	end

	--' Вычитка пресетов
	local min_temp = 0
	if idle_spawn_preset[obj.idle_spawn_min] ~= nil then
		obj.idle_spawn_min = idle_spawn_preset[obj.idle_spawn_min]
		if obj.idle_spawn_min > min_temp then
			min_temp = obj.idle_spawn_min
		else
			obj.idle_spawn_min = min_temp
		end
	else
		obj.idle_spawn_min = tonumber(obj.idle_spawn_min)
	end
	if idle_spawn_preset_max[obj.idle_spawn_max] ~= nil then
		obj.idle_spawn_max = idle_spawn_preset_max[obj.idle_spawn_max]
		if obj.idle_spawn_max < obj.idle_spawn_min then
			obj.idle_spawn_min = obj.idle_spawn_max
			obj.idle_spawn_max = min_temp
		end
	else
		obj.idle_spawn_max = tonumber(obj.idle_spawn_max)
	end

	obj.str_conditions = r_str(ini, section_name, "conditions", "100")
	obj.conditions = xr_logic.parse_condlist_q(obj.str_conditions)
	obj.respawn_radius = r_field_num("respawn_radius", -1)
	obj.parent = r_field_num("parent", nil)

	if reset ~= nil and reset == true then
		-- производим первичную инициализацию
		obj.respawn_time = game.get_game_time()
	end

	-- Для сбора статистики сохраняем указатель на респавнер
	respawners[obj:name()] = obj
	if obj.parent ~= nil then
		respawners_by_parent[obj.parent] = obj
	end
end

-- Создаем объект
function se_respawn:create(prob)
	if prob == nil then
		abort("RESPAWN[%s] - spawn probability is not set", tostring(self:name()))
		prob = 0
	end

	if tostring(prob)=="true" then
		prob=80
	elseif tostring(prob)=="false" then
		prob=0
	end

  if math_random(100) <= tonumber(prob) then
    local spawn_section = ""
    local sum = 0
    -- Производим рандомную взвешенную выборку
    -- с учетом уже заспавленного количества человек.
    for k,v in pairs(self.respawn_section) do
        sum = sum + v.prob
    end
    sum = math_random(0, sum)
    for k,v in pairs(self.respawn_section) do
        sum = sum - v.prob
        if sum <= 0 then
          spawn_section = v.section
          break
        end
    end

    if spawn_section == "" then
      return false
    end

    local parent_id = nil
    if self.parent ~= nil then
      local s_obj = alife():story_object(self.parent)
      if s_obj == nil then
        abort("SPAWNING [%s], cant find parent with SID [%s]", self:name(), self.parent)
        return
      end
      parent_id = s_obj.id
    end

    local obj
    if parent_id == nil then
      obj = alife():create(spawn_section,
            self.position,
            self.m_level_vertex_id,
            self.m_game_vertex_id)
    else
      obj = alife():create(spawn_section,
            self.position,
            self.m_level_vertex_id,
            self.m_game_vertex_id,
            parent_id)
    end

	amk.on_REspawn(obj,self)

		if self.item_spawn == false then
			if self.sectSpawnProps[spawn_section].check == true and not self.amk_name then
				obj:brain():update()
				if obj:smart_terrain_id() == 65535 then
					alife():release(obj, true)
					return false
				end
			end
		end
		self.spawned_obj[#self.spawned_obj + 1] = obj.id
		return true
	end
	return false
end
-- Попытка спаунить объекты. Анализируется сколько уже заспавнено и выбирается один из механизмов - либо
-- мы доспавниваем до минимального количества, либо спавним с заданной вероятностью
function se_respawn:spawn()
	if not self.spawn_once then
		-- Пробегаемся по списку уже заспавненных объектов и удаляем из них мертвые либо уничтоженные.
		for k,v in pairs(self.spawned_obj) do
			local obj = level.object_by_id(v)
			if obj == nil then
			  obj = alife():object(v)
			end

			if obj ~= nil then
			  if (IsStalker(obj) or IsMonster(obj)) and obj:alive() ~= true then
				table_remove(self.spawned_obj, k)
			  end
			else
			  table_remove(self.spawned_obj, k)
			end
		end
	end
  if xr_logic.pick_section_from_condlist(db.actor_proxy, self, self.conditions) == "0" then
    return
  end

	if self.spawn_once and not self.already_once_spawned then
		self.already_once_spawned = true
	end
  -- экстренный спаун минимального количества объектов
  if #self.spawned_obj < self.min_count then
    while #self.spawned_obj < self.min_count do
      if self:create(100) == false then
        return
      end
    end
    return
  end

  -- делаем несколько попыток заспаунить объект.
  for i=1,self.max_spawn do
    if self.max_count ~= -1 and #self.spawned_obj >= self.max_count then
      return
    end
    if self:create(xr_logic.pick_section_from_condlist(db.actor_proxy, self, self.conditions)) == false then
      return
    end
  end
end
--' Удаляем уже заспавненный объект из списка заспавненных
--' Используется только  для ящиком со шмотками в смарттеррейнах
function se_respawn:remove_spawned(id)
  for k,v in pairs(self.spawned_obj) do
    if id == v then
      table_remove(self.spawned_obj, k)
    end
  end
end
function se_respawn:set_respawn_time()
	local idle_time = game.CTime()
	idle_time:setHMSms(math_random(12, 24), 0, math_random(self.idle_spawn_min, self.idle_spawn_max), 0)
	self.respawn_time = game.get_game_time() + idle_time
end
-- Обновление респавнера. В зависимости от настроек обновляется либо только в офлайне, либо и там и там.
function se_respawn:execute()
	if self.already_once_spawned==true then return end
  --' Выходим, если у нас установлен событийный спавн.
  if self.idle_spawn_min == -1 then
    return
  end

	if self.respawn_time < game.get_game_time() then
		if self.respawn_time == smart_terrain_CTime_0 then
			self:set_respawn_time()
		else
			self.respawn_time = smart_terrain_CTime_0
			-- Производим попытку заспаунить объекты
			self:spawn()
		end
	end
end
-- Обновление в офлайне
function se_respawn:update()
  cse_alife_smart_zone.update( self )

  self:execute()
end
-- Обновление в онлайне
function se_respawn:update_online()
	if self.respawn_radius == -1 then
		return
	end
	if db.actor:position():distance_to (self.position) >= self.respawn_radius then
		self:execute()
	end
end

function spawn(name)
  local spawner = respawners[name]
  if spawner == nil then
    return
  end

  for i=1,spawner.max_spawn do
    if spawner.max_count ~= -1 and #spawner.spawned_obj >= spawner.max_count then
      return
    end
    if spawner:create(xr_logic.pick_section_from_condlist(db.actor_proxy, spawner, spawner.conditions)) == false then
      return
    end
  end
end

function get_respawner_by_parent(parent_id)
  return respawners_by_parent[parent_id]
end

function create_ammo(section, position, lvi, gvi, pid, num)
	local num_in_box = read_line(section, "box_size")
	local sim = alife()

	while num > num_in_box do
		sim:create_ammo(section, position, lvi, gvi, pid, num_in_box)
		num = num - num_in_box
	end
	if num > 0 then
		sim:create_ammo(section, position, lvi, gvi, pid, num)
	end
end

function reinit_spawner_params(name, reset)
	if amk_respawner_control[name] then
		init_respawn_params(amk_respawner_control[name], reset)
	end
end

function get_respawner_by_name(name)
	if amk_named_respawner_control[name] then
		return alife():object(amk_named_respawner_control[name].id)
	end
end
