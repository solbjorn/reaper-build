--[[
Изменения script_version:
	4 - сохранение поля job_online
	5 - сохранение поля was_in_smart_terrain

	modyfied by xStream
]]

local levels_types = {
	l01_escape	= true,
	l02_garbage	= true,
	l03_agroprom	= true,
	l04_darkvalley	= true,
	l06_rostok	= true,
	l07_military	= true,
	l08_yantar	= true,
	l10_radar	= true,
	l11_pripyat	= true,
	l12_stancia	= true,
	l12_stancia_2	= true
}

need_be_online = { }

local clsid_psy_dog_phantom_s
local spot

function init_spot()
	clsid_psy_dog_phantom_s = clsid.psy_dog_phantom_s

	spot = has_info("have_kontroler_spot") or
	       has_info("have_bloodsucker_spot") or
	       has_info("have_pseudo_gigant_spot")
end

--------------------
class "se_monster" (cse_alife_monster_base)
--------------------
function se_monster:__init (section) super (section)
	self.ini = nil
	self.ini_initialized = false

	self.smart_terrain_conditions = nil
	self.smart_terrain_conditions_initialized = false

	self.min_distance_sqr = 3600
	self.day_night_switch = nil

	-- этот флаг берётся из работы смарта
	-- true     = всегда в онлайне
	-- false    = всегда в офлайне
	-- condlist = условие, которое отпределяет true или false
	-- nil      = смарту всё равно
	self.job_online          = nil
	self.job_online_condlist = nil

	-- посещал ли сталкер хоть один smart_terrain
	self.was_in_smart_terrain = false

	self.day_begin=-1
	self.day_end=-1

	self.spawner = nil

	self.state = nil
end
--------------------
function se_monster:get_ini()
	if not self.ini_initialized then
		local self_ini = self:spawn_ini()
		self.ini = self_ini
		self.ini_initialized = true

		if self_ini and self_ini:section_exist ("spawner") then
			if self_ini:line_exist("spawner", "min_distance") then
				local min_distance = self_ini:r_u32_ex("spawner", "min_distance", 100)
				self.min_distance_sqr = min_distance * min_distance
			end
			if self_ini:line_exist("spawner", "day_night_switch") then
				self.day_night_switch = self_ini:r_bool("spawner", "day_night_switch")
			end
			if self_ini:line_exist("spawner", "cond") then
				self.spawner = xr_logic.parse_condlist(self_ini:r_string("spawner", "cond"))
				self.spawner = reap_misc.cached_condlist(self.spawner, 1000)
			end
		end

		local sect = self:section_name()
		self.day_begin = config:r_float_cache(sect, "DayTime_Begin", -1)
		self.day_end = config:r_float_cache(sect, "DayTime_End", -1)

		if self.day_begin == -1 or self.day_end == -1 then
			self.day_night_switch = false
		end
	end
end
--------------------
function se_monster:get_job_online()
	if self.job_online_condlist == nil then
		return self.job_online
	else
		return self.job_online:pick_section_from_condlist(self) ~= nil
	end
end
--------------------
function se_monster:can_switch_offline ()
	local gj = self:get_job_online()
	if gj == false then
		return true
	else
		return cse_alife_monster_base.can_switch_offline (self)
	end
end
--------------------
function se_monster:can_switch_online()
	local r
	if need_be_online[self.id] ~= nil then
		r = need_be_online[self.id]
		need_be_online[self.id] = nil
		self.state = r
		return r
	end

	r = self:get_job_online()
	if r == false then
		self.state = false
		return false
	end

	if self:clsid() == clsid_psy_dog_phantom_s then
		r = cse_alife_monster_base.can_switch_online(self)
		self.state = r
		return r
	end

	-- если игрока нет, то в оффлайн
	if not Actor then
		self.state = false
		return false
	end

	-- Если в custom_data зверушки есть cond в секции [spawner], то это условие должно иметь приоритет.
	if self.spawner ~= nil then
		r = self.spawner:pick_section_from_condlist(self) ~= nil and
		    cse_alife_monster_base.can_switch_online(self)
		self.state = r
		return r
	end

	local level_name = object_level_name(self)

	local day_night_switch = self.day_night_switch
	if day_night_switch == nil then
		day_night_switch = levels_types[level_name]
	end

	--если "ночь" - остаемся в офф
	if day_night_switch and not is_creature_day(self) then
		if self.online then
			local obj = level_object(self.id)
			if ( obj ~= nil and Actor:see(obj) ) then
				self.state = true
				return true
			end
		end
		self.state = false
		return false
	end

	--если задана дистанция проверки, то проверим.
	r = cse_alife_monster_base.can_switch_online(self)
	if r then
		if level_name == curr_level and not self.online then
			if screen.cam_pos:distance_to_sqr(self.position) < self.min_distance_sqr then
				r = screen.cam_dir:dotproduct( self.position:sub(screen.cam_pos) ) < 0
			end
		end
	end
	self.state = r
	return r
end
--------------------
function se_monster:STATE_Write(packet)
	cse_alife_monster_base.STATE_Write (self, packet)

	local st = 0
	if self.state == true then
		st=4
	end

	if self.job_online == true then
		packet:w_u8(0+st)
	elseif self.job_online == false then
		packet:w_u8(1+st)
	elseif self.job_online == nil then
		packet:w_u8(2+st)
	else
		packet:w_u8(3+st)
		packet:w_stringZ(self.job_online_condlist)
	end

	packet:w_bool(self.was_in_smart_terrain)
end
--------------------
function se_monster:STATE_Read(packet, size)
	cse_alife_monster_base.STATE_Read (self, packet, size)

	local t = packet:r_u8()

	if t>=4 then
		need_be_online[self.id]=true
		t = t - 4
	end

	if t == 0 then
		self.job_online = true
	elseif t == 1 then
		self.job_online = false
	elseif t == 2 then
		self.job_online = nil
	else
		self.job_online_condlist = packet:r_stringZ()
		self.job_online = xr_logic.parse_condlist(self.job_online_condlist)
		self.job_online = reap_misc.cached_condlist(self.job_online, 1000)
	end

	self.was_in_smart_terrain = packet:r_bool()
end
--------------------
function se_monster:on_before_register()
	self:fill_exclusives()
end
--------------------
function se_monster:on_register()
	-- Чистим рестрикторы
	local tbl=amk.read_monster_params(self)
	tbl.crvu32u16u2={}
	amk.write_monster_params(tbl,self)

	cse_alife_monster_base.on_register( self )

	-- dsh: Принудительно установим мобам flInteractive
	-- Есть подозрение, что те, у кого этот флаг сброшен, а таких полно в all.spawn, не обходят аномалии.
	g_alife:set_interactive( self, true )

	--' Нарисовать мапспот с собой
	if spot == nil then
		init_spot()
	end
	if spot == true and self:alive() then
		local community = xr_statistic.monster_classes[self:clsid()]
		if community=="controller" and has_alife_info("have_kontroler_spot")  then
			level.map_add_object_spot(self.id, "kontroler_spot", "контроллер")
		elseif community=="bloodsucker" and has_alife_info("have_bloodsucker_spot")  then
			level.map_add_object_spot(self.id, "bloodsucker_spot", "кровосос")
		elseif community=="pseudo_gigant" and has_alife_info("have_pseudo_gigant_spot")  then
			level.map_add_object_spot(self.id, "pseudo_gigant_spot", "псевдогигант")
		end
	end
end
--------------------
function se_monster:on_unregister()
	cse_alife_monster_base.on_unregister( self )

	--' Убрать мапспот с собой
	if spot == nil then
		init_spot()
	end
	if spot == true then
		local community = xr_statistic.monster_classes[self:clsid()]
		if community=="controller" then
			level.map_remove_object_spot(self.id, "kontroler_spot")
		elseif community=="bloodsucker" then
			level.map_remove_object_spot(self.id, "bloodsucker_spot")
		elseif community=="pseudo_gigant" then
			level.map_remove_object_spot(self.id, "pseudo_gigant_spot")
		end
	end

	smart_terrain.unregister_npc(self)
end
--------------------
function se_monster:on_death(killer)
	cse_alife_monster_base.on_death(self, killer)

	--' Убрать мапспот с собой
	if spot == nil then
		init_spot()
	end
	if spot == true then
		local community = xr_statistic.monster_classes[self:clsid()]
		if community=="controller" then
			level.map_remove_object_spot(self.id, "kontroler_spot")
		elseif community=="bloodsucker" then
			level.map_remove_object_spot(self.id, "bloodsucker_spot")
		elseif community=="pseudo_gigant" then
			level.map_remove_object_spot(self.id, "pseudo_gigant_spot")
		end
	end
end
--------------------
function se_monster:fill_exclusives()
	self:get_ini()
	self.smart_terrain_conditions             = smart_terrain.read_smart_terrain_conditions( self )

	if self.smart_terrain_conditions then
		for name, condlist in pairs(self.smart_terrain_conditions) do
			smart_terrain.exclusives[name] = (smart_terrain.exclusives[name] or 0) + 1
		end
	end
end
--------------------
function is_creature_day(obj)
	--проверка на дневной/ночной режим
	local hrs = level.get_time_hours()
	local de = obj.day_end
	if obj.day_begin > de then
		hrs = hrs+24
		de = de+24
	end
	return hrs >= obj.day_begin and hrs < de
end
