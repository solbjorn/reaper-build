--[[------------------------------------------------------------------------------------------------
Space restrictor binder
Чугай Александр

Примечания:
  - обновлений у рестрикторов нету, поэтому для тех, кому надо, актёр вызывает искусственно на своём обновлении
--------------------------------------------------------------------------------------------------]]
local removed_names = {
	['gar_vagon_in_restrictor'] = true,
	['bar_restrictor'] = true,
	['rostok_sniper_killer_restrictor'] = true,
	['agr_u_bloodsucker_rest'] = true,

	esc_tutorial_zone				= true,
	esc_anomaly_tips_zone				= true,
	trader_zone					= true,
	bar_no_weapon_zone				= true,
	yan_no_weapon_restr				= true,
	aes2_space_restrictor_no_weapon			= true,

	val_trader_tip_zone				= true,
	mil_sr_sleep_1					= true,
	rad_sleep_room					= true,
	pri_wave3_followers_btr_phrase1_sound_zone	= true,
	aes_space_restrictor_sound_0054			= true,
	aes2_space_restrictor_zombies			= true
}

local updatable_binders = {}    -- биндеры, которые требуют обновлений (update)

function actor_update(delta)
  for i, v in pairs(updatable_binders) do
    v:actor_update(delta)
  end
end

function bind( obj )
	if removed_names[obj:name()] then
		release(obj)
		return
	end

  obj:bind_object( restrictor_binder( obj ) )
end

----------------------------------------------------------------------------------------------------
class "restrictor_binder" ( object_binder )

function restrictor_binder:__init(obj, char_ini) super(obj)
  self.initialized = false
  self.loaded = false
end

function restrictor_binder:reload(section)
  object_binder.reload(self, section)
end

function restrictor_binder:reinit()
	object_binder.reinit(self)

	self.st = { }
	db.storage[self.object:id()] = self.st
end

function restrictor_binder:net_spawn(data)
  if not object_binder.net_spawn( self,data ) then
    return false
  end

  db.add_zone( self.object )

  -- Не регистрироваться на апдейты, если у объекта в customdata
  -- нет секции logic вообще.
	local ini = self.object:spawn_ini()
	if ini and xr_logic.logic_not_empty(self.object, ini) then
		updatable_binders[self.object:id()] = self
	end

  return true
end

function restrictor_binder:net_destroy()
  local st = db.storage[self.object:id()]
  if st.active_scheme then
    xr_logic.issue_event(self.object, st[st.active_scheme], "net_destroy")
  end

  db.del_zone( self.object )

  updatable_binders[self.object:id()] = nil

  object_binder.net_destroy(self)
end

-- вызывается из обновления актёра!
function restrictor_binder:actor_update(delta)
  if not self.initialized then
    self.initialized = true
		xr_logic.initialize_obj(self.object, self.st, self.loaded, modules.stype_restrictor)
  end

	if self.st.active_section ~= nil then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "update", delta)
	elseif self.object:section() == "space_restrictor" and
	       self.object:name() == "space_restrictor" .. self.object:id() and
	       not self.object:is_story_object() then
		release(self.object)
	else
		updatable_binders[self.object:id()] = nil
	end
end

function restrictor_binder:net_save_relevant()
  return true
end

function restrictor_binder:save(packet)
  object_binder.save(self, packet)

  xr_logic.save_obj(self.object, packet)
end

function restrictor_binder:load(reader)
  self.loaded = true

  object_binder.load(self, reader)

  xr_logic.load_obj(self.object, reader)
end
