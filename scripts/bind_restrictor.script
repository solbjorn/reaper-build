--[[------------------------------------------------------------------------------------------------
Space restrictor binder
Чугай Александр

Примечания:
  - обновлений у рестрикторов нету, поэтому для тех, кому надо, актёр вызывает искусственно на своём обновлении
--------------------------------------------------------------------------------------------------]]

local updatable_binders = {}    -- биндеры, которые требуют обновлений (update)

for i, int in ipairs({ 200, 1000, 5000 }) do
	updatable_binders[int] = {
		binders		= { },
		last		= 0,
		["next"]	= 0
	}
end

function actor_update(delta)
	for int, cont in pairs(updatable_binders) do
		if cont.next <= time_real_ms then
			delta = time_real_ms - cont.last
			cont.last = time_real_ms

			for id, rest in pairs(cont.binders) do
				cont.binders[id] = nil
				rest:actor_update(delta)
			end

			cont.next = time_real_ms + int
		end
	end
end

function bind( obj )
  obj:bind_object( restrictor_binder( obj ) )
end

----------------------------------------------------------------------------------------------------
class "restrictor_binder" ( object_binder )

function restrictor_binder:__init(obj, char_ini) super(obj)
  self.initialized = false
  self.loaded = false
end

function restrictor_binder:reload(section)
  object_binder.reload(self, section)
end

function restrictor_binder:reinit()
	object_binder.reinit(self)

	self.st = { }
	db.storage[self.object:id()] = self.st
end

function restrictor_binder:net_spawn(data)
	if not object_binder.net_spawn(self, data) then
		return false
	end

	local obj = self.object
	db.add_zone(obj)

	-- Не регистрироваться на апдейты, если у объекта в customdata
	-- нет секции logic вообще.
	local ini = obj:spawn_ini()
	if not (ini and xr_logic.logic_not_empty(obj, ini)) then
		return true
	end

	local sect = obj:section()
	if sect == "zone_psy" then
		ogsm_psyzones.register(obj)
	end

	self.removable = sect == "space_restrictor" and
			 obj:name() == "space_restrictor" .. obj:id() and
			 not obj:is_story_object()
	self.radius = obj:get_shape_radius()
	updatable_binders[200].binders[obj:id()] = self

	return true
end

function restrictor_binder:net_destroy()
	local id = self.object:id()
	local st = db.storage[id]
  if st.active_scheme then
    xr_logic.issue_event(self.object, st[st.active_scheme], "net_destroy")
  end

	if self.object:section() == "zone_psy" then
		ogsm_psyzones.unregister(self.object)
	end

  db.del_zone( self.object )

	for int, cont in pairs(updatable_binders) do
		cont.binders[id] = nil
	end

  object_binder.net_destroy(self)
end

-- вызывается из обновления актёра!
function restrictor_binder:actor_update(delta)
  if not self.initialized then
    self.initialized = true
		xr_logic.initialize_obj(self.object, self.st, self.loaded, modules.stype_restrictor)
  end

	if self.st.active_section == nil then
		if self.removable then
			release(self.object)
		end
		return
	end

	xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "update", delta)

	local dist = self.object:position():distance_to(Actor:position()) - self.radius
	if dist < 0 then dist = 0 end

	local tbl = (dist < 25 and 200) or (dist < 100 and 1000) or 5000
	updatable_binders[tbl].binders[self.object:id()] = self

	return true
end

function restrictor_binder:net_save_relevant()
  return true
end

function restrictor_binder:save(packet)
  object_binder.save(self, packet)

  xr_logic.save_obj(self.object, packet)
end

function restrictor_binder:load(reader)
  self.loaded = true

  object_binder.load(self, reader)

  xr_logic.load_obj(self.object, reader)
end
