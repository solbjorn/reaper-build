----------------------------------------------------------------------------------------------------
-- Script switching logic
----------------------------------------------------------------------------------------------------
-- Разработчик: Andrey Fidrya (Zmey) af@svitonline.com
----------------------------------------------------------------------------------------------------

local string_find = string.find
local string_sub  = string.sub
local string_gfind = string.gfind
local string_gsub = string.gsub
local string_len  = string.len
local string_match = string.match

local utils_w_CTime = utils.w_CTime
local utils_r_CTime = utils.r_CTime

local db_storage = db.storage

--[[

----------------------------------------------------------------------------------------------------
-- ФУНКЦИИ, КОТОРЫЕ РАЗРЕШЕНО ВЫЗЫВАТЬ ИЗ ДРУГИХ СКРИПТОВ
----------------------------------------------------------------------------------------------------
  Активация схем производится с помощью функций:

function gulag_activate(npc, ini, section, gulag_name, death, combat, actor_dialogs, trade, hit)
Предназначение:
  активирует заданную схему, используется схемой гулаг. Тип скрипта определяется автоматически по имени секции.
Здесь:
  npc - персонаж, для которого будет активирована схема
  ini - его customdata
  section - имя секции, которая должна быть активирована
  gulag_name - имя гулага, которое будет добавлено спереди к именам путей
  death, combat, actor_dialogs, trade, hit - имена секций, задающих поведение при смерти и в бою

function assign_storage_and_bind(npc, ini, scheme, section)
Предназначение:
  Вызывает функцию add_to_binder схемы, а также создает (если его еще нет) и возвращает ссылку на storage
  для схемы. Примечание: в storage при этом могут оставаться старые данные, схема должна очистить его
  самостоятельно.

function subscribe_action_for_events(npc, storage, new_action)
Предназначение:
  Регистрирует класс для получения нотификаций о таких событиях как сброс схемы, сохранение и т.д.
  Класс реализует соответствующие функции (reset_scheme() и т.д.), которые будут вызываться из xr_logic
  в нужные моменты.

function pick_section_from_condlist(actor, npc, condlist)
Предназначение:
  Проверяет условия condlist, и если они успешны - ставит указанные infoportions и возвращает текст.
  Если условия не выполняются - возвращает nil.

function try_switch_to_another_section(npc, st, actor)
Предназчанение:
  Используя настройки xr_logic из storage персонажа, пытается переключить его на другую схему, если
  хоть одно из условий переключения сработало. Обычно вызывается из метода update класса персонажа.

function is_active(npc, st)
Предназначение:
  Вызывается из evaluator-а (или в самом начале update у предметов и монстров) для проверки, что данная
  схема сейчас активна (схема определяется по данным в storage).

function cfg_get_switch_conditions(ini, section, npc)
Предназначение:
  Считывает все возможные условия переключения схем.

function parse_condlist(npc, section, field, src)
Предназначение:
  Распарсивает условия вида: {+infop1} section1 %-infop2%, {+infop3 -infop4} section2 ... в таблицу.
  Параметры section и field используются только в сообщениях об ошибках. Если строка src считана не из файла,
  а передается в эту функцию гулагом, то нужно задать следующие параметры:
--]]
--    section = "[[[gulag_tasks.script]]]"
--    field = "[[[gulag_name=имя_гулага]]]"
--[[
----------------------------------------------------------------------------------------------------
-- ПРИВАТНЫЕ ФУНКЦИИ
----------------------------------------------------------------------------------------------------

function activate_by_section(npc, ini, section, loading)
Предназначение:
  Активирует указанную секцию. Если в данный момент какая-либо секция уже активирована, сообщает об ошибке.

function switch_to_section(npc, st, section)
Предназначение:
  Выполняет переключение с одной секции на другую, если новая секция не nil. Если же она nil, остается
  активной старая секция.

function abort_syntax_error_in_cond(npc, section, field)
Предназначение:
  Сообщает о синтаксической ошибке в условиях переключения схем секции section и поля field, и останавливает
  игру.

function parse_infop(rslt, str)
Предназначение:
  Распарсивает условия вида " +infop1 =func -infop2 " и т.д. (все не перечислены) в таблицу.

function cfg_get_number_and_condlist(ini, section, field, npc)
function cfg_get_string_and_condlist(ini, section, field, npc)
function cfg_get_condlist(ini, section, field, npc)
Предназначение:
  Считывает из customdata различные условия переключения схем.

function add_condition(lst, at, cond)
Предназначение:
  Добавляет условие в список условий переключения схем.

function cfg_get_overrides(ini, section, npc)
Предназначение:
  Считывает настройки для схем общего поведения.

function generic_scheme_overrides(npc)
Предназначение:
  Возвращает ссылку на настройки схем общего поведения, актуальные для работающей в данный момент схемы,
  либо nil, если ни одна из секций не активна, либо настройки не заданы.

--]]

--[[
-- Предназначение:
--      вызывается при включении набора скриптов через секцию logic у персонажа. Если в секции logic присутствует только
--      поле cfg, использует конфигурационный файл, заданный в этом поле, и возвращает новый ini file.
-- Здесь:
--  npc - персонаж, для которого будет активирована схема
--  ini - его customdata
--  stype - тип скрипта. Поскольку имя секции все еще неизвестно, его нужно задавать явно. Допустимые значения
--          перечислены в файле modules.script.
--  section - имя секции logic
--  gulag_name - имя гулага, если скрипт включается гулагом, а не биндером
--]]
function configure_schemes(npc, ini, ini_filename, stype, section_logic, gulag_name)
  local st     = db_storage[npc:id()]

  -- если какая-то схема была до этого активна, деактивировать её
  if st.active_section then
    issue_event(npc, st[st.active_scheme], "deactivate", npc)
  end

  local actual_ini
  if not ini:section_exist(section_logic) then
    if not gulag_name then
      -- Общие схемы должны работать и без logic:
      actual_ini = ini -- персонаж не обязательно должен иметь секцию logic
    else
      -- Иначе это персонаж Gulag-а и ему не задали работу:
      abort("ERROR: object '%s': unable to find section '%s'", npc:name(), section_logic)
    end
  else
    local filename = utils.cfg_get_string(ini, section_logic, "cfg", npc, false, "")
    if filename then
      -- Рекурсивно обработать конфигурационный файл, на который ссылается поле cfg
      actual_ini = ini_file(filename)
      return configure_schemes(npc, actual_ini, filename, stype, section_logic, gulag_name)
    else
      actual_ini = ini
    end
  end

  -- Поскольку в момент активации схемы могли работать ранее установленные общие схемы, нужно их все отключить:
  disable_generic_schemes(npc, stype)
  -- Включаем все общие схемы (раненный, коллбек на попадание и т.д.):
  enable_generic_schemes(actual_ini, npc, stype, section_logic)

  -- Инициализация торговли
  if stype == modules.stype_stalker or
     npc:clsid() == clsid_script_trader
  then
		if actual_ini:section_exist(section_logic) and actual_ini:line_exist(section_logic, "trade") then
			trade_manager.trade_init(npc, actual_ini:r_string(section_logic, "trade"))
		else
			trade_manager.trade_init(npc, nil)
		end
  end

  st.active_section = nil
  st.active_scheme = nil
  if gulag_name then
    st.gulag_name = gulag_name
  else
    st.gulag_name = ""
  end
  st.stype = stype
  st.ini = actual_ini
  st.ini_filename = ini_filename
  st.section_logic = section_logic

  return st.ini
end

-- Вызывается биндером с целью определить первую активную схему
function determine_section_to_activate(npc, ini, section_logic)
  if not ini:section_exist(section_logic) then
    return "nil"
  end

	-- Распарсить строку выбора активной секции с учетом команд, заключенных в %%
	local active_section_cond = cfg_get_condlist(ini, section_logic, "active", npc) or
				cfg_get_condlist(ini, section_logic, "selective", npc)
	local active_section
	if not active_section_cond then
		abort("object '%s': section '%s': no 'active' or 'selective'", npc:name(), section_logic)
	else
		active_section = pick_section_from_condlist(db_actor, npc, active_section_cond.condlist)
		if not active_section then
			abort("object '%s': section '%s': field 'active'/'selective' has no conditionless else clause",
				npc:name(), section_logic)
		end
	end

	local npc_id = npc:id()
  if active_section and db_storage[npc_id].stype and db_storage[npc_id].stype<=1 and db_storage[npc_id].stype~=stypes[utils.get_scheme_by_section(active_section)] then
  -- Блокируем активацию схемы для зверушек в человеческих гулагах. Dirty Hack.
    return "nil"
  else
  return active_section
  end
end

------------------------------------------------------------------------------------------------------------
-- ВНОСЯ ИЗМЕНЕНИЯ В ЭТУ ФУНКЦИЮ, НЕ ЗАБЫВАЙТЕ ДОБАВЛЯТЬ СООТВЕТСТВУЮЩИЕ СТРОКИ И В enable_generic_schemes
------------------------------------------------------------------------------------------------------------
function disable_generic_schemes(npc, stype)
  if stype == modules.stype_stalker then
    xr_combat.disable_scheme(npc, "combat")
	xr_punch_tm.disable_scheme(npc, "punch_tm")
	xrs_ai.disable_schemes(npc, stype)
    xr_use.disable_scheme(npc, "use")
    xr_hit.disable_scheme(npc, "hit")
    xr_meet.disable_scheme(npc, "actor_dialogs")
    xr_heli_hunter.disable_scheme(npc, "heli_hunter")
    xr_combat_ignore.disable_scheme(npc, "combat_ignore")
  elseif stype == modules.stype_mobile then
    mob_combat.disable_scheme(npc, "mob_combat")
    mob_trade.disable_scheme(npc, "mob_trade")
  elseif stype == modules.stype_item then
    ph_on_hit.disable_scheme(npc, "ph_on_hit")
  elseif stype == modules.stype_heli then
    xr_hit.disable_scheme(npc, "hit")
  end
end

------------------------------------------------------------------------------------------------------------
-- ВНОСЯ ИЗМЕНЕНИЯ В ЭТУ ФУНКЦИЮ, НЕ ЗАБЫВАЙТЕ ДОБАВЛЯТЬ СООТВЕТСТВУЮЩИЕ СТРОКИ И В disable_generic_schemes
------------------------------------------------------------------------------------------------------------
function enable_generic_schemes(ini, npc, stype, section)
	if stype == modules.stype_stalker then
		blowout_scheme.set_hide(npc, ini, "blowout_scheme", section)

    xr_danger.set_danger(npc, ini, "danger", "danger")

    local combat_section = utils.cfg_get_string(ini, section, "on_combat", npc, false, "")
    xr_combat.set_combat_checker(npc, ini, "combat", combat_section)

    local use_section = utils.cfg_get_string(ini, section, "on_use", npc, false, "")
    if use_section then
      xr_use.set_use_checker(npc, ini, "use", use_section)
    end
    local info_section = utils.cfg_get_string(ini, section, "info", npc, false, "")
    if info_section then
      stalker_generic.set_npc_info(npc, ini, "info", info_section)
    end

    local hit_section = utils.cfg_get_string(ini, section, "on_hit", npc, false, "")
    if hit_section then
      xr_hit.set_hit_checker(npc, ini, "hit", hit_section)
    end

    local actor_dialogs_section = utils.cfg_get_string (ini, section, "actor_dialogs", npc, false, "")
    if actor_dialogs_section then
      xr_meet.set_actor_dialogs(npc, ini, "actor_dialogs", actor_dialogs_section)
    end

    local wounded_section = utils.cfg_get_string (ini, section, "wounded", npc, false, "")
    xr_wounded.set_wounded (npc, ini, "wounded", wounded_section)

    xr_abuse.set_abuse(npc, ini, "abuse", section)

    local meet_section = utils.cfg_get_string (ini, section, "meet", npc, false, "")
    xr_meet.set_meet (npc, ini, "meet", meet_section)

    local death_section = utils.cfg_get_string (ini, section, "on_death", npc, false, "")
    xr_death.set_death (npc, ini, "death", death_section)

    local heli_hunter_section = utils.cfg_get_string(ini, section, "heli_hunter", npc, false, "")
    xr_heli_hunter.set_scheme(npc, ini, "heli_hunter", heli_hunter_section)

    local combat_ignore_section = utils.cfg_get_string(ini, section, "combat_ignore", npc, false, "")
    if combat_ignore_section then
      xr_combat_ignore.set_combat_ignore_checker(npc, ini, "combat_ignore", combat_ignore_section)
    end

		watcher_act.set_scheme(npc, ini, "watcher_act", "watcher_act")
		xr_punch_tm.set_scheme(npc, nil, "punch_tm")
		xrs_ai.enable_schemes(ini, npc, stype, section)
	elseif stype == modules.stype_mobile then
    local combat_section = utils.cfg_get_string(ini, section, "on_combat", npc, false, "")
    if combat_section then
      mob_combat.set_scheme(npc, ini, "mob_combat", combat_section)
    end

    local death_section = utils.cfg_get_string(ini, section, "on_death", npc, false, "")
    mob_death.set_scheme(npc, ini, "mob_death", death_section)

    local trade_section = utils.cfg_get_string(ini, section, "on_trade", npc, false, "")
    if trade_section then
      mob_trade.set_scheme(npc, ini, "mob_trade", trade_section)
    end

    local hit_section = utils.cfg_get_string(ini, section, "on_hit", npc, false, "")
    if hit_section then
      xr_hit.set_hit_checker(npc, ini, "hit", hit_section)
    end

    mob_panic.set_scheme(npc, ini, "mob_panic")
	elseif stype == modules.stype_item then
    local hit_section = utils.cfg_get_string(ini, section, "on_hit", npc, false, "")
    if hit_section then
      ph_on_hit.set_scheme(npc, ini, "ph_on_hit", hit_section)
    end
	elseif stype == modules.stype_heli then
    local hit_section = utils.cfg_get_string(ini, section, "on_hit", npc, false, "")
    if hit_section then
      xr_hit.set_hit_checker(npc, ini, "hit", hit_section)
    end
	end
end

function activate_by_section(npc, ini, section, loading)
  if loading == nil then
    abort("xr_logic: activate_by_section: loading field is nil, true or false expected")
  end

  local npc_storage = db_storage[npc:id()]
  if npc_storage.active_section then
    abort("xr_logic: activate_by_section: while processing section '%s': character '%s': trying to " ..
      "activate more than one schemes at once (section '%s' is active)",
      section, npc:name(), npc_storage.active_section)
  end

  if not loading then
    npc_storage.activation_time = time_global()
    -- GAMETIME added by Stohe.
    npc_storage.activation_game_time = game.get_game_time()
  end

  if section == "nil" then
    npc_storage.overrides = nil
    reset_generic_schemes_on_scheme_switch(npc, "nil", "nil")
    npc_storage.active_section = nil
    npc_storage.active_scheme = nil
    return
  end

  if ini:section_exist(section) then
		local scheme = string_gsub(section, "%d", "")
		local at, to = string_find(scheme, "@", 1, true)
		if at and to then
			scheme = string_sub(scheme, 1, at - 1)
		end
		if scheme == nil then
			abort("object '%s': unable to determine scheme name from section name '%s'", npc:name(), section)
			return
		end

    -- Загрузить оверрайды:
    npc_storage.overrides = cfg_get_overrides(ini, section, npc)

    -- Сбросить общие схемы:
    reset_generic_schemes_on_scheme_switch(npc, scheme, section)

    -- schemes[scheme] даст имя файла (модуля), в котором реализована схема
    -- _G[] даст указатель на неймспейс (таблицу) этого модуля
		_G[schemes[scheme]].set_scheme(npc, ini, scheme, section, npc_storage["gulag_name"])
    npc_storage.active_section = section
    npc_storage.active_scheme = scheme

    if npc_storage.stype == modules.stype_stalker then
      -- чтобы избежать дальнейшего движения по пути при установке рестрикторов
      utils.send_to_nearest_accessible_vertex(npc, npc:level_vertex_id())

      issue_event(npc, npc_storage[scheme], "activate_scheme", loading, npc)
    else
      issue_event(npc, npc_storage[scheme], "reset_scheme", loading, npc)
    end
  else
    abort("object '%s': activate_by_section: section '%s' does not exist",
      npc:name(), section)
  end
end

--[[
-- Предназначение:
--  Производит сброс состояния объекта (снимает коллбеки, отключает разговор) непосредственно перед включением
--  новой схемы.
--]]
function reset_generic_schemes_on_scheme_switch(npc, scheme, section)
  local st = db_storage[npc:id()]
	local stype = st.stype

  if not stype then
    return
  end

  if stype == modules.stype_stalker then
    xr_meet.reset_meet(npc, scheme, st, section)
    xr_abuse.reset_abuse(npc, scheme, st, section)
    xr_wounded.reset_wounded(npc, scheme, st, section)
    xr_death.reset_death(npc, scheme, st, section)
    xr_danger.reset_danger(npc, scheme, st, section)
    stalker_generic.reset_threshold(npc, scheme, st, section)
    stalker_generic.reset_show_spot(npc, scheme, st, section)
  elseif stype == modules.stype_mobile then
    xr_meet.dialog_manager_reset(npc, stype)
    mob_release(npc)
    if npc:clsid() == clsid_bloodsucker_s then
      if scheme == "nil" then
        npc:set_manual_invisibility(false)
      else
        npc:set_manual_invisibility(true)
      end
    end

    mob_panic.reset_panic(npc, scheme, st, section)
  elseif stype == modules.stype_item then
		if st.ph_door == nil and st.ph_button == nil then
			npc:set_callback(callback.use_object, nil)
		end
    npc:set_nonscript_usable(true)
    if npc:clsid() == clsid_car then
      -- Другие объекты под скрипт не берутся, поэтому для них не надо сбрасывать
      npc:destroy_car()
      mob_release(npc)
    end
  end
end

function assign_storage_and_bind(npc, ini, scheme, section)
	local npc_storage = db_storage[npc:id()]
	local st

  if not npc_storage[scheme] then
		st = {
			["npc"] = npc,
			["scheme"] = scheme,
			["section"] = section,
			["ini"] = ini,
			["actions"] = {}
		}
		npc_storage[scheme] = st

    -- Схема стартует впервые - прибиндить

		if _G[schemes[scheme]].add_to_binder_q then
			_G[schemes[scheme]].add_to_binder_q(npc, st)
		else
			_G[schemes[scheme]].add_to_binder(npc, ini, scheme, section, st)
		end
  else
    st = npc_storage[scheme]
		st.scheme = scheme
		st.section = section
		st.ini = ini
  end

  return st
end

function subscribe_action_for_events(npc, storage, new_action)
  if not storage.actions then
    storage.actions = {}
  end

  storage.actions[new_action] = true
end

function unsubscribe_action_from_events(npc, storage, new_action)
  if not storage.actions then
    return
  end

  storage.actions[new_action] = nil
end

-- st - storage активной схемы
function issue_event(npc, st, event_fn, ...)
  if not st or not st.actions then
    return
  end

  for action_ptr, is_active in pairs(st.actions) do
    if is_active and action_ptr[event_fn] then
      action_ptr[event_fn](action_ptr, ...)
    end
  end
end

local math_random = math.random
function pick_section_from_condlist(actor, npc, condlist)
	local rval = nil

	local infop_conditions_met, cond, infop
	for n = 1, #condlist do
		cond = condlist[n]
		infop_conditions_met = true -- изначально считаем, что все условия переключения удовлетворены
		for inum = 1, #cond.infop_check do
			infop = cond.infop_check[inum]
      if infop.prob then
        if not rval then
          rval = math_random(100)
        end
        if infop.prob < rval then
          infop_conditions_met = false -- инфопоршен есть, но он не должен присутствовать
          break
        end
      elseif infop.func then
        if not xr_conditions[infop.func] then
          abort("object '%s': pick_section_from_condlist: function '%s' is " ..
            "not defined in xr_conditions.script", npc:name(), infop.func)
        end
        if infop.params then
          if xr_conditions[infop.func](actor, npc, infop.params) then
            if not infop.expected then
              infop_conditions_met = false -- инфопоршен есть, но не должен присутствовать
              break
            end
          else
            if infop.expected then
              infop_conditions_met = false -- инфопоршен есть, но не должен присутствовать
              break
            end
          end
        else
          if xr_conditions[infop.func](actor, npc) then
            if not infop.expected then
              infop_conditions_met = false -- инфопоршен есть, но не должен присутствовать
              break
            end
          else
            if infop.expected then
              infop_conditions_met = false -- инфопоршен есть, но не должен присутствовать
              break
            end
          end
        end
      elseif has_alife_info(infop.name) then
        if not infop.required then
          infop_conditions_met = false -- инфопоршен есть, но он не должен присутствовать
          break
        end
      else
        if infop.required then
          infop_conditions_met = false -- инфопоршена нет, но он нужен
          break
        end
      end
    end
    if infop_conditions_met then
      -- Условия выполнены. Независимо от того, задана ли секция, нужно проставить требуемые
      -- infoportions:
			local num_infop_set = #cond.infop_set
			if num_infop_set > 0 then
				if db_actor == nil then
					abort("TRYING TO SET INFOS WHEN ACTOR IS NIL")
					return
				end
				for inum = 1, num_infop_set do
					infop = cond.infop_set[inum]
					if infop.func then
						local func = nil
						local module, fname = string_match(infop.func, "(.+)[.](.+)")
						if not fname then
							func = xr_effects[infop.func]
						else
							if _G[module] and _G[module][fname] then
								func = _G[module][fname]
							end
						end
						if not func then
							abort("object '%s': pick_section_from_condlist: function '%s' is " ..
								"not defined in xr_effects.script", if_then_else(npc, npc:name(), "nil"), infop.func)
						end
						if infop.params then
							func(actor, npc, infop.params)
						else
							func(actor, npc)
						end
					elseif infop.required then
						if not has_alife_info(infop.name) then
							db_actor:give_info_portion(infop.name)
						end
					else
						if has_alife_info(infop.name) then
							db_actor:disable_info_portion(infop.name)
						end
					end
				end
			end
			if cond.section == "never" then
				return nil
			else
				return cond.section
			end
		end
	end

	return nil
end

-- Выполняет переключение на указанную секцию, если задана.
-- Если section == nil, остается работать старая секция.
function switch_to_section(npc, st, section)
	if section == nil or section == "" then
		return false
	end
	if section == "sr_aes_deadzone" and has_alife_info("strelok_pda_have") then return false end
	local npc_storage = db_storage[npc:id()]
	local active_section = npc_storage.active_section
  if active_section == section then
    return false
  end

  -- call scheme::finalize()
  if active_section then
    issue_event(npc, npc_storage[npc_storage.active_scheme], "deactivate", npc)
  end

  npc_storage.active_section = nil
  npc_storage.active_scheme = nil
  activate_by_section(npc, st.ini, section, false)
  return true
end

function try_switch_to_another_section(npc, st, actor)
	local l = st.logic
	local string_find_ = string_find
	local function actor_in_zone(zone)
		return zone ~= nil and zone:inside(actor:position())
	end

	if not actor then
		abort("xr_logic.try_switch_to_another_section(): error executing scheme '%s': actor is nil - check bind_stalker.script, db.script", st.scheme)
		return
	end

	if not l then
		abort("Can't find script switching information in storage, scheme '%s'", st.active_scheme)
		return
	end

	local switched = false
	local section = nil
	for n = 1, #l do
		local c = l[n]
		local c_name = c.name
		-- FIXME: не дублировать тут имена, оставить один on_info, но добавлять несколько его экземпляров в список
		if c_name == "on_info" then
			section = pick_section_from_condlist(db_actor, npc, c.condlist)
		elseif c_name == "on_signal" then
			if st.signals and st.signals[c.v1] then
				section = pick_section_from_condlist(db_actor, npc, c.condlist)
			end
		elseif string_find_(c_name, "^on_actor_") then
			if c_name == "on_actor_inside" then
				if actor_in_zone(npc) then
					section = pick_section_from_condlist(db_actor, npc, c.condlist)
				end
			elseif c_name == "on_actor_dist_le" then
				if npc:alive() and npc:see(db_actor) and distance_between(db_actor, npc) <= c.v1 then
					section = pick_section_from_condlist(db_actor, npc, c.condlist)
				end
			elseif c_name == "on_actor_dist_le_nvis" then
				if distance_between(db_actor, npc) <= c.v1 then
					section = pick_section_from_condlist(db_actor, npc, c.condlist)
				end
			elseif c_name == "on_actor_in_zone" then
				if actor_in_zone(db.zone_by_name[c.v1]) then
					section = pick_section_from_condlist(db_actor, npc, c.condlist)
				end
			elseif c_name == "on_actor_outside" then
				if not actor_in_zone(npc) then
					section = pick_section_from_condlist(db_actor, npc, c.condlist)
				end
			elseif c_name == "on_actor_dist_g" then -- 2 in vanilla
				-- ТУТ УМЫШЛЕННО >, А НЕ >=, потому что оно составляет пару с on_actor_dist_le, где <=
				if npc:alive() and npc:see(db_actor) and distance_between(db_actor, npc) > c.v1 then
					section = pick_section_from_condlist(db_actor, npc, c.condlist)
				end
			elseif c_name == "on_actor_dist_ge_nvis" then
				-- ТУТ УМЫШЛЕННО >, А НЕ >=, потому что оно составляет пару с on_actor_dist_le_nvis, где <=
				if distance_between(db_actor, npc) > c.v1 then
					section = pick_section_from_condlist(db_actor, npc, c.condlist)
				end
			elseif c_name == "on_actor_not_in_zone" then
				if not actor_in_zone(db.zone_by_name[c.v1]) then
					section = pick_section_from_condlist(db_actor, npc, c.condlist)
				end
			end
		elseif c_name == "on_timer" then
			if time_global() >= db_storage[npc:id()].activation_time + c.v1 then
				section = pick_section_from_condlist(db_actor, npc, c.condlist)
			end
		-- GAMETIME added by Stohe.
		elseif c_name == "on_game_timer" then
			if  game.get_game_time():diffSec(db_storage[npc:id()].activation_game_time) >= c.v1 then
				section = pick_section_from_condlist(db_actor, npc, c.condlist)
			end
		elseif c_name == "on_npc_in_zone" then
			if utils.npc_in_zone(level.object_by_id(c.npc_id), db.zone_by_name[c.v2]) then
				section = pick_section_from_condlist(db_actor, npc, c.condlist)
			end
		elseif c_name == "on_npc_not_in_zone" then
			if not utils.npc_in_zone(level.object_by_id(c.npc_id), db.zone_by_name[c.v2]) then
				section = pick_section_from_condlist(db_actor, npc, c.condlist)
			end
		else
			abort(
				"WARNING: object '%s': try_switch_to_another_section: unknown condition '%s' encountered",
				npc:name(), c_name)
			return false
		end

		if section then 
			switched = switch_to_section(npc, st, section)
			if switched then
				return true
			end
			section = nil
		end
	end

	return false
end

function is_active(npc, st)
  if st.section == nil then
    abort("npc '%s': st.section is nil, active section is '%s'",
      npc:name(), utils.to_str(db_storage[npc:id()].active_section))
  end

	return (st.section == db_storage[npc:id()].active_section)
end


function abort_syntax_error_in_cond(npc, section, field, func_name)
	abort("xr_logic: object '%s': section '%s': field '%s': syntax error in switch condition in %s()",
		(npc and npc:name()) or "nil", tostring(section), tostring(field), func_name)
end

function parse_infop(rslt, str)
	local infop_name, sign
	local infop_n = 1
	local at, params
	for s in string_gfind(str, "%s*([%-%+%~%=%!][^%-%+%~%=%!%s]+)%s*") do
		sign = string_sub(s, 1, 1)
		infop_name = string_sub(s, 2)
		params = nil

		-- парсим параметры функций
		at = string_find(infop_name, "%(")
		if at then
			if string_sub(infop_name, -1) ~= ")" then
				abort("wrong condlist %s", str)
			end
			if at < string_len(infop_name) - 1 then
				params = {}
				for par in string_gfind(string_sub(infop_name, at + 1, -2), "%s*([^:]+)%s*") do
					params[#params+1] = tonumber(par) or par
				end
			end
			infop_name = string_sub(infop_name, 1, at - 1)
		end

		if sign == "+" then
			rslt[infop_n] = { name = infop_name, required = true }
		elseif sign == "=" then
			rslt[infop_n] = { func = infop_name, expected = true, params = params or {} }
		elseif sign == "-" then
			rslt[infop_n] = { name = infop_name, required = false }
		elseif sign == "!" then
			rslt[infop_n] = { func = infop_name, expected = false, params = params or {} }
		elseif sign == "~" then
			rslt[infop_n] = { prob = tonumber(infop_name) }
		else
			abort_syntax_error_in_cond(nil, section, field, "parse_infop")
			return
		end
		infop_n = infop_n + 1
	end
end

-- Распарсивает строку src вида:
-- {+infop1} section1 %-infop2%, {+infop3 -infop4} section2 ...
-- в таблицу:
-- {
--   1 = { infop_check = { 1 = {"infop1" = true} }, infop_set = { 1 = {"infop2" = false } }, section = "section1" },
--   2 = { infop_check = { 1 = {"infop3" = true}, 2 = {"infop4" = false} }, infop_set = {}, section = "section2" },
-- }
function parse_condlist(npc, section, field, src)
	return parse_condlist_q(src)
end

function parse_condlist_q(src)
	local lst = {}

	-- 1) Разбиваем на разделенные запятыми части:
	-- local at, to, infop_check_lst, remainings, infop_set_lst, newsect
	local at, to, infop_lst, remainings, newsect

	local n = 1
	for fld in string_gfind(src, "%s*([^,]+)%s*") do
		-- Здесь fld это набор infoportions в {} и имя секции, на которую переключиться.
		local infop_check_table = {}
		local infop_set_table = {}

		-- Выделяем список infoportions для проверки:
		at, to, infop_lst = string_find(fld, "{%s*(.*)%s*}")
		if infop_lst then
			-- Выделяем оставшуюся часть поля, т.е. имя секции плюс список infoportions для установки:
			remainings = string_sub(fld, 1, at - 1) .. string_sub(fld, to + 1)
			parse_infop(infop_check_table, infop_lst) -- nv170521 only called if there's info to process
		else
			-- Список infoportions для проверки не был задан, следовательно, ничего не удаляем:
			remainings = fld
		end

		-- Выделяем список infoportions для установки из remainings:
		at, to, infop_lst = string_find(remainings, "%%%s*(.*)%s*%%")
		if infop_lst then
			-- Выделяем оставшуюся часть поля, т.е. имя секции:
			newsect = string_sub(remainings, 1, at - 1) .. string_sub(remainings, to + 1)
			parse_infop(infop_set_table, infop_lst) -- nv170521 only called if there's info to process
		else
			-- Список infoportions для установки не был задан, следовательно, remainings и есть имя секции.
			newsect = remainings
		end

		-- И сразу trim имя секции:
		at, to, newsect = string_find(newsect, "%s*(.*)%s*")
		if not newsect then
			abort_syntax_error_in_cond(npc, section, field, "parse_condlist_q")
		end

		lst[n] = {
			section = newsect,
			infop_check = infop_check_table,
			infop_set = infop_set_table
		}

		n = n + 1
	end

	return lst
end

-- a | b | c  ==>  { 1 = "a", 2 = "b", 3 = "c" }
local function parse_params(params)
	local rslt = {}
	local n = 1
	for fld in string_gfind(params, "%s*([^|]+)%s*") do
		rslt[n] = fld
		n = n + 1
	end
	return rslt
end

function cfg_get_string_and_condlist(ini, section, field, npc)
	if not section or not ini:section_exist(section) then return nil end
	local str = ini:line_exist(section, field) and ini:r_string(section, field)
	if not str then
		return nil
	end

	local par = parse_params(str)
	if not par[1] or not par[2] then
		abort_syntax_error_in_cond(npc, section, field, "cfg_get_string_and_condlist")
	end

	return { name = field, v1 = par[1], condlist = parse_condlist_q(par[2]) }
end

function cfg_get_two_strings_and_condlist(ini, section, field, npc)
	if not section or not ini:section_exist(section) then return nil end
	local str = ini:line_exist(section, field) and ini:r_string(section, field)
	if not str then
		return nil
	end

	local par = parse_params(str)
	if not par[1] or not par[2] or not par[3] then
		abort_syntax_error_in_cond(npc, section, field, "cfg_get_two_strings_and_condlist")
	end

	return { name = field, v1 = par[1], v2 = par[2], condlist = parse_condlist_q(par[3]) }
end

function cfg_get_condlist(ini, section, field, npc)
	if not section or not ini:section_exist(section) then return nil end
	local str = ini:line_exist(section, field) and ini:r_string(section, field)
	if not str then
		return nil
	end

	local par = parse_params(str)
	if not par[1] then
		abort_syntax_error_in_cond(npc, section, field, "cfg_get_condlist")
		return nil
	end

	return { name = field, condlist = parse_condlist_q(par[1]) }
end

local function cfg_get_number_and_condlist_sv(field, field_value)
	local par = parse_params(field_value)
	if not par[1] or not par[2] then
		abort_syntax_error_in_cond(npc, section, field, "cfg_get_number_and_condlist_sv")
	end

	return { name = field, v1 = tonumber(par[1]), condlist = parse_condlist_q(par[2]) }
end

local function cfg_get_string_and_condlist_sv(field, field_value)
	local par = parse_params(field_value)
	if not par[1] or not par[2] then
		abort_syntax_error_in_cond(npc, section, field, "cfg_get_string_and_condlist_sv")
	end

	return { name = field, v1 = par[1], condlist = parse_condlist_q(par[2]) }
end

function cfg_get_condlist_sv(field, field_value)
	local par = parse_params(field_value)
	if not par[1] then
		abort_syntax_error_in_cond(npc, section, field, "cfg_get_condlist_sv")
		return nil
	end

	return { name = field, condlist = parse_condlist_q(par[1]) }
end

function cfg_get_switch_conditions(ini, section, npc)
	local l = {}
	if not section or not ini:section_exist(section) then
		return l
	end

	local n = 1

	local function add_conditions(func, cond)
		local i = 1
		local field_value = ini:line_exist(section, cond) and ini:r_string(section, cond)

		local c = field_value and func(cond, field_value) or nil

		while c ~= nil do
			l[n] = c
			n = n + 1

			i = i + 1
			local new_cond = cond..i
			field_value = ini:line_exist(section, new_cond) and ini:r_string(section, new_cond)
			c = field_value and func(cond, field_value) or nil
		end
	end

	add_conditions( cfg_get_condlist_sv           , "on_info"               )
	add_conditions( cfg_get_string_and_condlist_sv, "on_signal"             )
	add_conditions( cfg_get_condlist_sv           , "on_actor_inside"       )
	add_conditions( cfg_get_number_and_condlist_sv, "on_timer"              )
	add_conditions( cfg_get_number_and_condlist_sv, "on_actor_dist_le"      )
	add_conditions( cfg_get_number_and_condlist_sv, "on_actor_dist_le_nvis" )
	add_conditions( cfg_get_number_and_condlist_sv, "on_actor_dist_ge"      )
	add_conditions( cfg_get_number_and_condlist_sv, "on_actor_dist_ge_nvis" )
	add_conditions( cfg_get_number_and_condlist_sv, "on_game_timer"         )
	add_conditions( cfg_get_string_and_condlist_sv, "on_actor_in_zone"      )
	add_conditions( cfg_get_string_and_condlist_sv, "on_actor_not_in_zone"  )
	add_conditions( cfg_get_condlist_sv           , "on_actor_outside"      )

	if ini:line_exist(section, "on_npc_in_zone") then
		c = cfg_get_npc_and_zone(ini, section, "on_npc_in_zone", npc)
		if c ~= nil then
			l[n] = c
			n = n + 1
		end
	end
	if ini:line_exist(section, "on_npc_not_in_zone") then
		c = cfg_get_npc_and_zone(ini, section, "on_npc_not_in_zone", npc)
		if c ~= nil then
			l[n] = c
			n = n + 1
		end
	end

	return l
end

function cfg_get_overrides(ini, section, npc)
	local function get_field_string(field)
		return (ini:line_exist(section, field) and ini:r_string(section, field)) or nil
	end
	local function cfg_get_condlist_sv_for(field)
		local field_value = (ini:line_exist(section, field) and ini:r_string(section, field)) or nil
		return field_value and cfg_get_condlist_sv(field, field_value)
	end

	local l = nil
	local value
	if string_find(section, "kamp") ~= nil then
		value = get_field_string("center_point")
	else
		value = get_field_string("soundgroup")
	end
	if value then
		l = { soundgroup = value }
	end
	value = cfg_get_condlist_sv_for("combat_ignore_cond")
	if value then
		if not l then
			l = { combat_ignore = value }
		else
			l.combat_ignore = value
		end
	end
	value = (ini:line_exist(section, "combat_ignore_keep_when_attacked") and ini:r_bool(section, "combat_ignore_keep_when_attacked")) or false
	if value then
		if not l then
			l = { combat_ignore_keep_when_attacked = value }
		else
			l.combat_ignore_keep_when_attacked = value
		end
	end
	value = cfg_get_condlist_sv_for("combat_type")
	if value then
		if not l then
			l = { combat_type = value }
		else
			l.combat_type = value
		end
	end
	value = cfg_get_condlist_sv_for("on_combat")
	if value then
		if not l then
			l = { on_combat = value }
		else
			l.on_combat = value
		end
	end
	value = get_field_string("heli_hunter")
	if value then
		if not l then
			l = { heli_hunter = parse_condlist_q(value) }
		else
			l.heli_hunter = parse_condlist_q(value)
		end
	end

	return l
end

function cfg_get_npc_and_zone(ini, section, field, npc)
	local t = cfg_get_two_strings_and_condlist(ini, section, field, npc)

	if t then
		local sim = alife()
		if sim then
			local se_obj = sim:story_object(tonumber(t.v1))
			if se_obj then
				t.npc_id = se_obj.id
			else
				t.npc_id = -1
				abort("object '%s': section '%s': field '%s': there is no object with story_id '%s'",
										npc:name(), section, field, t.v1)
			end
		else
			t.npc_id = -1
		end
	end

	return t
end

-- Возвращает ссылку на оверрайды, зарегистрированные в активной на данный момент секции,
-- либо nil, если ни одна из секций не активна, или оверрайдов нет.
function generic_scheme_overrides(npc)
  return db_storage[npc:id()].overrides
end

function mob_release(mob)
  if mob:get_script() then
    mob:script(false, script_name())
  end
end

function mob_capture(mob, reset_actions)
  if reset_actions == nil then
    abort("mob_capture: reset_actions parameter's value is not specified")
  end

  if reset_actions then
    reset_action(mob, script_name())
  else
    if not mob:get_script() then
      mob:script(true, script_name())
    end
  end
end

function mob_captured(mob)
  return mob:get_script()
end

function save_logic(obj, packet, npc_storage)
	local activation_time = npc_storage.activation_time
	if not activation_time then
		activation_time = 0
	end
	packet:w_s32(activation_time - time_global())

	-- GAMETIME added by Stohe.
	utils_w_CTime(packet, npc_storage.activation_game_time)
end

function load_logic(obj, reader, npc_storage)
	npc_storage.activation_time = reader:r_s32() + time_global()

	-- GAMETIME added by Stohe.
	npc_storage.activation_game_time = utils_r_CTime(reader)
end

local pstor_number = 0
local pstor_string = 1
local pstor_boolean = 2

function pstor_store(obj, varname, val)
	local npc_storage = obj and db_storage[obj:id()]
	if not npc_storage then return end

	local obj_pstor = npc_storage.pstor
	if not obj_pstor then
		obj_pstor = { }
		npc_storage.pstor = obj_pstor
	end

	local tv = type(val) 
	if tv == "string" or tv == "number" or tv == "boolean" then
		obj_pstor[varname] = val
	else
		abort("xr_logic: pstor_store: unregistered type '%s' encountered (corrupted save?)", tv)
	end
end

function pstor_retrieve(obj, varname, defval, del)
	local obj_pstor = obj and db_storage[obj:id()].pstor
	local var = obj_pstor and obj_pstor[varname]

	if not var then return defval end
	if del then obj_pstor[varname] = nil end

	return var
end

function pstor_save_all(obj, packet, npc_storage)
	local pstor = npc_storage.pstor
	if not pstor then
		pstor = {}
		npc_storage.pstor = pstor
	end

	local ctr = 0
	for k, v in pairs(pstor) do
		ctr = ctr + 1
	end
	packet:w_u32(ctr)

	for k, v in pairs(pstor) do
		packet:w_stringZ(k)
		local tv = type(v)
		if tv == "string" then
			packet:w_u8(1) --(pstor_string)
			packet:w_stringZ(v)
		elseif tv == "number" then
			packet:w_u8(0) --(pstor_number)
			packet:w_float(v)
		elseif tv == "boolean" then
			packet:w_u8(2) --(pstor_boolean)
			packet:w_bool(v)
		else
			abort("xr_logic: pstor_save_all: unregistered type '%s' encountered (corrupted save?)", tv)
		end
	end
end

function pstor_load_all(obj, reader, npc_storage)
	local pstor = npc_storage.pstor
	if not pstor then
		pstor = {}
		npc_storage.pstor = pstor
	end
	local ctr = reader:r_u32()

	for i = 1, ctr do
		local varname = reader:r_stringZ()
		local tn = reader:r_u8()
		if tn == 1 then --pstor_string then
			pstor[varname] = reader:r_stringZ()
		elseif tn == 0 then --pstor_number then
			pstor[varname] = reader:r_float()
		elseif tn == 2 then --pstor_boolean then
			pstor[varname] = reader:r_bool()
		else
			abort("xr_logic: pstor_load_all: unregistered type N %d encountered (corrupted save?)", tn)
			pstor[varname] = nil
		end
	end
end

function save_obj(obj, packet)
	local st = db_storage[obj:id()]

	packet:w_stringZ(st.ini_filename or "")
	packet:w_stringZ(st.section_logic or "")
	packet:w_stringZ(st.active_section or "")
	packet:w_stringZ(st.gulag_name or "")

	save_logic(obj, packet, st)

	if st.active_scheme then
		issue_event(obj, st[st.active_scheme], "save")
	end

	pstor_save_all(obj, packet, st)
end

function load_obj(obj, reader)
	local st = db_storage[obj:id()]

	local ini_filename = reader:r_stringZ()
	if ini_filename == "" then
		ini_filename = nil
	end

	local section_logic = reader:r_stringZ()
	if section_logic == "" then
		section_logic = nil
	end

	local active_section = reader:r_stringZ()
	if active_section == "" then
		-- В activate_by_section нужно передать строку "nil", а не nil, чтобы не активировать ни одной из схем.
		-- При этом реальная active_section станет равной nil.
		active_section = "nil"
	end

	local gulag_name = reader:r_stringZ()
	if gulag_name == "" then
		gulag_name = nil
	end

	st.loaded_ini_filename = ini_filename
	st.loaded_section_logic = section_logic
	st.loaded_active_section = active_section
	st.loaded_gulag_name = gulag_name

	load_logic(obj, reader, st)

	pstor_load_all(obj, reader, st)
end

local dummy_ini_file = ini_file("[logic]\nactive = nil")

function get_customdata_or_ini_file(npc, filename)
	if filename == "<customdata>" then
		return npc:spawn_ini() or dummy_ini_file
	elseif string_find( filename, "*" ) == 1 then
		-- динамический ltx
		local p = string_find( filename, "*", 2 )
		return gulag_tasks.loadLtx( string_sub(filename, 2, p-1), string_sub(filename, p+1) )
	else
		return ini_file(filename)
	end
end

function initialize_obj(obj, st, loaded, actor, stype, inifile)
	local ini
	if not loaded then
		if not inifile then
			ini = obj:spawn_ini() or dummy_ini_file
		else
			ini = get_customdata_or_ini_file(obj, inifile)
		end
		ini = configure_schemes(obj, ini, "<customdata>", stype, "logic", nil)
		local sect = determine_section_to_activate(obj, ini, "logic")
		activate_by_section(obj, ini, sect, false)
	else
		local ini_filename = st.loaded_ini_filename
		if ini_filename then
			if ini_filename == "<customdata>" then
				ini = obj:spawn_ini() or dummy_ini_file
			elseif string_find( ini_filename, "*" ) == 1 then
				local p = string_find( ini_filename, "*", 2 )
				ini = gulag_tasks.loadLtx( string_sub(ini_filename, 2, p-1), string_sub(ini_filename, p+1) )
			else
				ini = ini_file(ini_filename)
			end
			ini = configure_schemes(obj, ini, ini_filename, stype, st.loaded_section_logic, st.loaded_gulag_name)
			activate_by_section(obj, ini, st.loaded_active_section, true)
		end
	end
end
