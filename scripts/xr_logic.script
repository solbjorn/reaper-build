----------------------------------------------------------------------------------------------------
-- Script switching logic
----------------------------------------------------------------------------------------------------
-- Разработчик: Andrey Fidrya (Zmey) af@svitonline.com
----------------------------------------------------------------------------------------------------

local math_random = math.random
local string_find = string.find
local string_gmatch = string.gmatch
local string_len  = string.len
local string_match = string.match
local string_sub  = string.sub
local string_trim = string.trim

local db_storage = db.storage
local ini_cache = { }

--[[

----------------------------------------------------------------------------------------------------
-- ФУНКЦИИ, КОТОРЫЕ РАЗРЕШЕНО ВЫЗЫВАТЬ ИЗ ДРУГИХ СКРИПТОВ
----------------------------------------------------------------------------------------------------
  Активация схем производится с помощью функций:

function gulag_activate(npc, ini, section, gulag_name, death, combat, actor_dialogs, trade, hit)
Предназначение:
  активирует заданную схему, используется схемой гулаг. Тип скрипта определяется автоматически по имени секции.
Здесь:
  npc - персонаж, для которого будет активирована схема
  ini - его customdata
  section - имя секции, которая должна быть активирована
  gulag_name - имя гулага, которое будет добавлено спереди к именам путей
  death, combat, actor_dialogs, trade, hit - имена секций, задающих поведение при смерти и в бою

function assign_storage_and_bind(npc, ini, scheme, section)
Предназначение:
  Вызывает функцию add_to_binder схемы, а также создает (если его еще нет) и возвращает ссылку на storage
  для схемы. Примечание: в storage при этом могут оставаться старые данные, схема должна очистить его
  самостоятельно.

function pick_section_from_condlist(npc, condlist)
Предназначение:
  Проверяет условия condlist, и если они успешны - ставит указанные infoportions и возвращает текст.
  Если условия не выполняются - возвращает nil.

function try_switch_to_another_section(npc, st)
Предназчанение:
  Используя настройки xr_logic из storage персонажа, пытается переключить его на другую схему, если
  хоть одно из условий переключения сработало. Обычно вызывается из метода update класса персонажа.

function is_active(npc, st)
Предназначение:
  Вызывается из evaluator-а (или в самом начале update у предметов и монстров) для проверки, что данная
  схема сейчас активна (схема определяется по данным в storage).

function cfg_get_switch_conditions(ini, section, npc)
Предназначение:
  Считывает все возможные условия переключения схем.

function parse_condlist(src)
Предназначение:
  Распарсивает условия вида: {+infop1} section1 %-infop2%, {+infop3 -infop4} section2 ... в таблицу.
--]]

--[[
----------------------------------------------------------------------------------------------------
-- ПРИВАТНЫЕ ФУНКЦИИ
----------------------------------------------------------------------------------------------------

function activate_by_section(npc, ini, section, loading)
Предназначение:
  Активирует указанную секцию. Если в данный момент какая-либо секция уже активирована, сообщает об ошибке.

function switch_to_section(npc, st, section)
Предназначение:
  Выполняет переключение с одной секции на другую, если новая секция не nil. Если же она nil, остается
  активной старая секция.

function abort_syntax_error_in_cond(npc, section, field, func_name)
Предназначение:
  Сообщает о синтаксической ошибке в условиях переключения схем секции section и поля field, и останавливает
  игру.

function parse_infop(rslt, str)
Предназначение:
  Распарсивает условия вида " +infop1 =func -infop2 " и т.д. (все не перечислены) в таблицу.

function cfg_get_number_and_condlist(ini, section, field, npc)
function cfg_get_string_and_condlist(ini, section, field, npc)
function cfg_get_condlist(ini, section, field, npc)
Предназначение:
  Считывает из customdata различные условия переключения схем.

function add_condition(lst, at, cond)
Предназначение:
  Добавляет условие в список условий переключения схем.

function cfg_get_overrides(ini, section, npc)
Предназначение:
  Считывает настройки для схем общего поведения.

function generic_scheme_overrides(npc)
Предназначение:
  Возвращает ссылку на настройки схем общего поведения, актуальные для работающей в данный момент схемы,
  либо nil, если ни одна из секций не активна, либо настройки не заданы.

--]]

--[[
-- Предназначение:
--      вызывается при включении набора скриптов через секцию logic у персонажа. Если в секции logic присутствует только
--      поле cfg, использует конфигурационный файл, заданный в этом поле, и возвращает новый ini file.
-- Здесь:
--  npc - персонаж, для которого будет активирована схема
--  ini - его customdata
--  stype - тип скрипта. Поскольку имя секции все еще неизвестно, его нужно задавать явно. Допустимые значения
--          перечислены в файле modules.script.
--  section - имя секции logic
--  gulag_name - имя гулага, если скрипт включается гулагом, а не биндером
--]]
function configure_schemes(npc, ini, ini_filename, stype, section_logic, gulag_name)
  local st     = db_storage[npc:id()]

  -- если какая-то схема была до этого активна, деактивировать её
  if st.active_section then
    issue_event(npc, st[st.active_scheme], "deactivate", npc)
  end

  local actual_ini
  if not ini:section_exist(section_logic) then
    if not gulag_name then
      -- Общие схемы должны работать и без logic:
      actual_ini = ini -- персонаж не обязательно должен иметь секцию logic
    else
      -- Иначе это персонаж Gulag-а и ему не задали работу:
      abort("ERROR: object '%s': unable to find section '%s'", npc:name(), section_logic)
    end
  else
		local filename = (ini:line_exist(section_logic, "cfg") and ini:r_string(section_logic, "cfg")) or nil
		if filename then
			-- Рекурсивно обработать конфигурационный файл, на который ссылается поле cfg
			actual_ini = ini_cache[filename]
			if not actual_ini then
				actual_ini = ini_file(filename)
				ini_cache[filename] = actual_ini
			end
			return configure_schemes(npc, actual_ini, filename, stype, section_logic, gulag_name)
		else
			actual_ini = ini
		end
	end

	if stype < modules.stype_restrictor then
		-- Поскольку в момент активации схемы могли работать ранее установленные общие схемы, нужно их все отключить:
		disable_generic_schemes(npc, stype)
		-- Включаем все общие схемы (раненный, коллбек на попадание и т.д.):
		enable_generic_schemes(actual_ini, npc, stype, section_logic)
	end

	-- Инициализация торговли
	if stype == modules.stype_stalker or npc:is_trader() then
		if actual_ini:section_exist(section_logic) and actual_ini:line_exist(section_logic, "trade") then
			trade_manager.trade_init(npc, actual_ini:r_string(section_logic, "trade"))
		else
			trade_manager.trade_init(npc, nil)
		end
	end

  st.active_section = nil
  st.active_scheme = nil
  if gulag_name then
    st.gulag_name = gulag_name
  else
    st.gulag_name = ""
  end
  st.stype = stype
  st.ini = actual_ini
  st.ini_filename = ini_filename
  st.section_logic = section_logic

  return st.ini
end

-- Вызывается биндером с целью определить первую активную схему
function determine_section_to_activate(npc, ini, section_logic)
  if not ini:section_exist(section_logic) then
    return "nil"
  end

	-- Распарсить строку выбора активной секции с учетом команд, заключенных в %%
	local active_section_cond = cfg_get_condlist(ini, section_logic, "active", npc)
	local active_section
	if not active_section_cond then
		abort("object '%s': section '%s': unable to find field 'active'", npc:name(), section_logic)
	else
		active_section = pick_section_from_condlist(npc, active_section_cond.condlist)
		if not active_section then
			abort("object '%s': section '%s': section 'active' has no conditionless else clause",
				npc:name(), section_logic)
		end
	end

	local npc_id = npc:id()
	if active_section and db_storage[npc_id].stype and db_storage[npc_id].stype <= 1 and
	   db_storage[npc_id].stype ~= stypes[string_match(active_section, "^[_%a]+")] then
  -- Блокируем активацию схемы для зверушек в человеческих гулагах. Dirty Hack.
    return "nil"
  else
  return active_section
  end
end

------------------------------------------------------------------------------------------------------------
-- ВНОСЯ ИЗМЕНЕНИЯ В ЭТУ ФУНКЦИЮ, НЕ ЗАБЫВАЙТЕ ДОБАВЛЯТЬ СООТВЕТСТВУЮЩИЕ СТРОКИ И В enable_generic_schemes
------------------------------------------------------------------------------------------------------------
function disable_generic_schemes(npc, stype)
  if stype == modules.stype_stalker then
    xr_combat.disable_scheme(npc, "combat")
	xr_punch_tm.disable_scheme(npc, "punch_tm")
	xrs_ai.disable_schemes(npc, stype)
    xr_use.disable_scheme(npc, "use")
    xr_hit.disable_scheme(npc, "hit")
    xr_meet.disable_scheme(npc, "actor_dialogs")
    xr_heli_hunter.disable_scheme(npc, "heli_hunter")
    xr_combat_ignore.disable_scheme(npc, "combat_ignore")
  elseif stype == modules.stype_mobile then
    mob_combat.disable_scheme(npc, "mob_combat")
    mob_trade.disable_scheme(npc, "mob_trade")
  elseif stype == modules.stype_item then
    ph_on_hit.disable_scheme(npc, "ph_on_hit")
  elseif stype == modules.stype_heli then
    xr_hit.disable_scheme(npc, "hit")
  end
end

------------------------------------------------------------------------------------------------------------
-- ВНОСЯ ИЗМЕНЕНИЯ В ЭТУ ФУНКЦИЮ, НЕ ЗАБЫВАЙТЕ ДОБАВЛЯТЬ СООТВЕТСТВУЮЩИЕ СТРОКИ И В disable_generic_schemes
------------------------------------------------------------------------------------------------------------
function enable_generic_schemes(ini, npc, stype, section)
	local function get_field_string(field)
		return (ini:line_exist(section, field) and ini:r_string(section, field)) or nil
	end
	local field_value
	if not section or not ini:section_exist(section) then
		if stype == modules.stype_stalker then
			blowout_scheme.set_hide(npc, ini, "blowout_scheme", section)

			assign_storage_and_bind(npc, ini, "danger", "danger")
			xr_combat.set_combat_checker(npc, ini, "combat", nil)
			xr_wounded.set_wounded (npc, ini, "wounded", nil)
			assign_storage_and_bind(npc, ini, "abuse", nil)
			assign_storage_and_bind(npc, ini, "meet", nil)
			assign_storage_and_bind(npc, ini, "death", nil)
			xr_heli_hunter.set_scheme(npc, ini, "heli_hunter", nil)

			watcher_act.set_scheme(npc, ini, "watcher_act", "watcher_act")
			xr_punch_tm.set_scheme(npc, nil, "punch_tm")
			xrs_ai.enable_schemes(ini, npc, stype, section)
		elseif stype == modules.stype_mobile then
			mob_death.set_scheme(npc, ini, "mob_death", nil)
		end
	else
		if stype == modules.stype_stalker then
			blowout_scheme.set_hide(npc, ini, "blowout_scheme", section)

			assign_storage_and_bind(npc, ini, "danger", "danger")
			xr_combat.set_combat_checker(npc, ini, "combat", get_field_string("on_combat"))

			field_value = get_field_string("on_use")
			if field_value then
				xr_use.set_use_checker(npc, ini, "use", field_value)
			end

			field_value = get_field_string("info")
			if field_value then
				stalker_generic.set_npc_info(npc, ini, "info", field_value)
			end

			field_value = get_field_string("on_hit")
			if field_value then
				xr_hit.set_hit_checker(npc, ini, "hit", field_value)
			end

			field_value = get_field_string("actor_dialogs")
			if field_value then
				xr_meet.set_actor_dialogs(npc, ini, "actor_dialogs", field_value)
			end

			xr_wounded.set_wounded (npc, ini, "wounded", get_field_string("wounded"))
			assign_storage_and_bind(npc, ini, "abuse", section)
			assign_storage_and_bind(npc, ini, "meet", get_field_string("meet"))
			assign_storage_and_bind(npc, ini, "death", get_field_string("on_death"))
			xr_heli_hunter.set_scheme(npc, ini, "heli_hunter", get_field_string("heli_hunter"))

			field_value = get_field_string("combat_ignore")
			if field_value then
				xr_combat_ignore.set_combat_ignore_checker(npc, ini, "combat_ignore", field_value)
			end

			watcher_act.set_scheme(npc, ini, "watcher_act", "watcher_act")
			xr_punch_tm.set_scheme(npc, nil, "punch_tm")
			xrs_ai.enable_schemes(ini, npc, stype, section)
		elseif stype == modules.stype_mobile then
			field_value = get_field_string("on_combat")
			if field_value then
				mob_combat.set_scheme(npc, ini, "mob_combat", field_value)
			end

			mob_death.set_scheme(npc, ini, "mob_death", get_field_string("on_death"))

			field_value = get_field_string("on_trade")
			if field_value then
				mob_trade.set_scheme(npc, ini, "mob_trade", field_value)
			end

			field_value = get_field_string("on_hit")
			if field_value then
				xr_hit.set_hit_checker(npc, ini, "hit", field_value)
			end
		elseif stype == modules.stype_item then
			field_value = get_field_string("on_hit")
			if field_value then
				ph_on_hit.set_scheme(npc, ini, "ph_on_hit", field_value)
			end
		elseif stype == modules.stype_heli then
			field_value = get_field_string("on_hit")
			if field_value then
				xr_hit.set_hit_checker(npc, ini, "hit", field_value)
			end
		end
	end -- if not section or not section exists
end

function activate_by_section(npc, ini, section, loading)
	if loading == nil then
		abort("xr_logic: activate_by_section: loading field is nil, true or false expected")
		return
	end

	local npc_storage = db_storage[npc:id()]
	if npc_storage.active_section then
		abort("xr_logic: activate_by_section: while processing section '%s': character '%s': trying to " ..
			"activate more than one schemes at once (section '%s' is active)",
			section, npc:name(), npc_storage.active_section)
		return
	end

  if not loading then
    npc_storage.activation_time = time_global()
    -- GAMETIME added by Stohe.
    npc_storage.activation_game_time = game.get_game_time()
  end

	if section == "nil"
		or ( ini:section_exist(section)
		and ini:line_count(section) == 0 )
	then
    npc_storage.overrides = nil
    reset_generic_schemes_on_scheme_switch(npc, "nil", "nil")
    npc_storage.active_section = nil
    npc_storage.active_scheme = nil
    return
  end

	if section and ini:section_exist(section) then
		local scheme = string_match( section, "^[_%a]+" )
		if scheme == nil then
			abort("object '%s': unable to determine scheme name from section name '%s'", npc:name(), section)
			return
		end

		local stype = npc_storage.stype
		if stype < modules.stype_heli then
			-- Сбросить общие схемы:
			reset_generic_schemes_on_scheme_switch(npc, scheme, section)
		end

    -- schemes[scheme] даст имя файла (модуля), в котором реализована схема
    -- _G[] даст указатель на неймспейс (таблицу) этого модуля
		_G[schemes[scheme]].set_scheme(npc, ini, scheme, section, npc_storage["gulag_name"])
    npc_storage.active_section = section
    npc_storage.active_scheme = scheme

		if stype == modules.stype_stalker then
			npc_storage.overrides = cfg_get_overrides(ini, section, npc)
			-- чтобы избежать дальнейшего движения по пути при установке рестрикторов
			local lvid = npc:level_vertex_id()
			if not npc:accessible(lvid) then
				lvid = npc:accessible_nearest( level.vertex_position(lvid), vector() )
			end
			npc:set_dest_level_vertex_id(lvid)

      issue_event(npc, npc_storage[scheme], "activate_scheme", loading, npc)
    else
      issue_event(npc, npc_storage[scheme], "reset_scheme", loading, npc)
    end
  else
    abort("object '%s': activate_by_section: section '%s' does not exist",
      npc:name(), section)
  end
end

--[[
-- Предназначение:
--  Производит сброс состояния объекта (снимает коллбеки, отключает разговор) непосредственно перед включением
--  новой схемы.
--]]
function reset_generic_schemes_on_scheme_switch(npc, scheme, section)
  local st = db_storage[npc:id()]
	local stype = st.stype

  if not stype then
    return
  end

  if stype == modules.stype_stalker then
    xr_meet.reset_meet(npc, scheme, st, section)
    xr_wounded.reset_wounded(npc, scheme, st, section)
    xr_death.reset_death(npc, scheme, st, section)
    xr_danger.reset_danger(npc, scheme, st, section)
		stalker_generic.reset_threshold_and_show_spot(npc, scheme, st, section)
  elseif stype == modules.stype_mobile then
		if npc:is_trader() then npc:restore_default_start_dialog() end
		if npc:get_script() then npc:script(false, script_name()) end
    if npc:clsid() == clsid_bloodsucker_s then
      if scheme == "nil" then
        npc:set_manual_invisibility(false)
      else
        npc:set_manual_invisibility(true)
      end
    end

		local panic_threshold = (st.ini:line_exist(section, "panic") and st.ini:r_float(section, "panic")) or nil
		if panic_threshold then
			npc:set_custom_panic_threshold(panic_threshold)
		else
			npc:set_default_panic_threshold()
		end
	elseif stype == modules.stype_item then
		if st.ph_door == nil and st.ph_button == nil then
			npc:set_callback(callback.use_object, nil)
		end
		npc:set_nonscript_usable(true)
		if npc:clsid() == clsid_car then
			-- Другие объекты под скрипт не берутся, поэтому для них не надо сбрасывать
			npc:destroy_car()
			if npc:get_script() then npc:script(false, script_name()) end
		end
	end
end

function assign_storage_and_bind(npc, ini, scheme, section)
	local npc_storage = db_storage[npc:id()]
	local st = npc_storage[scheme]

	if st then
		st.scheme = scheme
		st.section = section
		st.ini = ini
	else
		st = {
			["npc"] = npc,
			["scheme"] = scheme,
			["section"] = section,
			["ini"] = ini,
			["actions"] = {}
		}
		npc_storage[scheme] = st

		-- Схема стартует впервые - прибиндить
		_G[schemes[scheme]].add_to_binder(npc, st)
	end

	return st
end

function unsubscribe_action_from_events(npc, storage, new_action)
  if not storage.actions then
    return
  end

  storage.actions[new_action] = nil
end

-- st - storage активной схемы
function issue_event(npc, st, event_fn, ...)
  if not st or not st.actions then
    return
  end

  for action_ptr, is_active in pairs(st.actions) do
    if is_active and action_ptr[event_fn] then
      action_ptr[event_fn](action_ptr, ...)
    end
  end
end

function pick_section_from_condlist(npc, condlist)
	local rval = nil

	local infop_conditions_met, cond, infop
	for n = 1, #condlist do
		cond = condlist[n]
		infop_conditions_met = true -- изначально считаем, что все условия переключения удовлетворены
		for inum = 1, #cond.infop_check do
			infop = cond.infop_check[inum]
      if infop.prob then
        if not rval then
          rval = math_random(100)
        end
        if infop.prob < rval then
          infop_conditions_met = false -- инфопоршен есть, но он не должен присутствовать
          break
        end
			elseif infop.func then
				if infop.func(Actor, npc, infop.params) then
					if not infop.expected then
						infop_conditions_met = false -- инфопоршен есть, но не должен присутствовать
						break
					end
				else
					if infop.expected then
						infop_conditions_met = false -- инфопоршен есть, но не должен присутствовать
						break
					end
				end
			elseif has_info(infop.name) then
        if not infop.required then
          infop_conditions_met = false -- инфопоршен есть, но он не должен присутствовать
          break
        end
      else
        if infop.required then
          infop_conditions_met = false -- инфопоршена нет, но он нужен
          break
        end
      end
    end
    if infop_conditions_met then
      -- Условия выполнены. Независимо от того, задана ли секция, нужно проставить требуемые
      -- infoportions:
			local num_infop_set = #cond.infop_set
			if num_infop_set > 0 then
				if Actor == nil then
					abort("TRYING TO SET INFOS WHEN ACTOR IS NIL")
					return nil
				end
				for inum = 1, num_infop_set do
					infop = cond.infop_set[inum]
					if infop.func then
						infop.func(Actor, npc, infop.params)
					elseif infop.required then
						if not has_info(infop.name) then
							give_info(infop.name)
						end
					else
						if has_info(infop.name) then
							disable_info(infop.name)
						end
					end
				end
			end
			if cond.section == "never" then
				return nil
			else
				return cond.section
			end
		end
	end

	return nil
end

-- Выполняет переключение на указанную секцию, если задана.
-- Если section == nil, остается работать старая секция.
function switch_to_section(npc, st, section)
	if section == nil or section == "" then
		return false
	end
	local npc_storage = db_storage[npc:id()]
	local active_section = npc_storage.active_section
  if active_section == section then
    return false
  end

  -- call scheme::finalize()
  if active_section then
    issue_event(npc, npc_storage[npc_storage.active_scheme], "deactivate", npc)
  end

  npc_storage.active_section = nil
  npc_storage.active_scheme = nil
  activate_by_section(npc, st.ini, section, false)
  return true
end

function try_switch_to_another_section(npc, st)
	local actor = Actor
	if not actor then
		abort("xr_logic.try_switch_to_another_section(): error executing scheme '%s': actor is nil - check bind_actor.script, db.script", st.scheme)
		return
	end

	local l = st.logic
	local string_find_ = string_find
	local function actor_in_zone(zone)
		return zone ~= nil and zone:inside(actor:position())
	end

	if not l then
		abort("Can't find script switching information in storage, scheme '%s'", st.active_scheme)
		return
	end

	local switched = false
	local c, c_name
	for n = 1, #l do
		c = l[n]
		c_name = c.name
		if c_name == "on_info" then
			-- FIXME: не дублировать тут имена, оставить один on_info, но добавлять несколько его экземпляров в список
			switched = true
		elseif c_name == "on_signal" then
			switched = st.signals and st.signals[c.v1]
		elseif c_name == "on_timer" then
			switched = time_global() >= db_storage[npc:id()].activation_time + c.v1
		elseif string_find_(c_name, "^on_actor_") then
			if c_name == "on_actor_inside" then
				switched = actor_in_zone(npc)
			elseif c_name == "on_actor_dist_le" then
				switched = npc:alive() and npc:see(actor) and distance_between(actor, npc) <= c.v1
			elseif c_name == "on_actor_dist_le_nvis" then
				switched = distance_between(actor, npc) <= c.v1
			elseif c_name == "on_actor_in_zone" then
				switched = actor_in_zone(db.zone_by_name[c.v1])
			elseif c_name == "on_actor_outside" then
				switched = not actor_in_zone(npc)
			elseif c_name == "on_actor_dist_ge" then
				-- ТУТ УМЫШЛЕННО >, А НЕ >=, потому что оно составляет пару с on_actor_dist_le, где <=
				switched = npc:alive() and npc:see(actor) and distance_between(actor, npc) > c.v1
			elseif c_name == "on_actor_dist_ge_nvis" then
				-- ТУТ УМЫШЛЕННО >, А НЕ >=, потому что оно составляет пару с on_actor_dist_le_nvis, где <=
				switched = distance_between(actor, npc) > c.v1
			elseif c_name == "on_actor_not_in_zone" then
				switched = not actor_in_zone(db.zone_by_name[c.v1])
			end
		-- GAMETIME added by Stohe.
		elseif c_name == "on_game_timer" then
			switched =  game.get_game_time():diffSec(db_storage[npc:id()].activation_game_time) >= c.v1
		elseif c_name == "on_npc_in_zone" then
			switched = utils.npc_in_zone(level.object_by_id(c.npc_id), db.zone_by_name[c.v2])
		elseif c_name == "on_npc_not_in_zone" then
			switched = not utils.npc_in_zone(level.object_by_id(c.npc_id), db.zone_by_name[c.v2])
		else
			abort(
				"WARNING: object '%s': try_switch_to_another_section: unknown condition '%s' encountered",
				npc:name(), c_name)
			return false
		end

		if switched and switch_to_section(npc, st, pick_section_from_condlist(npc, c.condlist)) then
			return true
		end
	end

	return false
end

function is_active(npc, st)
  if st.section == nil then
    abort("npc '%s': st.section is nil, active section is '%s'",
      npc:name(), utils.to_str(db_storage[npc:id()].active_section))
  end

	return (st.section == db_storage[npc:id()].active_section)
end

function abort_syntax_error_in_cond(npc, section, field, func_name)
	abort("xr_logic: object '%s': section '%s': field '%s': syntax error in switch condition in %s()",
		(npc and npc:name()) or "nil", tostring(section), tostring(field), func_name)
end

function parse_infop_func(str, check)
	local file, fname = string_match(str, "(.+)[.](.+)")
	if not fname then
		file = check and "xr_conditions" or "xr_effects"
		fname = str
	end

	local func = _G[file] and _G[file][fname]
	if not func then
		abort("parse_infop_func: function '%s' is not found in '%s'",
		      fname or str or "nil", file or "nil")
		return nil
	end

	return func
end

function parse_infop(rslt, str, check)
	local infop_name, sign
	local infop_n = 1
	local at, params
	for s in string_gmatch(str, "%s*([%-%+%~%=%!][^%-%+%~%=%!%s]+)%s*") do
		sign = string_sub(s, 1, 1)
		infop_name = string_sub(s, 2)
		params = nil

		-- парсим параметры функций
		at = string_find(infop_name, "%(")
		if at then
			if string_sub(infop_name, -1) ~= ")" then
				abort("wrong condlist %s", str)
			end
			if at < string_len(infop_name) - 1 then
				params = {}
				for par in string_gmatch(string_sub(infop_name, at + 1, -2), "%s*([^:]+)%s*") do
					params[#params+1] = tonumber(par) or par
				end
			end
			infop_name = string_sub(infop_name, 1, at - 1)
		end

		if sign == "+" then
			rslt[infop_n] = {
				name		= infop_name,
				required	= true
			}
		elseif sign == "=" then
			rslt[infop_n] = {
				func		= parse_infop_func(infop_name, check),
				expected	= true,
				params		= params or {}
			}
		elseif sign == "-" then
			rslt[infop_n] = {
				name		= infop_name,
				required	= false
			}
		elseif sign == "!" then
			rslt[infop_n] = {
				func		= parse_infop_func(infop_name, check),
				expected	= false,
				params		= params or {}
			}
		elseif sign == "~" then
			rslt[infop_n] = {
				prob		= tonumber(infop_name)
			}
		else
			abort_syntax_error_in_cond(nil, section, field, "parse_infop")
			return
		end
		infop_n = infop_n + 1
	end
end

-- Распарсивает строку src вида:
-- {+infop1} section1 %-infop2%, {+infop3 -infop4} section2 ...
-- в таблицу:
-- {
--   1 = { infop_check = { 1 = {"infop1" = true} }, infop_set = { 1 = {"infop2" = false } }, section = "section1" },
--   2 = { infop_check = { 1 = {"infop3" = true}, 2 = {"infop4" = false} }, infop_set = {}, section = "section2" },
-- }
function parse_condlist(src)
	local lst = {}

	-- 1) Разбиваем на разделенные запятыми части:
	local at, to, infop_lst, remainings, newsect

	local n = 1
	for fld in string_gmatch(src, "%s*([^,]+)%s*") do
		-- Здесь fld это набор infoportions в {} и имя секции, на которую переключиться.
		local infop_check_table = {}
		local infop_set_table = {}

		-- Выделяем список infoportions для проверки:
		at, to, infop_lst = string_find(fld, "{%s*(.*)%s*}")
		if infop_lst then
			-- Выделяем оставшуюся часть поля, т.е. имя секции плюс список infoportions для установки:
			remainings = string_sub(fld, 1, at - 1) .. string_sub(fld, to + 1)
			parse_infop(infop_check_table, infop_lst, true)
		else
			-- Список infoportions для проверки не был задан, следовательно, ничего не удаляем:
			remainings = fld
		end

		-- Выделяем список infoportions для установки из remainings:
		at, to, infop_lst = string_find(remainings, "%%%s*(.*)%s*%%")
		if infop_lst then
			-- Выделяем оставшуюся часть поля, т.е. имя секции:
			newsect = string_sub(remainings, 1, at - 1) .. string_sub(remainings, to + 1)
			parse_infop(infop_set_table, infop_lst, false)
		else
			-- Список infoportions для установки не был задан, следовательно, remainings и есть имя секции.
			newsect = remainings
		end

		-- И сразу trim имя секции:
		newsect = string_trim(newsect)
		if not newsect then
			abort_syntax_error_in_cond(npc, section, field, "parse_condlist")
		end

		lst[n] = {
			section = newsect,
			infop_check = infop_check_table,
			infop_set = infop_set_table
		}

		n = n + 1
	end

	return lst
end

-- a | b | c  ==>  { 1 = "a", 2 = "b", 3 = "c" }
local function parse_params(params)
	local rslt = {}
	local n = 1
	for fld in string_gmatch(params, "%s*([^|]+)%s*") do
		rslt[n] = fld
		n = n + 1
	end
	return rslt
end

function cfg_get_string_and_condlist(ini, section, field, npc)
	if not section or not ini:section_exist(section) then return nil end
	local str = ini:line_exist(section, field) and ini:r_string(section, field)
	if not str then
		return nil
	end

	local par = parse_params(str)
	if not par[1] or not par[2] then
		abort_syntax_error_in_cond(npc, section, field, "cfg_get_string_and_condlist")
	end

	return { name = field, v1 = par[1], condlist = parse_condlist(par[2]) }
end

function cfg_get_two_strings_and_condlist(ini, section, field, npc)
	if not section or not ini:section_exist(section) then return nil end
	local str = ini:line_exist(section, field) and ini:r_string(section, field)
	if not str then
		return nil
	end

	local par = parse_params(str)
	if not par[1] or not par[2] or not par[3] then
		abort_syntax_error_in_cond(npc, section, field, "cfg_get_two_strings_and_condlist")
	end

	return { name = field, v1 = par[1], v2 = par[2], condlist = parse_condlist(par[3]) }
end

function cfg_get_condlist(ini, section, field, npc)
	if not section or not ini:section_exist(section) then return nil end
	local str = ini:line_exist(section, field) and ini:r_string(section, field)
	if not str then
		return nil
	end

	local par = parse_params(str)
	if not par[1] then
		abort_syntax_error_in_cond(npc, section, field, "cfg_get_condlist")
		return nil
	end

	return { name = field, condlist = parse_condlist(par[1]) }
end

local function cfg_get_number_and_condlist_sv(field, field_value)
	local par = parse_params(field_value)
	if not par[1] or not par[2] then
		abort_syntax_error_in_cond(npc, section, field, "cfg_get_number_and_condlist_sv")
	end

	return { name = field, v1 = tonumber(par[1]), condlist = parse_condlist(par[2]) }
end

local function cfg_get_string_and_condlist_sv(field, field_value)
	local par = parse_params(field_value)
	if not par[1] or not par[2] then
		abort_syntax_error_in_cond(npc, section, field, "cfg_get_string_and_condlist_sv")
	end

	return { name = field, v1 = par[1], condlist = parse_condlist(par[2]) }
end

function cfg_get_condlist_sv(field, field_value)
	local par = parse_params(field_value)
	if not par[1] then
		abort_syntax_error_in_cond(npc, section, field, "cfg_get_condlist_sv")
		return nil
	end

	return { name = field, condlist = parse_condlist(par[1]) }
end

function cfg_get_switch_conditions(ini, section, npc)
	local l = {}
	if not section or not ini:section_exist(section) then
		return l
	end

	local n = 1

	local function add_conditions(func, cond)
		local i = 1
		local field_value = ini:line_exist(section, cond) and ini:r_string(section, cond)

		local c = field_value and func(cond, field_value) or nil

		while c ~= nil do
			l[n] = c
			n = n + 1

			i = i + 1
			local new_cond = cond..i
			field_value = ini:line_exist(section, new_cond) and ini:r_string(section, new_cond)
			c = field_value and func(cond, field_value) or nil
		end
	end

	add_conditions( cfg_get_condlist_sv           , "on_info"               )
	add_conditions( cfg_get_string_and_condlist_sv, "on_signal"             )
	add_conditions( cfg_get_condlist_sv           , "on_actor_inside"       )
	add_conditions( cfg_get_number_and_condlist_sv, "on_timer"              )
	add_conditions( cfg_get_number_and_condlist_sv, "on_actor_dist_le"      )
	add_conditions( cfg_get_number_and_condlist_sv, "on_actor_dist_le_nvis" )
	add_conditions( cfg_get_number_and_condlist_sv, "on_actor_dist_ge"      )
	add_conditions( cfg_get_number_and_condlist_sv, "on_actor_dist_ge_nvis" )
	add_conditions( cfg_get_number_and_condlist_sv, "on_game_timer"         )
	add_conditions( cfg_get_string_and_condlist_sv, "on_actor_in_zone"      )
	add_conditions( cfg_get_string_and_condlist_sv, "on_actor_not_in_zone"  )
	add_conditions( cfg_get_condlist_sv           , "on_actor_outside"      )

	if ini:line_exist(section, "on_npc_in_zone") then
		c = cfg_get_npc_and_zone(ini, section, "on_npc_in_zone", npc)
		if c ~= nil then
			l[n] = c
			n = n + 1
		end
	end
	if ini:line_exist(section, "on_npc_not_in_zone") then
		c = cfg_get_npc_and_zone(ini, section, "on_npc_not_in_zone", npc)
		if c ~= nil then
			l[n] = c
		end
	end

	return l
end

function cfg_get_overrides(ini, section, npc)
	local function get_field_string(field)
		return (ini:line_exist(section, field) and ini:r_string(section, field)) or nil
	end
	local function cfg_get_condlist_sv_for(field)
		local field_value = (ini:line_exist(section, field) and ini:r_string(section, field)) or nil
		return field_value and cfg_get_condlist_sv(field, field_value)
	end

	local l = nil
	local value
	if string_find(section, "kamp") ~= nil then
		value = get_field_string("center_point")
	else
		value = get_field_string("soundgroup")
	end
	if value then
		l = { soundgroup = value }
	end
	value = cfg_get_condlist_sv_for("combat_ignore_cond")
	if value then
		if value.condlist then
			value.cached_condlist = reap_misc.cached_condlist(value.condlist, 1000)
		end
		if not l then
			l = { combat_ignore = value }
		else
			l.combat_ignore = value
		end
	end
	value = (ini:line_exist(section, "combat_ignore_keep_when_attacked") and ini:r_bool(section, "combat_ignore_keep_when_attacked")) or false
	if value then
		if not l then
			l = { combat_ignore_keep_when_attacked = value }
		else
			l.combat_ignore_keep_when_attacked = value
		end
	end
	value = cfg_get_condlist_sv_for("combat_type")
	if value then
		if not l then
			l = { combat_type = value }
		else
			l.combat_type = value
		end
	end
	value = cfg_get_condlist_sv_for("on_combat")
	if value then
		if not l then
			l = { on_combat = value }
		else
			l.on_combat = value
		end
	end
	value = get_field_string("heli_hunter")
	if value then
		if not l then
			l = { heli_hunter = parse_condlist(value) }
		else
			l.heli_hunter = parse_condlist(value)
		end
	end

	return l
end

function cfg_get_npc_and_zone(ini, section, field, npc)
	local t = cfg_get_two_strings_and_condlist(ini, section, field, npc)

	if t then
		local se_obj = story_object(tonumber(t.v1))
		if se_obj then
			t.npc_id = se_obj.id
		else
			t.npc_id = -1
			abort("object '%s': section '%s': field '%s': there is no object with story_id '%s'",
			      npc:name(), section, field, t.v1)
		end
	end

	return t
end

function mob_release(mob)
  if mob:get_script() then
    mob:script(false, script_name())
  end
end

function mob_capture(mob, reset_actions)
  if reset_actions == nil then
    abort("mob_capture: reset_actions parameter's value is not specified")
  end

  if reset_actions then
    reset_action(mob, script_name())
  else
    if not mob:get_script() then
      mob:script(true, script_name())
    end
  end
end

function mob_captured(mob)
  return mob:get_script()
end

local pstor_number = 0
local pstor_string = 1
local pstor_true = 2
local pstor_false = 3
local pstor_table = 4
local pstor_end_table = 5

local pstor_types = {
	['string'] = true,
	['number'] = true,
	['boolean'] = true,
	['table'] = true
}

function pstor_store(obj, varname, val)
	local npc_storage = obj and db_storage[obj:id()]
	if not npc_storage then
		abort("xr_logic: pstor_store: no storage for object " .. (obj and obj:name() or "<nil>"))
		return
	end

	local obj_pstor = npc_storage.pstor
	if not obj_pstor then
		obj_pstor = { }
		npc_storage.pstor = obj_pstor
	end

	if val == nil then
		obj_pstor[varname] = nil
	elseif pstor_types[type(val)] then
		obj_pstor[varname] = val
	else
		abort("xr_logic: pstor_store: unregistered type '%s' encountered (corrupted save?)", type(val))
	end
end

function pstor_retrieve(obj, varname, defval, del)
	local obj_pstor = obj and db_storage[obj:id()].pstor
	local var = obj_pstor and obj_pstor[varname]

	if var == nil then return defval end
	if del then obj_pstor[varname] = nil end

	return var
end

function pstor_save_table(pk, tbl, obj)
	local tp
	for k, v in pairs(tbl) do
		if v == true then
			pk:w_u8(pstor_true)
		elseif v == false then
			pk:w_u8(pstor_false)
		else
			tp = type(v)
			if tp == "string" then
				pk:w_u8(pstor_string)
				pk:w_stringZ(v)
			elseif tp == "number" then
				pk:w_u8(pstor_number)
				pk:w_float(v)
			elseif tp == "table" then
				pk:w_u8(pstor_table)
				pstor_save_table(pk, v, obj)
			else
				abort("xr_logic.save_pstor_table object %s: not registered type '%s' encountered [ %s :: %s ]",
				      obj:name(), tp, k, tostring(v))
			end
		end
		pk:w_stringZ(k)
	end
	pk:w_u8(pstor_end_table)
end

function pstor_load_table(pk, tbl, obj)
	local k, v, n
	while true do
		n = pk:r_u8()
		if n == pstor_end_table then
			return tbl
		else
			if n == pstor_string then
				v = pk:r_stringZ()
			elseif n == pstor_number then
				v = pk:r_float()
			elseif n == pstor_true then
				v = true
			elseif n == pstor_false then
				v = false
			elseif n == pstor_table then
				v = pstor_load_table(pk, { }, obj)
			else
				abort("xr_logic.pstor_load_table object %s: unregistered type '%d' encountered",
				      obj:name(), n)
				v = nil
			end
			k = pk:r_stringZ()
			tbl[k] = v
		end
	end
end

function pstor_save_all(obj, packet, npc_storage)
	local pstor = npc_storage.pstor
	if not pstor then
		pstor = {}
		npc_storage.pstor = pstor
	end

	pstor_save_table(packet, pstor, obj)
end

function pstor_load_all(obj, reader, npc_storage)
	local pstor = npc_storage.pstor
	if not pstor then
		pstor = {}
		npc_storage.pstor = pstor
	end

	pstor_load_table(reader, pstor, obj)
end

function save_obj(obj, packet)
	local st = db_storage[obj:id()]

	-- сообщение по побившейся логике
	if ((st.loaded_data and not st.loaded_data.ini_filename)
		or not st.ini_filename)
		and logic_not_empty(obj)
	then
		abort("xr_logic: save_obj: object " .. obj:name() .. " has broken logics")
		return
	end

	if st.loaded_data == nil then
		packet:w_stringZ(st.ini_filename or "")
		packet:w_stringZ(st.section_logic or "")
		packet:w_stringZ(st.active_section or "")
		packet:w_stringZ(st.gulag_name or "")
	else
		-- Если логика объекта не успела проинициализироваться,
		-- то сохраним загруженные данные, чтобы логика не слетела.
		-- Также здесь будут сохраняться объекты, имеющие неактивную логику
		-- (мёртвые НПС, рестрикторы, ящики и физ. объекты без логики, и т.д.).
		local ld = st.loaded_data
		packet:w_stringZ(ld.ini_filename or "")
		packet:w_stringZ(ld.section_logic or "")
		packet:w_stringZ(ld.active_section or "")
		packet:w_stringZ(ld.gulag_name or "")
	end

	packet:w_s32( (st.activation_time or 0) - time_global() )
	-- GAMETIME added by Stohe.
	packet:w_CTime(st.activation_game_time)

	if st.active_scheme then
		issue_event(obj, st[st.active_scheme], "save")
	end

	pstor_save_all(obj, packet, st)
end

function load_obj(obj, reader)
	local st = db_storage[obj:id()]
	local ld = {}
	st.loaded_data = ld

	local s = reader:r_stringZ()
	if s ~= "" then
		ld.ini_filename = s
	end

	s = reader:r_stringZ()
	if s ~= "" then
		ld.section_logic = s
	end

	s = reader:r_stringZ()
	-- В activate_by_section нужно передать строку "nil", а не nil, чтобы не активировать ни одной из схем.
	-- При этом реальная active_section станет равной nil.
	ld.active_section = s ~= "" and s or "nil"

	s = reader:r_stringZ()
	if s ~= "" then
		ld.gulag_name = s
	end

	st.activation_time = reader:r_s32() + time_global()
	-- GAMETIME added by Stohe.
	st.activation_game_time = reader:r_CTime()

	pstor_load_all(obj, reader, st)
end

local dummy_ini_file = ini_file("[logic]\nactive = nil")

function initialize_obj(obj, st, loaded, stype)
	local ini
	if not loaded then
		ini = obj:spawn_ini() or dummy_ini_file
		ini = configure_schemes(obj, ini, "<customdata>", stype, "logic", nil)
		local sect = determine_section_to_activate(obj, ini, "logic")
		activate_by_section(obj, ini, sect, false)
	else
		local ld = st.loaded_data
		if ld then
			local ini_filename = ld.ini_filename
			if ini_filename then
				if ini_filename == "<customdata>" then
					ini = obj:spawn_ini() or dummy_ini_file
				elseif string_find( ini_filename, "*" ) == 1 then
					local p = string_find( ini_filename, "*", 2 )
					ini = gulag_tasks.loadLtx( string_sub(ini_filename, 2, p-1), string_sub(ini_filename, p+1) )
				else
					ini = ini_cache[ini_filename]
					if not ini then
						ini = ini_file(ini_filename)
						ini_cache[ini_filename] = ini
					end
				end
				ini = configure_schemes(obj, ini, ini_filename, stype, ld.section_logic, ld.gulag_name)
				activate_by_section(obj, ini, ld.active_section, true)
			end
			st.loaded_data = nil
		end
	end
end

-- у объекта есть "непустая" логика
function logic_not_empty(npc, ini)
	if not ini then ini = npc:spawn_ini() end
	return ini and ini:section_exist("logic")
		and ( ini:line_exist("logic", "cfg")
		or ( ini:line_exist("logic", "active")
		and ini:r_string("logic", "active") ~= "nil" )
	)
end

-- переменные
class "CVariable"

function CVariable:__init()
	self.vars = container:get("variable", {})
end

-- пишем переменную
function CVariable:set(var, value)
	self.vars[var] = value
end

-- читаем переменную
function CVariable:get(var, default, delete)
	local value = self.vars[var]
	if value == nil then
		return default
	end

	if delete then
		-- переменная больше не нужна, удаляем
		self.vars[var] = nil
	end

	return value
end

-- удаляем переменную
function CVariable:del(var)
	self.vars[var] = nil
end

-- есть ли переменная
function CVariable:has(var)
	return self.vars[var] ~= nil
end
