----------------------------------------------------------------------------------------------------
-- Remark
----------------------------------------------------------------------------------------------------
-- Разработчик: Andrey Fidrya (Zmey) af@svitonline.com
-- Изменения: Didenko Ruslan.
----------------------------------------------------------------------------------------------------

local state_initial = 0
local state_animation = 1
local state_sound = 2
local state_finish = 3

---------------------------------------------------------------------------------------------------------------------
class "evaluator_need_remark" (property_evaluator)
function evaluator_need_remark:__init(storage, name) super(nil, name)
    self.st = storage
end
function evaluator_need_remark:evaluate()
	return self.st.section == db.storage[self.object:id()].active_section
end

----------------------------------------------------------------------------------------------------------------------
class "action_remark_activity" (action_base)
function action_remark_activity:__init (npc_name, action_name, storage) super(nil, action_name)
  self.st = storage
end
function action_remark_activity:initialize()
  action_base.initialize(self)
  self.object:set_desired_position()
  self.object:set_desired_direction()
  xr_sound.set_sound(self.object, nil)
end
function action_remark_activity:activate_scheme()
    self.st.signals = {}
    self.sound_end_signalled = false
    self.action_end_signalled = false
    self.anim_end_signalled = false

  -- Определим нужно ли нам отыгрывать анимацию/поворачиваться на объект.
  self.anim_scheduled = true
  
  -- Определим нужно ли нам отыгрывать отдельно звук после поворота.
  if self.st.snd_anim_sync == false and
     self.st.snd ~= nil 
  then
    self.snd_scheduled = true
  else
    self.snd_scheduled = false
  end

  self.snd_started = false
  
  -- Задаем стартовое состояние
  self.state = state_initial
  self.tips_sound = nil
end
function action_remark_activity:get_target()
  local look_tbl = {}

	--' Если таргет не проинициализирован, то запускаем инициализатор.
	if self.st.target_init == false then
		self.st.target_position, self.st.target_id, self.st.target_init = initialize_gulag_target(self.object, self.st.target)
		if self.st.target_init == false then
			return nil
		end
	end

    if self.st.target_actor == true then
        look_tbl.look_object = db_actor
    end

    if self.st.target_id then
        look_tbl.look_object = level.object_by_id(self.st.target_id)
    end

    if self.st.target_position then
        look_tbl.look_position = self.st.target_position
    end

    return look_tbl
end
function action_remark_activity:turn_end_callback()
end
function action_remark_activity:time_callback()
  self.state = state_sound
  self:update()
end
function action_remark_activity:update()
  --' 1. Мы должны повернуться на объект.
  --printf("REMARK: [%s] state[%s]", self.object:name(), self.state)
  if self.state == state_initial then
    local cb = { obj = self, func = self.time_callback, turn_end_func = self.turn_end_callback }
    local synsound
    if self.st.snd_anim_sync == true then
      self.snd_started = true
      synsound = self.st.snd
    else
      synsound = nil
    end
    local target = self:get_target()
    if target == nil then
      return
    end
    
    state_mgr.set_state(self.object, self.st.anim, cb, 0, target, { animation = self.st.anim_reset }, synsound)     
    self.state = state_animation
    
  --' Ожидание колбека от стейтменеджера
  elseif self.state == state_animation then
  
  --' 2. Мы должны отыграть фразу.
  elseif self.state == state_sound then
    --' Должны выдать сигнал anim_end
    if self.anim_end_signalled == false then
      self.anim_end_signalled = true
      self.st.signals["anim_end"] = true
    end
  
    if self.snd_scheduled == true then
      self.snd_started = true
      xr_sound.set_sound_play(self.object, self.st.snd, 50)
    end
    --' Нужно выдать связанный типс.
    if self.st.tips_id ~= nil then
      self.tips_sound = news_manager.send_tip_nosound(db.actor, self.st.tips_id, self.st.sender)
      if self.tips_sound ~= nil then
        --' Играем звук забитый
        self.tips_sound:play(db.actor, 0, sound_object.s2d)
      end
    end

  
    self.state = state_finish
    
  --' 3. Мы должны выдать сигнал об окончании действия
  --' должны выдать сигнал action_end
  --' должны выдать сигнал sound_end
  elseif self.state == state_finish then
    --' Проверить что звук уже запущен:
    if self.snd_started == true then
      if self.object:active_sound_count() ~= 0 then
        self.snd_started = false
      end
    end
  
    if self.snd_started == false and self.object:active_sound_count() == 0 then
      if self.sound_end_signalled == false then
        self.st.signals["sound_end"] = true
        self.sound_end_signalled = true
      end
    end

    if self.sound_end_signalled == true and
       self.anim_end_signalled == true
    then
      if self.action_end_signalled == false then
        self.st.signals["action_end"] = true
        self.action_end_signalled = true
      end
    end
  end
  
end
function action_remark_activity:execute()
  action_base.execute(self)

  --' Try to switch to another scheme:
  if xr_logic.try_switch_to_another_section(self.object, self.st, db_actor) then
    return
  end
  self:update()
end
function action_remark_activity:finalize()
  if self.tips_sound ~= nil then
    self.tips_sound:stop()
  end
  action_base.finalize(self)
end

----------------------------------------------------------------------------------------------------------------------
--remark binder
----------------------------------------------------------------------------------------------------------------------

local prop_need_remark = xr_evaluators_id.zmey_remark_base + 1
local operator_action_remark = xr_actions_id.zmey_remark_base + 1
local xr_actions_id_alife = xr_actions_id.alife
local wp_stalker_ids_property_alive_true = world_property(stalker_ids.property_alive, true)
local wp_stalker_ids_property_danger_false = world_property(stalker_ids.property_danger, false)
local wp_stalker_ids_property_enemy_false = world_property(stalker_ids.property_enemy, false)
local wp_stalker_ids_property_anomaly_false = world_property(stalker_ids.property_anomaly, false)
local wp_prop_need_remark_true = world_property(prop_need_remark, true)
local wp_prop_need_remark_false = world_property(prop_need_remark, false)

function add_to_binder_q(npc, storage)
	local manager = npc:motivation_action_manager()

		-- // evaluators
	manager:add_evaluator(prop_need_remark, this.evaluator_need_remark(storage, "remark_need_remark"))

	local new_action = this.action_remark_activity(npc, "action_remark_activity", storage)
	new_action:add_precondition(wp_stalker_ids_property_alive_true)
	new_action:add_precondition(wp_stalker_ids_property_danger_false)
	new_action:add_precondition(wp_stalker_ids_property_enemy_false)
	new_action:add_precondition(wp_stalker_ids_property_anomaly_false)
	new_action:add_precondition(wp_prop_need_remark_true)
	xr_motivator.addCommonPrecondition(new_action)
	new_action:add_effect(wp_prop_need_remark_false)
	manager:add_action(operator_action_remark, new_action)

	-- Зарегистрировать все actions, в которых должен быть вызван метод reset_scheme при изменении настроек схемы:
	storage.actions[ new_action ] = true

	new_action = manager:action(xr_actions_id_alife)
	new_action:add_precondition(wp_prop_need_remark_false)
end

local string_find = string.find
local string_sub  = string.sub
function parse_target(target)
	local pos = string_find(target, ",")
	if pos then
		return string_sub(target, 1, pos - 1), string_sub(target, pos + 1)
	else
		return target, nil
	end
end
function initialize_gulag_target(npc, target)
	local gulag = xr_gulag.get_npc_gulag(npc)
	local param1, param2 = parse_target(target)
-- Возможные варианты:
-- Передана работа в гулаге чувака
-- Передана работа и идентификатор гулага
-- Передан патрульный путь и номер вейпоинта.
-- На выход нужно дать: либо target_id либо target_position

-- Если вторым параметром передано число, то это однозначно патрульный путь.
	local wp_id = tonumber(param2)
	if wp_id then
		return patrol(param1):point(wp_id), nil, true
	end
	if param2 then
		gulag = xr_gulag.get_gulag_by_name(param2)
	end
	if gulag then
		return nil, gulag:idNPCOnJob(param1), true
	end

	return nil, nil, false
end


-- Включение схемы
function set_scheme(npc, ini, scheme, section, gulag_name)
	local function get_field_string(field, default)
		return (ini:line_exist(section, field) and ini:r_string(section, field)) or default
	end

	local st = xr_logic.assign_storage_and_bind(npc, ini, scheme, section)

	st.logic		 = xr_logic.cfg_get_switch_conditions(ini, section, npc)

	if section and ini:section_exist(section) then
		st.snd_anim_sync = (ini:line_exist(section, "snd_anim_sync") and ini:r_bool(section, "snd_anim_sync")) or false
		st.snd = get_field_string("snd")
		st.anim = get_field_string("anim", "wait")
		st.tips_id = get_field_string("tips")
		if st.tips_id then
			st.sender = get_field_string("tips_sender")
		end
		if st.anim == "idle" then
			abort("remark <abort>: object '%s', xr_remark.set_scheme: anim field cannot be [idle]", npc:name())
			return
		end
		if ini:line_exist(section, "anim_reset") then
			st.anim_reset = ini:r_bool(section, "anim_reset")
		else
			st.anim_reset = true
		end
		st.target = get_field_string("target", "nil")
	else
		st.snd_anim_sync = false
		st.snd = nil
		st.anim = "wait"
		st.tips_id = ""
		st.sender = ""
		st.anim_reset = true
		st.target = "nil"
	end

	st.target_id = nil
	st.target_position = nil
	if st.target and st.target ~= "nil" then
		if st.target == "actor" then
			st.target_actor = true
			st.target_init = true
		else
			st.target_actor = false
			local sid = tonumber(st.target)
			if sid then
				st.target_id = id_by_sid(sid)
				if not st.target_id then
					st.target_id = nil
				end
				st.target_init = true
			else
				st.target_position, st.target_id, st.target_init = initialize_gulag_target(npc, st.target)
			end
		end
	end
end
