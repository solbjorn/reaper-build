----------------------------------------------------------------------------------------------------------------------
--	Схема лагерь. Чудак(и) у костра.
--	автор: Диденко Руслан (Stohe)
--	TODO:
----------------------------------------------------------------------------------------------------------------------

kamps = {}
kamp_stalkers = {} -- могут ли сталкеры в лагере юзаться игроком.
-- Объявления итераторов
local math_random = math.random
local math_mod = math.mod

deadmansids={} -- кто какой труп оттаскивает
deadmansidsuses={} -- сколько попыток оттащить было сделано

---------------------------------------------------------------------------------------------------------------------
--Evaluators
----------------------------------------------------------------------------------------------------------------------
--' Условие завершения скрипта
class "evaluator_kamp_end" (property_evaluator)
function evaluator_kamp_end:__init(name, storage) super (nil, name)
	self.a = storage
end
function evaluator_kamp_end:evaluate()
	return (self.a.section ~= db.storage[self.object:id()].active_section)
end
--' Находимся ли мы на заданной позиции
class "evaluator_on_position" (property_evaluator)
function evaluator_on_position:__init(name, storage) super (nil, name)
	self.a = storage
end
function evaluator_on_position:evaluate()
    if self.object:level_vertex_id() == self.a.pos_vertex then
		return true
	end
	-- не рыпаться, если кто-то подвинул с места
	if self.a.pos_vertex and self.object:path_completed() and level.vertex_position(self.a.pos_vertex):distance_to_sqr(self.object:position()) < 8 then
		return true
	end
	return false
end
--added by xStream--
--' Оп-па! Увидели труп поблизости от костра, непорядок...
class "evaluator_see_deadman" (property_evaluator)
function evaluator_see_deadman:__init(name, storage) super (nil, name)
	self.a = storage
end
function evaluator_see_deadman:evaluate()
	local npc = self.object
	-- Есть дела поважнее, чем трупы складировать...
	if not xr_logic.is_active(self.object, self.a) then
		if self.a.choosed_deadman then
			deadmansids[self.a.choosed_deadman]=nil
			self.a.choosed_deadman=nil
			self.a.reached=nil
		end
		return false
	end

	-- Труп себе уже выбрали, не спускаем с него глаз...
	if self.a.choosed_deadman then
		local obj = level.object_by_id(self.a.choosed_deadman)
		if obj and obj:position():distance_to(patrol(self.a.center_point):point(0))<20 then
			return true
		end
		-- если утащен далеко, то ну его нафиг...
		deadmansids[self.a.choosed_deadman]=nil
		self.a.choosed_deadman=nil
		self.a.reached=nil
		return false
	end

	local function check_item(o)
			local obj=o:object()
			--если есть рядом с костром труп сталкера или монстра, его еще никто не прихватил себе и трупец нигде не застрял, то забираем его...
			if (obj:is_stalker() or obj:is_monster()) and not obj:alive() and (not deadmansids[obj:id()] or not level_object(deadmansids[obj:id()]) or not level_object(deadmansids[obj:id()]):alive()) and obj:position():distance_to(patrol(self.a.center_point):point(0))<10 then
				if not deadmansidsuses[obj:id()] or deadmansidsuses[obj:id()]<3 then
					deadmansids[obj:id()]=npc:id()
					self.a.choosed_deadman=obj:id()
					deadmansidsuses[obj:id()] = (deadmansidsuses[obj:id()] or 0) +1
					-- ...заодно сразу прикидываем, куда бы его оттащить от костра, желательно под забор, стену дома и т.п.,
					-- за неимением таковых - будем тащить куда попало, главное - подальше от костра
				  self.a.drop_lvid=npc:level_vertex_id()
				  local gi=level.object_by_id(self.a.choosed_deadman)
				  if gi then
				    local center = gi:level_vertex_id()
				    local center_pos = patrol(self.a.center_point):point(0)
				    local max_dist=0
				    local tgt_vertex=nil
				    local base_dir=gi:position():sub(center_pos)
				    local base_point=npc:vertex_in_direction(center,gi:position():sub(center_pos):mul(-1),20)
				    for ang=-90,90,20 do
				      local cur_vert=npc:vertex_in_direction(base_point,vector_rotate_y(base_dir,ang),20)
				      local dist=level.vertex_position(cur_vert):distance_to(center_pos)
				      if dist>11 and dist<17 then
				        if dist>max_dist then
				          max_dist=dist
				          tgt_vertex=cur_vert
				        end
				      end
				    end
				    if tgt_vertex==nil then
				      tgt_vertex=npc:vertex_in_direction(base_point,vector_rotate_y(base_dir,math_random()*180-90),20)
				    end

				    self.a.drop_lvid = tgt_vertex
				    self.a.ps=gi:get_physics_shell()
				  end
					return true
				end
			end
	end

	for o in npc:memory_visible_objects() do
		check_item(o)
	end
	for o in npc:memory_sound_objects() do
		check_item(o)
	end
	for o in npc:not_yet_visible_objects() do
		check_item(o)
	end
	return false
end

--' Тащим труп
class "evaluator_can_move_deadman" (property_evaluator)
function evaluator_can_move_deadman:__init(name, storage) super (nil, name)
	self.a = storage
end
function evaluator_can_move_deadman:evaluate()
  local npc=self.object
	local obj = level.object_by_id(self.a.choosed_deadman)
	--если труп застрял (расстояние увеличилось), то возвращаемся к нему
	--или если ГГ подошел, то уделяем ему чуточку внимания
  return self.a.reached==1 and obj and obj:bone_position("bip01_spine1"):distance_to(npc:position())<2 and obj:bone_position("bip01_spine1"):distance_to(Actor:position())>3.0
end
--end--
----------------------------------------------------------------------------------------------------------------------
--Actions
----------------------------------------------------------------------------------------------------------------------
--' Идет в заданную область
class "action_go_position" (action_base)
function action_go_position:__init (action_name,storage) super (nil,action_name)
	self.a = storage
end
function action_go_position:initialize()
	action_base.initialize(self)
	self.object:set_desired_position()
	self.object:set_desired_direction()

	self.a.pos_vertex = nil
	self.a.dest_vertex = nil
	state_mgr.set_state(self.object, "idle")
	self.pos = self.object:position()
	self.pos_count = time_global() -- 0
end
function action_go_position:check_progress(ticks)
	if time_global() - self.pos_count > ticks then
		local pos = self.object:position()
		self.pos_count = time_global()
		if pos:distance_to(self.pos) < 0.1 then
			local cur_spot = kamps[self.a.center_point].npc[self.object:id()].position_id
			xr_gulag.resetJob(self.object)
			vector_rotate_y (self.object:direction(), -10)
			self.object:set_desired_position()
			self.object:set_desired_direction()

			self.a.pos_vertex = nil
			self.a.dest_vertex = nil
			return false
		end
		self.pos = pos
		return true
	end
end
function action_go_position:execute ()
	action_base.execute (self)

	if Actor and xr_logic.try_switch_to_another_section(self.object, self.a) then
		return
	end

	local tmp_pos_vertex = self.a.dest_vertex
	if tmp_pos_vertex == nil then
		tmp_pos_vertex = kamps[self.a.center_point]:getDestVertex(self.object:id(), self.a.radius)
		if tmp_pos_vertex == nil then return end
		self.a.dest_vertex = tmp_pos_vertex
	end
	if self.a.pos_vertex ~= tmp_pos_vertex then
		if self:check_progress(2000) == false then return end

		if not self.object:accessible(tmp_pos_vertex) then
			local ttp = vector():set(0,0,0)
			tmp_pos_vertex = self.object:accessible_nearest(level.vertex_position(tmp_pos_vertex), ttp)
		end
		self.a.pos_vertex = tmp_pos_vertex

		local kamp_vertex = patrol(self.a.center_point):level_vertex_id(0)
		local math_random_ = math_random
		self.a.pp = level.vertex_in_direction(kamp_vertex, vector():set(math_random_(-1,1), 0, math_random_(-1,1)), math_random_(0,0.5))
		self.object:set_dest_level_vertex_id(tmp_pos_vertex)
		self.object:set_desired_direction(vector():sub(level.vertex_position(self.a.pp),level.vertex_position(tmp_pos_vertex)))
		self.object:set_path_type(game_object.level_path)
		state_mgr.set_state(self.object, self.a.def_state_moving)
		state_mgr.set_state(self.object, self.a.def_state_moving)
	else
		self:check_progress(6000)
	end
end
function action_go_position:finalize ()
	action_base.finalize (self)
end

--' Просто сидит и втыкает
class "action_wait" (action_base)
function action_wait:__init (action_name,storage) super (nil,action_name)
	self.a = storage
end
function action_wait:initialize()
	action_base.initialize(self)
	self.object:set_desired_position()
	self.object:set_desired_direction()

	kamps[self.a.center_point]:increasePops()
end
function action_wait:activate_scheme()
end
function action_wait:execute()
	action_base.execute (self)
	if Actor and xr_logic.try_switch_to_another_section(self.object, self.a) then
		return
	end
	local state, sound, substate = kamps[self.a.center_point]:updateNpc(self.object)

	--' повернуть его лицом к центру
	state_mgr.set_state(self.object, state, nil, nil, {look_position = level.vertex_position(self.a.pp),accuracy = 1.2}, nil, nil, {subanim = substate})
	xr_sound.set_sound(self.object, sound)
end
function action_wait:finalize()
	-- убираем сразу звук гитары
	local stop_sound
	for i,s in ipairs({"guitar_a","harmonica_a"}) do
		local obj = self.object:object(s)
		if obj and obj:attachable_item_enabled() then
			stop_sound = true
			break
		end
	end
	xr_sound.set_sound(self.object, nil, stop_sound)
	kamps[self.a.center_point]:decreasePops()
	action_base.finalize (self)
end
function action_wait:deactivate(npc)
	kamps[self.a.center_point]:removeNpc(npc)
end
function action_wait:death_callback(npc)
	kamps[self.a.center_point]:removeNpc(npc)
end
function action_wait:net_destroy(npc)
	kamps[self.a.center_point]:removeNpc(npc)
end

--added by xStream--
--Идет к бездыханному товарищу
class "action_go_to_deadman" (action_base)
function action_go_to_deadman:__init (npc_name,action_name,storage) super (nil,action_name)
	self.a = storage
end
function action_go_to_deadman:initialize()
	action_base.initialize(self)
	local npc=self.object
	local gi=level.object_by_id(self.a.choosed_deadman)
	if gi then
		--попремся в сторону головы - за шкирятник тащить бум
		self.a.dest_lvid=gi:level_vertex_id()
		local diff=gi:bone_position("bip01_head"):sub(gi:position())
		local len=diff:magnitude()*2.5
		self.a.dest_lvid=npc:vertex_in_direction(self.a.dest_lvid,diff,len)
			if not npc:accessible(self.a.dest_lvid) then
				self.a.dest_lvid = npc:accessible_nearest(level.vertex_position(self.a.dest_lvid), vector():set(0,0,0))
			end
	else
		self.a.dest_lvid=npc:level_vertex_id()
	end
	self.a.reached=0
	self.a.cur_dead_lvid=gi:level_vertex_id()
	--пойдем не спеша...
	state_mgr.set_state(self.object, self.a.def_state_moving)
	--на все гулянки в сторону трупа дается 30 секунд, если не успел, то да ну нафиг заморачиваться :)
	self.a.go_time_end=time_global()+30000
	self.a.captures = (self.a.captures or 0) + 1
	xr_sound.set_sound(npc, nil)
	stop_play_sound(npc)
end

function action_go_to_deadman:execute ()
	action_base.execute (self)
	local npc=self.object
  local gi=level.object_by_id(self.a.choosed_deadman)
	-- если уже задолбало дергать труп, а он застрял (дергаем 3 раза), то нафиг его
	-- так же если какой то мимопроходящий товарищ труп с места сдвинул - то туда ему и дорога (трупу), а нам он больше не интересен
  if self.a.captures==4 or self.a.go_time_end<time_global() or gi==nil or gi:level_vertex_id()~=self.a.cur_dead_lvid then
    deadmansids[self.a.choosed_deadman]=nil
    self.a.choosed_deadman=nil
		self.a.reached=nil
		self.a.captures=nil
  else
		npc:set_dest_level_vertex_id(self.a.dest_lvid)
		-- долгое путешествие до трупа успешно завершилось, ура, товарищи
    if self.a.dest_lvid and self.a.dest_lvid==npc:level_vertex_id() then
      self.a.reached=1
    end
  end
end

function action_go_to_deadman:finalize ()
	action_base.finalize (self)
end

--Тащит трупец
class "action_moving_deadman" (action_base)
function action_moving_deadman:__init (npc_name,action_name,storage) super (nil,action_name)
	self.a = storage
end
function action_moving_deadman:initialize()
	action_base.initialize(self)
  local npc=self.object
  --если пушка в руках - прячем, а то тащить неудобно
  if npc:weapon_unstrapped() then
    npc:set_item(object.idle,nil)
  end
	--потащим медленно, осторожно и на карачках
	npc:set_movement_type(move.walk)
	npc:set_mental_state(anim.danger)
	npc:set_body_state(move.crouch)
	npc:movement_enabled(true)

	--на таскание трупа в грязи даем 40 секунд
  self.a.time_end=time_global()+40000
  self.force=vector():set(0,0,0)
	--на приседание рядом с трупом и разворот лицом дадим секунду
  self.time_drag=time_global()+1000
end

function action_moving_deadman:execute ()
	action_base.execute (self)
  local npc=self.object
  local gi=level.object_by_id(self.a.choosed_deadman)

	--хватит таскать труп - время истекло, пусть другие этим занимаются
  if self.a.time_end<time_global() then
    deadmansids[self.a.choosed_deadman]=nil
    self.a.choosed_deadman=nil
	self.a.reached=nil
    return
  end

	-- смотри мне в глаза!
	local dir=gi:position():sub(npc:position())
	dir.y=0
	npc:set_movement_type(move.walk)
	npc:set_mental_state(anim.danger)
	npc:set_body_state(move.crouch)
	npc:movement_enabled(true)
	npc:set_sight(look.direction,dir,true)

  if self.a.ps and self.time_drag<time_global() then
    npc:set_dest_level_vertex_id(self.a.drop_lvid)
  	-- непись сильный - тащит левой рукой за туловище трупа
	local bone="bip01_spine1"
    local dir=npc:bone_position("bip01_l_hand"):sub(gi:bone_position(bone))
    dir:mul(25000)
	dir.y=9000
    self.force:mul(0.5)
    dir:mul(0.5)
    self.force:add(dir)
    if self.a.ps:get_element_by_bone_name(bone) then
		self.a.ps:get_element_by_bone_name(bone):apply_force(self.force.x,self.force.y,self.force.z)
    else
    end
  end

	-- уф! дотащили... всем спасибо, все свободны...
  if self.a.drop_lvid and self.a.drop_lvid==npc:level_vertex_id() then
    deadmansids[self.a.choosed_deadman]=nil
    self.a.choosed_deadman=nil
    self.a.reached=nil
  end
end

function action_moving_deadman:finalize ()
	action_base.finalize (self)
	state_mgr.set_state(self.object, self.a.def_state_moving)
end
--end--

--Таблица соответствий состояния лагеря и допустимых анимаций и звуков.
local ks_avail_state = {
	idle			= { directed	= { "wait", "sit", "sit_ass", "sit_knee", "eat_kolbasa", "eat_vodka", "eat_energy", "eat_bread", "eat_sigaret", "trans"},
						undirected	= { "wait", "sit", "sit_ass", "sit_knee", "eat_kolbasa", "eat_vodka", "eat_energy", "eat_bread", "eat_sigaret", "trans"}},
	pre_harmonica		= { directed	= { "wait_harmonica"},
						undirected	= { "wait", "sit", "sit_ass", "sit_knee", "eat_kolbasa", "eat_vodka", "eat_energy", "eat_bread", "eat_sigaret", "trans"}},
	harmonica		= { directed	= { "play_harmonica"},
						undirected	= { "wait", "sit", "sit_ass", "sit_knee", "eat_kolbasa", "eat_vodka", "eat_energy", "eat_bread", "eat_sigaret", "trans"}},
	post_harmonica		= { directed	= { "wait_harmonica"},
						undirected	= { "wait", "sit", "sit_ass", "sit_knee", "eat_kolbasa", "eat_vodka", "eat_energy", "eat_bread", "eat_sigaret", "trans"}},
	pre_guitar		= { directed	= { "wait_guitar"},
						undirected	= { "wait", "sit", "sit_ass", "sit_knee", "eat_kolbasa", "eat_vodka", "eat_energy", "eat_bread", "eat_sigaret", "trans"}},
	guitar			= { directed	= { "play_guitar"},
						undirected	= { "wait", "sit", "sit_ass", "sit_knee", "eat_kolbasa", "eat_vodka", "eat_energy", "eat_bread", "eat_sigaret", "trans"}},
	post_guitar		= { directed	= { "wait_guitar"},
						undirected	= { "wait", "sit", "sit_ass", "sit_knee", "eat_kolbasa", "eat_vodka", "eat_energy", "eat_bread", "eat_sigaret", "trans"}},
	story			= { directed	= { "declarate"},
						undirected	= { "wait", "sit", "sit_ass", "sit_knee", "eat_kolbasa", "eat_vodka", "eat_energy", "eat_bread", "eat_sigaret", "trans"}},
	post_story		= { directed	= { "declarate"},
						undirected	= { "wait", "sit", "sit_ass", "sit_knee", "eat_kolbasa", "eat_vodka", "eat_energy", "eat_bread", "eat_sigaret", "trans"}},
	pre_joke		= { directed	= { "declarate"},
						undirected	= { "wait", "sit", "sit_ass", "sit_knee", "eat_kolbasa", "eat_vodka", "eat_energy", "eat_bread", "eat_sigaret", "trans"}},
	joke			= { directed	= { "declarate"},
						undirected	= { "wait", "sit", "sit_ass", "sit_knee", "eat_kolbasa", "eat_vodka", "eat_energy", "eat_bread", "eat_sigaret", "trans"}},
	post_joke		= { directed	= { "declarate"},
						undirected	= { "wait", "sit", "sit_ass", "sit_knee", "eat_kolbasa", "eat_vodka", "eat_energy", "eat_bread", "eat_sigaret", "trans"}}
}
local ks_avail_sound = {
	idle			= { directed = "idle", undirected = "idle"},
	pre_harmonica		= { directed = "pre_harmonica", undirected = ""},
	harmonica		= { directed = "play_harmonica", undirected = ""},
	post_harmonica		= { directed = "", undirected = "reac_harmonica"},
	pre_guitar		= { directed = "pre_guitar", undirected = ""},
	guitar			= { directed = "play_guitar", undirected = ""},
	post_guitar		= { directed = "", undirected = "reac_guitar"},
	story			= { directed = "play_story", undirected = ""},
	post_story		= { directed = "", undirected = "reac_story"},
	pre_joke		= { directed = "pre_joke", undirected = ""},
	joke			= { directed = "play_joke", undirected = ""},
	post_joke		= { directed = "", undirected = "reac_joke"}
}
-- Таблица допустимых переходов между состояниями с вероятностями.
local ks_trans_kamp = {
	idle			= { idle = 0, pre_harmonica = 20, pre_guitar = 30, story = 20, pre_joke = 30 },
	pre_harmonica		= { harmonica = 100 },
	harmonica		= { post_harmonica = 100 },
	post_harmonica		= { idle = 70, harmonica = 30 },
	pre_guitar		= { guitar = 100 },
	guitar			= { post_guitar = 100 },
	post_guitar		= { idle = 70, guitar = 30 },
	story			= { post_story = 100 },
	post_story		= { idle = 100 },
	pre_joke		= { joke = 100 },
	joke			= { post_joke = 100 },
	post_joke		= { idle = 100 }
}

class "CKampManager"
function CKampManager:__init(storage, avoid_spots)
	self.st = storage
	self.kamp_name = storage.center_point
	self.patrol = patrol(storage.center_point)
	self.center = self.patrol:level_vertex_id(0)
	self.npc = {}
	self.population = 0
	self.kamp_state = "idle"

	-- Таблица таймаутов по состоянию. Если состояние установилось, то некоторое время оно не может быт изменено.
	self.timeout = {
		idle				= { min = 30000 },
		pre_harmonica		= { min = 3000 },
		harmonica			= { min = 5000, soundstart = true },
		post_harmonica		= { min = 3000 },
		pre_guitar			= { min = 3000 },
		guitar				= { min = 5000, soundstart = true },
		post_guitar			= { min = 3000 },
		story				= { min = 1000, soundstart = true },
		post_story			= { min = 3000 },
		pre_joke			= { min = 3000 },
		joke				= { min = 5000, soundstart = true },
		post_joke			= { min = 3000 }
	}
	-- Таблица глобальных состояний лагеря.
	self.kamp_states = {
		idle = true,
		pre_harmonica = false, harmonica = false, post_harmonica = false,
		pre_guitar = false, guitar = false, post_guitar = false,
		story = false, post_story = false,
		pre_joke = true, joke = true, post_joke = true
	}

	-- Хранилище для режиссера лагеря. Режиссерем является сталкер, затеявший необычное поведение
	self.director = nil
	self.free = {1,2,3,4,5,6,7,8}
	if avoid_spots > 0 then
		for i = 8, 1, -1 do
			if bit_and(avoid_spots, 2^(i-1)) > 0 then
				table.remove(self.free,i)
			end
		end
	end
end
local posvecs = {
	vector():set(-1, 0, 1),
	vector():set(0, 0, 1),
	vector():set(1, 0, 1),
	vector():set(-1, 0, 0),
	vector():set(1, 0, 0),
	vector():set(-1, 0, -1),
	vector():set(0, 0, -1),
	vector():set(1, 0, -1)
}
function CKampManager:selectPosition(npc)
	-- создаем список доступных позиций
	if #self.free > 0 then
		local radius = self.st.radius
		local i
		local dest_pos_distance = 10000
		for k, v in pairs(self.free) do
			local vx = level.vertex_in_direction(self.center, posvecs[v], radius)
			local dist_to_vx = npc:position():distance_to(level.vertex_position(vx))
			if dist_to_vx < dest_pos_distance then
				dest_pos_distance = dist_to_vx
				i = k
			end
		end
		if i == nil then i = math_random(#self.free) end
		self.npc[npc:id()].position_id = table.remove(self.free, i)
	end
end
function CKampManager:getDestVertex(npc_id, radius)
	local pv = posvecs
	if self.npc == nil or self.npc[npc_id] == nil then return nil end
	local npc_kamp_pos = self.npc[npc_id] and self.npc[npc_id].position_id
	if npc_kamp_pos == nil then
		abort("get dest Vertex: npc [%s] not camp member or has no position", npc_id)
		return nil
	end
	return level.vertex_in_direction(self.center, pv[npc_kamp_pos], radius)
end
function CKampManager:proceedState(npc)
	-- Проверка на таймаут
	local npc_id = npc:id()
	if self.npc == nil or self.npc[npc_id] == nil then return end
	local active_sound_count = npc:active_sound_count()
	if self.npc[npc_id].need_sound_begin == true then
		if active_sound_count == 0 then
			return
		else
			self.npc[npc_id].need_sound_begin = false
		end
	end
	if self.begin ~= nil and
	   time_global() - self.begin < self.timeout[self.kamp_state].min
	then
		return
	end

	-- Если режиссер не закончил говорить - ждем конца фразы.
	if active_sound_count > 0 then
		return
	end

	-- В случае с историей переход обрабатывается отдельно
	if self.kamp_state == "post_story" then
		if self.story_last < self.story_max - 1 then
			self.npc[npc_id].begin = nil
			self.npc[npc_id].need_sound_begin = true
			self.director = npc_id
			self.kamp_state = "story"
			self.begin = time_global()
			for kk,vv in pairs(self.npc) do
				vv.new = true
			end
			return
		else
			self.selected_story = nil
		end
	end
	-- Определяются допустимые в данный момент переходы.
	local temp = {}
	local max_rnd = 0

	local trans_kamp = ks_trans_kamp
	for k,v in pairs(trans_kamp[self.kamp_state]) do
		-- Определяются допустимые состояния для лагеря.
		if self.kamp_states[k] == true then
			temp[k] = v
			max_rnd = max_rnd + v
		end
	end
	-- Осуществляется рандомный взвешенный переход.
	if max_rnd == 0 then
		-- Если переходить некуда - переходим в айдл
		temp["idle"] = 100
		max_rnd = 100
	end
	local p = math_random(0,max_rnd)
	for k,v in pairs(temp) do
		p = p - v
		if p <= 0 then
			if k == "idle" then
				self.director = nil
				if self.kamp_state ~= "idle" then
					self.npc[npc_id].begin = nil
				end
			else
				self.npc[npc_id].begin = nil
				if self.timeout[k].soundstart == true then
					self.npc[npc_id].need_sound_begin = true
				end
				self.director = npc_id
				self.censor = nil
			end
			self.kamp_state = k
			self.begin = time_global()
			-- Меняем таймаут для истории
			if k == "post_story" then
				local dep = sound_theme.theme[self.selected_story].depence[self.story_last]
				if dep and dep.min and dep.max then
					self.timeout["post_story"].min = math_random(dep.min*1000, dep.max*1000)
				end
			end
			for kk,vv in pairs(self.npc) do
				vv.new = true
			end
			return
		end
	end
end
function CKampManager:proceedRole(npc, director)
	-- Определить список доступных анимаций по состоянию лагеря.
	-- определить список доступных анимаций по наличию предметов
	-- выбрать одну из них (то же самое со звуком).
	local sound
	local state
	local npc_id = npc:id()
	if self.npc == nil or self.npc[npc_id] == nil then return nil, nil end
	if self.npc[npc_id].begin == nil or
	   time_global() - self.npc[npc_id].begin >= self.npc[npc_id].state_idle
	then
		local states
		if director then
			states = ks_avail_state[self.kamp_state].directed
			sound = ks_avail_sound[self.kamp_state].directed
		else
			states = ks_avail_state[self.kamp_state].undirected
			sound = ks_avail_sound[self.kamp_state].undirected
		end
		-- Выбирать новое состояние только раз в какое то время.
		local temp = {}
		for k,v in pairs(states) do
			if self.npc[npc_id].states[v] == true then
				temp[#temp+1] = v
			end
		end

		-- Если мы решили говорить историю, надо выбрать какую именно говорить.
		if sound == "play_story" and not self.selected_story then
			self.selected_story = table.fastrand(xr_info.camp_stories)
		end

		self.npc[npc_id].begin = time_global()
		state = #temp > 0 and temp[math_random(#temp)] or "idle"
		self.npc[npc_id].state_selected = state
		self.npc[npc_id].state_idle = math_random(15000,20000)
	else
		if director then
			sound = ks_avail_sound[self.kamp_state].directed
		else
			sound = ks_avail_sound[self.kamp_state].undirected
		end
		state = self.npc[npc_id].state_selected
	end
	return state, sound
end

function CKampManager:updateNpc(npc)
	-- Просим лагерь выбрать текущее состояние. Менять состояние лагеря
	-- имеет право только режиссер.
	local npc_id = npc:id()
	if self.npc == nil or self.npc[npc_id] == nil then return nil, nil, nil end
	local camp_npc = self.npc[npc_id]
	-- Проверка что сталкер может делать, а что нет.
	local director = self.director == nil or self.director == npc_id

	if camp_npc.comm_class == 0 then
		if director or camp_npc.camp_pop ~= self.population then
			self:checkNpcAbility(npc)
		end
	end
	if director then
		self:proceedState(npc)
	end
	-- Говорим чудаку выбрать себе состояние для текущего состояния лагеря.
	local state, sound = self:proceedRole(npc, director)

	local substate = nil
	if state == "wait_harmonica" then
		if sound == "pre_harmonica" and camp_npc.new == true then
			xr_sound.set_sound_play(npc, "intro_music", math_random(2000,3000))
			camp_npc.new = false
		end
		state = "harmonica"
		xr_kamp.kamp_stalkers[npc_id] = false
	elseif state == "play_harmonica" then
		state = "harmonica"
		substate = 1
		xr_kamp.kamp_stalkers[npc_id] = false
	elseif state == "wait_guitar" then
		if sound == "pre_guitar" and camp_npc.new == true then
			xr_sound.set_sound_play(npc, "intro_music", math_random(2000,3000))
			camp_npc.new = false
		end
		state = "guitar"
		xr_kamp.kamp_stalkers[npc_id] = false
	elseif state == "play_guitar" then
		state = "guitar"
		substate = 1
		xr_kamp.kamp_stalkers[npc_id] = false
	elseif state == "eat_sigaret" then
		particles_object("weapons\\generic_sigarets"):play_at_pos((npc:object("sigaret")):position())
	elseif state == "declarate" then
		if camp_npc.new == true then
			if sound == "pre_joke" then
				xr_sound.set_sound_play(npc, "intro_joke", math_random(2000,3000))
			elseif sound == "play_joke" then
				xr_sound.set_sound_play(npc, "joke", math_random(2000,3000))
			elseif sound == "play_story" then
				xr_sound.set_sound_play(npc, self.selected_story)
				self.story_last, self.story_max = xr_sound.get_last_IDS(npc, self.selected_story)
				if self.story_last==nil then
					self.story_last=0
					self.story_max=1
					xr_sound.set_sound_play(npc, "threat_back", math_random(1000,2000))
					--- dirty hack
					self.kamp_state="idle"
					self.forbiddendirector=self.director
					self.director=nil
				end
			end
			camp_npc.new = false
		end

		if camp_npc.comm_class == -1 then
			local t = math_mod(npc_id, 2)
			if t == 0 then
				state = "trans_0"
			else
				state = "trans_1"
			end
		elseif camp_npc.comm_class == -2 then
			state = "trans_zombied"
		else
			local t = math_mod(npc_id, 3)
			if t == 0 then
				state = "sit"
			elseif t == 1 then
				state = "sit_ass"
			else
				state = "sit_knee"
			end
		end
		xr_kamp.kamp_stalkers[npc_id] = false
	elseif state == "trans" then
		if camp_npc.comm_class == -1 then
			local t = math_mod(npc_id, 2)
			if t == 0 then
				state = "trans_0"
			else
				state = "trans_1"
			end
		elseif camp_npc.comm_class == -2 then
			state = "trans_zombied"
		end
		xr_kamp.kamp_stalkers[npc_id] = false
	else
		xr_kamp.kamp_stalkers[npc_id] = true
	end
	-- Выбор реальных звуков
	if sound == "idle" then
		sound = "weather, state"
	elseif sound == "reac_guitar" then
		sound = "reac_music"
	elseif sound == "reac_harmonica" then
		sound = "reac_music"
	elseif sound == "reac_joke" then
		sound = ""
		if camp_npc.new == true then
			if self.censor == nil then
				xr_sound.set_sound_play(npc, "reac_joke", math_random(2000,3000))
				self.censor = npc_id
			else
				xr_sound.set_sound_play(npc, "story_reac_laughter", math_random(100,300))
			end
			camp_npc.new = false
		end
	elseif sound == "reac_story" then
		sound = ""
		if camp_npc.new == true then
			local dep = sound_theme.theme[self.selected_story].depence[(self.story_last or 0) + 1]
			if dep then
				if dep.type == "all" then
					xr_sound.set_sound_play(npc, dep.theme, math_random(100,300))
				else
					sound = dep.theme
				end
			end
		end
	elseif sound == "reac_story" then
		sound = ""
	else
		sound = ""
	end

	return state, sound, substate
end
function CKampManager:checkNpcAbility(npc)
	local npc_id = npc:id()
	local camp_npc = self.npc and self.npc[npc_id]
	if not camp_npc then return end
	local npc_states = camp_npc.states
	-- есть колбасу
	if npc:object("kolbasa") then
		npc_states["eat_kolbasa"] = true
	else
		npc_states["eat_kolbasa"] = false
	end
	-- пить водку
	if npc:object("vodka") then
		npc_states["eat_vodka"] = true
	else
		npc_states["eat_vodka"] = false
	end
	-- пить енергитический напиток
	if npc:object("energy_drink") then
		npc_states["eat_energy"] = true
	else
		npc_states["eat_energy"] = false
	end
	-- есть хлеб
	if npc:object("bread") then
		npc_states["eat_bread"] = true
	else
		npc_states["eat_bread"] = false
	end
	camp_npc.camp_pop = self.population
	-- играть на гармошке
	if self.population > 1 and npc:object("harmonica_a") then
		npc_states["play_harmonica"] = true
		npc_states["wait_harmonica"] = true
		self.kamp_states["pre_harmonica"] = true
		self.kamp_states["harmonica"] = true
		self.kamp_states["post_harmonica"] = true
	else
		npc_states["play_harmonica"] = false
		npc_states["wait_harmonica"] = false
		self.kamp_states["pre_harmonica"] = false
		self.kamp_states["harmonica"] = false
		self.kamp_states["post_harmonica"] = false
	end
	-- играть на гитаре
	if self.population > 1 and npc:object("guitar_a") then
		npc_states["play_guitar"] = true
		npc_states["wait_guitar"] = true
		self.kamp_states["pre_guitar"] = true
		self.kamp_states["guitar"] = true
		self.kamp_states["post_guitar"] = true
	else
		npc_states["play_guitar"] = false
		npc_states["wait_guitar"] = false
		self.kamp_states["pre_guitar"] = false
		self.kamp_states["guitar"] = false
		self.kamp_states["post_guitar"] = false
	end

	-- анекдоты
	if self.population > 1 then
		self.kamp_states["pre_joke"] = true
		self.kamp_states["joke"] = true
		self.kamp_states["post_joke"] = true

		self.kamp_states["story"] = true
		self.kamp_states["post_story"] = true
	else
		self.kamp_states["pre_joke"] = false
		self.kamp_states["joke"] = false
		self.kamp_states["post_joke"] = false

		self.kamp_states["story"] = false
		self.kamp_states["post_story"] = false
	end

	-- курить
	if npc:object("sigaret") then
		npc_states["eat_sigaret"] = true
	else
		npc_states["eat_sigaret"] = false
	end
end
function CKampManager:addNpc(npc)
	local npc_id = npc:id()
	if not self.npc or self.npc[npc_id] ~= nil then return end

	local comm_type = 0
	if npc:character_community() == "monolith" then
		 comm_type = -1
	elseif npc:character_community() == "zombied" then
		 comm_type = -2
	end
	if comm_type ~= 0 then
		self.npc[npc_id] = {name = npc:name(), position_id = nil, comm_class = comm_type, camp_pop = 0, states = {
								stand_wait = false, sit = false, sit_ass = false, sit_knee = false, declarate = true,
								eat_kolbasa = false, eat_vodka = false, eat_energy = false, eat_bread = false, eat_sigaret = false, trans = true,
								play_harmonica = false, play_guitar = false, play_joke = false, play_story = false}}
	else
		self.npc[npc_id] = {name = npc:name(), position_id = nil, comm_class = 0, camp_pop = 0, states = {
								stand_wait = true, sit = true, sit_ass = true, sit_knee = true, declarate = true,
								eat_kolbasa = false, eat_vodka = false, eat_energy = false, eat_bread = false, eat_sigaret = true, trans = false,
								play_harmonica = false, play_guitar = false, play_joke = false, play_story = false}}
	end
	self:selectPosition(npc)
end
function CKampManager:removeNpc(npc)
	local npc_id = npc:id()
	local t = self.npc[npc_id]
	if t ~= nil then
		-- Если удаляем режиссера - необходимо форсированно перевести лагерь в идловое состояние.
		if self.director == npc_id then
			self.director = nil
			t.begin = nil
			self.censor = nil
			self.kamp_state = "idle"
			self.begin = time_global()
			for kk,vv in pairs(self.npc) do
				vv.new = true
			end
			xr_sound.set_sound(npc, nil)
			stop_play_sound(npc)
		end
		local cur_npc_spot = t.position_id
		if cur_npc_spot ~= nil then
			table.insert(self.free, cur_npc_spot)
		end
		self.npc[npc_id] = nil
	end
end
function CKampManager:increasePops()
	self.population = self.population + 1
end
function CKampManager:decreasePops()
	self.population = self.population - 1
end
----------------------------------------------------------------------------------------------------------------------
--Kamp binder
----------------------------------------------------------------------------------------------------------------------
local prop_kamp_end = xr_evaluators_id.stohe_kamp_base + 1
local prop_on_position = prop_kamp_end + 1
local prop_see_deadman = prop_kamp_end + 2
local prop_can_move_deadman = prop_kamp_end + 4
local operator_go_position = xr_actions_id.stohe_kamp_base + 1
local operator_wait = operator_go_position + 2
local operator_go_to_deadman = operator_go_position + 3
local operator_move_deadman = operator_go_position + 4
local xr_actions_id_alife = xr_actions_id.alife
local wp_stalker_ids_property_alive_true = world_property(stalker_ids.property_alive, true)
local wp_stalker_ids_property_danger_false = world_property(stalker_ids.property_danger, false)
local wp_stalker_ids_property_enemy_false = world_property(stalker_ids.property_enemy, false)
local wp_stalker_ids_property_anomaly_false = world_property(stalker_ids.property_anomaly, false)
local wp_prop_kamp_end_true = world_property(prop_kamp_end, true)
local wp_prop_kamp_end_false = world_property(prop_kamp_end, false)
local wp_prop_on_position_true = world_property(prop_on_position, true)
local wp_prop_see_deadman_true = world_property(prop_see_deadman, true)
local wp_prop_see_deadman_false = world_property(prop_see_deadman, false)
local wp_prop_can_move_deadman_true = world_property(prop_can_move_deadman, true)
local wp_prop_can_move_deadman_false = world_property(prop_can_move_deadman, false)

function add_to_binder(object, storage)
	local manager = object:motivation_action_manager()

	-- Evaluators
	manager:add_evaluator (prop_kamp_end, 		this.evaluator_kamp_end		("kamp_end", storage))
	manager:add_evaluator (prop_on_position,	this.evaluator_on_position	("kamp_on_position", storage))

	local zombi=object:character_community()=="zombied" or object:character_community()=="trader" or
		  object:character_community()=="arena_enemy" or object:name()=="mil_stalker0012" or object:name()=="yantar_ecolog_general"
	if zombi then
		manager:add_evaluator (prop_see_deadman, property_evaluator_const(false))
		manager:add_evaluator (prop_can_move_deadman, property_evaluator_const(false))
	else
		manager:add_evaluator (prop_see_deadman,	this.evaluator_see_deadman	("see_deadman", storage))
		manager:add_evaluator (prop_can_move_deadman,	this.evaluator_can_move_deadman	("can_move_deadman", storage))
	end

	-- Actions
	local action = this.action_wait ("action_kamp_wait", storage)
	action:add_precondition		(wp_stalker_ids_property_alive_true)
	action:add_precondition		(wp_stalker_ids_property_danger_false)
	action:add_precondition		(wp_stalker_ids_property_enemy_false)
	action:add_precondition		(wp_stalker_ids_property_anomaly_false)
	action:add_precondition		(wp_prop_see_deadman_false)
	bind_stalker.addCommonPrecondition(action)
	action:add_precondition		(wp_prop_on_position_true)
	action:add_effect 		(wp_prop_kamp_end_true)
	manager:add_action (operator_wait, action)
	storage.actions[ action ] = true

	action = this.action_go_position ("action_go_kamp", storage)
	action:add_precondition		(wp_stalker_ids_property_alive_true)
	action:add_precondition		(wp_stalker_ids_property_danger_false)
	action:add_precondition		(wp_stalker_ids_property_enemy_false)
	action:add_precondition		(wp_stalker_ids_property_anomaly_false)
	action:add_precondition		(wp_prop_see_deadman_false)
	bind_stalker.addCommonPrecondition(action)
	action:add_precondition		(wp_prop_kamp_end_false)
	action:add_effect		(wp_prop_on_position_true)
	manager:add_action (operator_go_position, action)

	-- видим труп - идем разбираться...
	action = this.action_go_to_deadman (object:name(),"action_go_to_deadman", storage)
	action:add_precondition		(wp_stalker_ids_property_alive_true)
	action:add_precondition		(wp_stalker_ids_property_danger_false)
	action:add_precondition		(wp_stalker_ids_property_enemy_false)
	action:add_precondition		(wp_stalker_ids_property_anomaly_false)
	action:add_precondition		(wp_prop_see_deadman_true)
	action:add_precondition		(wp_prop_can_move_deadman_false)
	action:add_precondition		(wp_prop_kamp_end_false)
	action:add_effect		(wp_prop_can_move_deadman_true)
	manager:add_action (operator_go_to_deadman, action)

	--тащим труп подальше от тусовки
	action = this.action_moving_deadman (object:name(),"action_moving_deadman", storage)
	action:add_precondition		(wp_stalker_ids_property_alive_true)
	action:add_precondition		(wp_stalker_ids_property_danger_false)
	action:add_precondition		(wp_stalker_ids_property_enemy_false)
	action:add_precondition		(wp_stalker_ids_property_anomaly_false)
	action:add_precondition		(wp_prop_see_deadman_true)
	action:add_precondition		(wp_prop_can_move_deadman_true)
	action:add_precondition		(wp_prop_kamp_end_false)
	action:add_effect		(wp_prop_see_deadman_false)
	action:add_effect		(wp_prop_can_move_deadman_false)
	manager:add_action (operator_move_deadman, action)

	action = manager:action (xr_actions_id_alife)
	action:add_precondition		(wp_prop_kamp_end_true)

end
-- включение лагеря
function set_scheme(npc, ini, scheme, section, gulag_name)
	local st = xr_logic.assign_storage_and_bind(npc, ini, scheme, section)

	st.logic     = xr_logic.cfg_get_switch_conditions(ini, section, npc)

	if section and ini:section_exist(section) then
		if not ini:line_exist(section, "center_point") then
			abort("xr_kamp scheme %s, section %s: missing center_point field", scheme, section)
			return
		end
		if gulag_name and gulag_name ~= "" then
			st.center_point  = gulag_name .. "_" .. ini:r_string(section, "center_point")
		else
			st.center_point  = ini:r_string(section, "center_point")
		end
		st.radius = (ini:line_exist(section, "radius") and ini:r_float(section, "radius")) or 2
		st.def_state_moving = (ini:line_exist(section, "def_state_moving") and ini:r_string(section, "def_state_moving")) or "walk"
	else
			abort("xr_kamp scheme %s has bad or missing section: %s", scheme, tostring(section))
			return
	end
	st.pos_vertex = nil
	st.dest_vertex = nil

	if kamps[st.center_point] == nil then
		local avoid_pos	= utils.cfg_get_number(ini, section, "avoid_pos", npc, false, 0)
		kamps[st.center_point] = CKampManager(st, avoid_pos)
	end
	kamps[st.center_point]:addNpc(npc)
end
